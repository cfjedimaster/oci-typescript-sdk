/**
 * Resource Manager API
 * API for the Resource Manager service. Use this API to install, configure, and manage resources via the "infrastructure-as-code" model. For more information, see [Overview of Resource Manager](/iaas/Content/ResourceManager/Concepts/resourcemanager.htm).
 * OpenAPI spec version: 20180917
 *
 *
 * NOTE: This class is auto generated by OracleSDKGenerator.
 * Do not edit the class manually.
 *
 * Copyright (c) 2020, Oracle and/or its affiliates.  All rights reserved.
 * This software is dual-licensed to you under the Universal Permissive License (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl or Apache License 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose either license.
 */

import common = require("oci-common");
import * as requests from "./request";
import * as models from "./model";
import * as responses from "./response";
import { paginateRecords, paginateResponses } from "oci-common";
import { ResourceManagerWaiter } from "./resourcemanager-waiter";
import { composeResponse, composeRequest } from "oci-common";

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum ResourceManagerApiKeys {}

export class ResourceManagerClient {
  protected static serviceEndpointTemplate = "https://resourcemanager.{region}.{secondLevelDomain}";
  protected "_endpoint": string = "";
  protected "_defaultHeaders": any = {};
  protected "_waiters": ResourceManagerWaiter;

  protected _httpClient: common.HttpClient;

  constructor(params: common.AuthParams) {
    const requestSigner = params.authenticationDetailsProvider
      ? new common.DefaultRequestSigner(params.authenticationDetailsProvider)
      : null;
    this._httpClient = params.httpClient || new common.FetchHttpClient(requestSigner);

    if (
      params.authenticationDetailsProvider &&
      common.isRegionProvider(params.authenticationDetailsProvider)
    ) {
      const provider: common.RegionProvider = params.authenticationDetailsProvider;
      if (provider.getRegion()) {
        this.region = provider.getRegion();
      }
    }
  }

  /**
   * Sets the endpoint to call (ex, https://www.example.com).
   * @param endpoint The endpoint of the service.
   */
  public set endpoint(endpoint: string) {
    this._endpoint = endpoint;
    this._endpoint = this._endpoint + "/20180917";
  }

  /**
   * Sets the region to call (ex, Region.US_PHOENIX_1).
   * Note, this will call {@link #endpoint(String) endpoint} after resolving the endpoint.
   * @param region The region of the service.
   */
  public set region(region: common.Region) {
    this.endpoint = common.EndpointBuilder.createEndpointFromRegion(
      ResourceManagerClient.serviceEndpointTemplate,
      region
    );
  }

  /**
   * Sets the regionId to call (ex, 'us-phoenix-1').
   *
   * Note, this will first try to map the region ID to a known Region and call {@link #region(Region) region}.
   * If no known Region could be determined, it will create an endpoint assuming its in default Realm OC1
   * and then call {@link #endpoint(String) endpoint}.
   * @param regionId The public region ID.
   */
  public set regionId(regionId: string) {
    this.endpoint = common.EndpointBuilder.createEndpointFromRegionId(
      ResourceManagerClient.serviceEndpointTemplate,
      regionId
    );
  }

  /**
   * Creates a new ResourceManagerWaiter for resources for this service.
   *
   * @param config The waiter configuration for termination and delay strategy
   * @return The service waiters.
   */
  public createWaiters(config?: common.WaiterConfiguration): ResourceManagerWaiter {
    this._waiters = new ResourceManagerWaiter(this, config);
    return this._waiters;
  }

  /**
   * Gets the waiters available for resources for this service.
   *
   * @return The service waiters.
   */
  public getWaiters(): ResourceManagerWaiter {
    if (this._waiters) {
      return this._waiters;
    }
    throw Error("Waiters do not exist. Please create waiters.");
  }

  /**
   * Indicates the intention to cancel the specified job.
   * Cancellation of the job is not immediate, and may be delayed,
   * or may not happen at all.
   *
   * @param CancelJobRequest
   * @return CancelJobResponse
   * @throws OciError when an error occurs
   */
  public async cancelJob(
    cancelJobRequest: requests.CancelJobRequest
  ): Promise<responses.CancelJobResponse> {
    const pathParams = {
      "{jobId}": cancelJobRequest.jobId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": cancelJobRequest.opcRequestId,
      "if-match": cancelJobRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/jobs/{jobId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CancelJobResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Moves a Stack and it's associated Jobs into a different compartment.
   * @param ChangeStackCompartmentRequest
   * @return ChangeStackCompartmentResponse
   * @throws OciError when an error occurs
   */
  public async changeStackCompartment(
    changeStackCompartmentRequest: requests.ChangeStackCompartmentRequest
  ): Promise<responses.ChangeStackCompartmentResponse> {
    const pathParams = {
      "{stackId}": changeStackCompartmentRequest.stackId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": changeStackCompartmentRequest.ifMatch,
      "opc-request-id": changeStackCompartmentRequest.opcRequestId,
      "opc-retry-token": changeStackCompartmentRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/stacks/{stackId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeStackCompartmentRequest.changeStackCompartmentDetails,
        "ChangeStackCompartmentDetails",
        models.ChangeStackCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeStackCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a job.
   * @param CreateJobRequest
   * @return CreateJobResponse
   * @throws OciError when an error occurs
   */
  public async createJob(
    createJobRequest: requests.CreateJobRequest
  ): Promise<responses.CreateJobResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-request-id": createJobRequest.opcRequestId,
      "opc-retry-token": createJobRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/jobs",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createJobRequest.createJobDetails,
        "CreateJobDetails",
        models.CreateJobDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateJobResponse>{},
        body: await response.json(),
        bodyKey: "job",
        bodyModel: "model.Job",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a stack in the specified comparment.
   * Specify the compartment using the compartment ID.
   * For more information, see [Create a Stack](https://docs.cloud.oracle.com/iaas/Content/ResourceManager/Tasks/usingconsole.htm#CreateStack).
   *
   * @param CreateStackRequest
   * @return CreateStackResponse
   * @throws OciError when an error occurs
   */
  public async createStack(
    createStackRequest: requests.CreateStackRequest
  ): Promise<responses.CreateStackResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-request-id": createStackRequest.opcRequestId,
      "opc-retry-token": createStackRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/stacks",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createStackRequest.createStackDetails,
        "CreateStackDetails",
        models.CreateStackDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateStackResponse>{},
        body: await response.json(),
        bodyKey: "stack",
        bodyModel: "model.Stack",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Deletes the specified stack object.
   * @param DeleteStackRequest
   * @return DeleteStackResponse
   * @throws OciError when an error occurs
   */
  public async deleteStack(
    deleteStackRequest: requests.DeleteStackRequest
  ): Promise<responses.DeleteStackResponse> {
    const pathParams = {
      "{stackId}": deleteStackRequest.stackId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": deleteStackRequest.opcRequestId,
      "if-match": deleteStackRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/stacks/{stackId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteStackResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Returns the specified job along with the job details.
   * @param GetJobRequest
   * @return GetJobResponse
   * @throws OciError when an error occurs
   */
  public async getJob(getJobRequest: requests.GetJobRequest): Promise<responses.GetJobResponse> {
    const pathParams = {
      "{jobId}": getJobRequest.jobId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getJobRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/jobs/{jobId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetJobResponse>{},
        body: await response.json(),
        bodyKey: "job",
        bodyModel: "model.Job",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Returns log entries for the specified job in JSON format.
   *
   * @param GetJobLogsRequest
   * @return GetJobLogsResponse
   * @throws OciError when an error occurs
   */
  public async getJobLogs(
    getJobLogsRequest: requests.GetJobLogsRequest
  ): Promise<responses.GetJobLogsResponse> {
    const pathParams = {
      "{jobId}": getJobLogsRequest.jobId
    };

    const queryParams = {
      "type": getJobLogsRequest.type,
      "levelGreaterThanOrEqualTo": getJobLogsRequest.levelGreaterThanOrEqualTo,
      "sortOrder": getJobLogsRequest.sortOrder,
      "limit": getJobLogsRequest.limit,
      "page": getJobLogsRequest.page,
      "timestampGreaterThanOrEqualTo": getJobLogsRequest.timestampGreaterThanOrEqualTo,
      "timestampLessThanOrEqualTo": getJobLogsRequest.timestampLessThanOrEqualTo
    };

    let headerParams = {
      "opc-request-id": getJobLogsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/jobs/{jobId}/logs",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetJobLogsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "LogEntry[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.LogEntry objects
   * contained in responses from the getJobLogs operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public getAllJobLogs(
    request: requests.GetJobLogsRequest
  ): AsyncIterableIterator<models.LogEntry> {
    return paginateRecords(request, req => this.getJobLogs(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the getJobLogs operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public getAllJobLogsResponses(
    request: requests.GetJobLogsRequest
  ): AsyncIterableIterator<responses.GetJobLogsResponse> {
    return paginateResponses(request, req => this.getJobLogs(req));
  }

  /**
   * Returns raw log file for the specified job in text format.
   * Returns a maximum of 100,000 log entries.
   *
   * @param GetJobLogsContentRequest
   * @return GetJobLogsContentResponse
   * @throws OciError when an error occurs
   */
  public async getJobLogsContent(
    getJobLogsContentRequest: requests.GetJobLogsContentRequest
  ): Promise<responses.GetJobLogsContentResponse> {
    const pathParams = {
      "{jobId}": getJobLogsContentRequest.jobId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getJobLogsContentRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/jobs/{jobId}/logs/content",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetJobLogsContentResponse>{},

        body: await response.text(),
        bodyKey: "value",
        bodyModel: "string",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Returns the Terraform configuration file for the specified job in .zip format.
   * Returns an error if no zip file is found.
   *
   * @param GetJobTfConfigRequest
   * @return GetJobTfConfigResponse
   * @throws OciError when an error occurs
   */
  public async getJobTfConfig(
    getJobTfConfigRequest: requests.GetJobTfConfigRequest
  ): Promise<responses.GetJobTfConfigResponse> {
    const pathParams = {
      "{jobId}": getJobTfConfigRequest.jobId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getJobTfConfigRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/jobs/{jobId}/tfConfig",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetJobTfConfigResponse>{},

        body: response.body!,
        bodyKey: "value",
        bodyModel: "string",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Returns the Terraform state for the specified job.
   * @param GetJobTfStateRequest
   * @return GetJobTfStateResponse
   * @throws OciError when an error occurs
   */
  public async getJobTfState(
    getJobTfStateRequest: requests.GetJobTfStateRequest
  ): Promise<responses.GetJobTfStateResponse> {
    const pathParams = {
      "{jobId}": getJobTfStateRequest.jobId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getJobTfStateRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/jobs/{jobId}/tfState",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetJobTfStateResponse>{},

        body: response.body!,
        bodyKey: "value",
        bodyModel: "string",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets a stack using the stack ID.
   * @param GetStackRequest
   * @return GetStackResponse
   * @throws OciError when an error occurs
   */
  public async getStack(
    getStackRequest: requests.GetStackRequest
  ): Promise<responses.GetStackResponse> {
    const pathParams = {
      "{stackId}": getStackRequest.stackId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getStackRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/stacks/{stackId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetStackResponse>{},
        body: await response.json(),
        bodyKey: "stack",
        bodyModel: "model.Stack",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Returns the Terraform configuration file in .zip format for the specified stack.
   * Returns an error if no zip file is found.
   *
   * @param GetStackTfConfigRequest
   * @return GetStackTfConfigResponse
   * @throws OciError when an error occurs
   */
  public async getStackTfConfig(
    getStackTfConfigRequest: requests.GetStackTfConfigRequest
  ): Promise<responses.GetStackTfConfigResponse> {
    const pathParams = {
      "{stackId}": getStackTfConfigRequest.stackId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getStackTfConfigRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/stacks/{stackId}/tfConfig",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetStackTfConfigResponse>{},

        body: response.body!,
        bodyKey: "value",
        bodyModel: "string",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Returns the Terraform state for the specified stack.
   * @param GetStackTfStateRequest
   * @return GetStackTfStateResponse
   * @throws OciError when an error occurs
   */
  public async getStackTfState(
    getStackTfStateRequest: requests.GetStackTfStateRequest
  ): Promise<responses.GetStackTfStateResponse> {
    const pathParams = {
      "{stackId}": getStackTfStateRequest.stackId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getStackTfStateRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/stacks/{stackId}/tfState",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetStackTfStateResponse>{},

        body: response.body!,
        bodyKey: "value",
        bodyModel: "string",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Return the given work request.
   * @param GetWorkRequestRequest
   * @return GetWorkRequestResponse
   * @throws OciError when an error occurs
   */
  public async getWorkRequest(
    getWorkRequestRequest: requests.GetWorkRequestRequest
  ): Promise<responses.GetWorkRequestResponse> {
    const pathParams = {
      "{workRequestId}": getWorkRequestRequest.workRequestId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getWorkRequestRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workRequests/{workRequestId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetWorkRequestResponse>{},
        body: await response.json(),
        bodyKey: "workRequest",
        bodyModel: "model.WorkRequest",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Returns a list of jobs in a stack or compartment, ordered by time created.
* <p>
- To list all jobs in a stack, provide the stack [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
* - To list all jobs in a compartment, provide the compartment [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
* - To return a specific job, provide the job [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
* 
     * @param ListJobsRequest
     * @return ListJobsResponse
     * @throws OciError when an error occurs
     */
  public async listJobs(
    listJobsRequest: requests.ListJobsRequest
  ): Promise<responses.ListJobsResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listJobsRequest.compartmentId,
      "stackId": listJobsRequest.stackId,
      "id": listJobsRequest.id,
      "lifecycleState": listJobsRequest.lifecycleState,
      "displayName": listJobsRequest.displayName,
      "sortBy": listJobsRequest.sortBy,
      "sortOrder": listJobsRequest.sortOrder,
      "limit": listJobsRequest.limit,
      "page": listJobsRequest.page
    };

    let headerParams = {
      "opc-request-id": listJobsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/jobs",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListJobsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "JobSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.JobSummary objects
   * contained in responses from the listJobs operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllJobs(request: requests.ListJobsRequest): AsyncIterableIterator<models.JobSummary> {
    return paginateRecords(request, req => this.listJobs(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listJobs operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllJobsResponses(
    request: requests.ListJobsRequest
  ): AsyncIterableIterator<responses.ListJobsResponse> {
    return paginateResponses(request, req => this.listJobs(req));
  }

  /**
   * Returns a list of stacks.
   * - If called using the compartment ID, returns all stacks in the specified compartment.
   * - If called using the stack ID, returns the specified stack.
   *
   * @param ListStacksRequest
   * @return ListStacksResponse
   * @throws OciError when an error occurs
   */
  public async listStacks(
    listStacksRequest: requests.ListStacksRequest
  ): Promise<responses.ListStacksResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listStacksRequest.compartmentId,
      "id": listStacksRequest.id,
      "lifecycleState": listStacksRequest.lifecycleState,
      "displayName": listStacksRequest.displayName,
      "sortBy": listStacksRequest.sortBy,
      "sortOrder": listStacksRequest.sortOrder,
      "limit": listStacksRequest.limit,
      "page": listStacksRequest.page
    };

    let headerParams = {
      "opc-request-id": listStacksRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/stacks",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListStacksResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "StackSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.StackSummary objects
   * contained in responses from the listStacks operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllStacks(
    request: requests.ListStacksRequest
  ): AsyncIterableIterator<models.StackSummary> {
    return paginateRecords(request, req => this.listStacks(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listStacks operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllStacksResponses(
    request: requests.ListStacksRequest
  ): AsyncIterableIterator<responses.ListStacksResponse> {
    return paginateResponses(request, req => this.listStacks(req));
  }

  /**
   * Returns a list of supported Terraform versions for use with stacks.
   *
   * @param ListTerraformVersionsRequest
   * @return ListTerraformVersionsResponse
   * @throws OciError when an error occurs
   */
  public async listTerraformVersions(
    listTerraformVersionsRequest: requests.ListTerraformVersionsRequest
  ): Promise<responses.ListTerraformVersionsResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listTerraformVersionsRequest.compartmentId
    };

    let headerParams = {
      "opc-request-id": listTerraformVersionsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/terraformVersions",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListTerraformVersionsResponse>{},
        body: await response.json(),
        bodyKey: "terraformVersionCollection",
        bodyModel: "model.TerraformVersionCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Return a (paginated) list of errors for a given work request.
   *
   * @param ListWorkRequestErrorsRequest
   * @return ListWorkRequestErrorsResponse
   * @throws OciError when an error occurs
   */
  public async listWorkRequestErrors(
    listWorkRequestErrorsRequest: requests.ListWorkRequestErrorsRequest
  ): Promise<responses.ListWorkRequestErrorsResponse> {
    const pathParams = {
      "{workRequestId}": listWorkRequestErrorsRequest.workRequestId
    };

    const queryParams = {
      "compartmentId": listWorkRequestErrorsRequest.compartmentId,
      "limit": listWorkRequestErrorsRequest.limit,
      "page": listWorkRequestErrorsRequest.page,
      "sortOrder": listWorkRequestErrorsRequest.sortOrder
    };

    let headerParams = {
      "opc-request-id": listWorkRequestErrorsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workRequests/{workRequestId}/errors",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListWorkRequestErrorsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "WorkRequestError[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.WorkRequestError objects
   * contained in responses from the listWorkRequestErrors operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllWorkRequestErrors(
    request: requests.ListWorkRequestErrorsRequest
  ): AsyncIterableIterator<models.WorkRequestError> {
    return paginateRecords(request, req => this.listWorkRequestErrors(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listWorkRequestErrors operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllWorkRequestErrorsResponses(
    request: requests.ListWorkRequestErrorsRequest
  ): AsyncIterableIterator<responses.ListWorkRequestErrorsResponse> {
    return paginateResponses(request, req => this.listWorkRequestErrors(req));
  }

  /**
   * Return a (paginated) list of logs for a given work request.
   *
   * @param ListWorkRequestLogsRequest
   * @return ListWorkRequestLogsResponse
   * @throws OciError when an error occurs
   */
  public async listWorkRequestLogs(
    listWorkRequestLogsRequest: requests.ListWorkRequestLogsRequest
  ): Promise<responses.ListWorkRequestLogsResponse> {
    const pathParams = {
      "{workRequestId}": listWorkRequestLogsRequest.workRequestId
    };

    const queryParams = {
      "compartmentId": listWorkRequestLogsRequest.compartmentId,
      "limit": listWorkRequestLogsRequest.limit,
      "page": listWorkRequestLogsRequest.page,
      "sortOrder": listWorkRequestLogsRequest.sortOrder
    };

    let headerParams = {
      "opc-request-id": listWorkRequestLogsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workRequests/{workRequestId}/logs",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListWorkRequestLogsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "WorkRequestLogEntry[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.WorkRequestLogEntry objects
   * contained in responses from the listWorkRequestLogs operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllWorkRequestLogs(
    request: requests.ListWorkRequestLogsRequest
  ): AsyncIterableIterator<models.WorkRequestLogEntry> {
    return paginateRecords(request, req => this.listWorkRequestLogs(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listWorkRequestLogs operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllWorkRequestLogsResponses(
    request: requests.ListWorkRequestLogsRequest
  ): AsyncIterableIterator<responses.ListWorkRequestLogsResponse> {
    return paginateResponses(request, req => this.listWorkRequestLogs(req));
  }

  /**
   * Lists the work requests in a given compartment or for a given resource.
   *
   * @param ListWorkRequestsRequest
   * @return ListWorkRequestsResponse
   * @throws OciError when an error occurs
   */
  public async listWorkRequests(
    listWorkRequestsRequest: requests.ListWorkRequestsRequest
  ): Promise<responses.ListWorkRequestsResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listWorkRequestsRequest.compartmentId,
      "resourceId": listWorkRequestsRequest.resourceId,
      "limit": listWorkRequestsRequest.limit,
      "page": listWorkRequestsRequest.page
    };

    let headerParams = {
      "opc-request-id": listWorkRequestsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workRequests",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListWorkRequestsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "WorkRequestSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.WorkRequestSummary objects
   * contained in responses from the listWorkRequests operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllWorkRequests(
    request: requests.ListWorkRequestsRequest
  ): AsyncIterableIterator<models.WorkRequestSummary> {
    return paginateRecords(request, req => this.listWorkRequests(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listWorkRequests operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllWorkRequestsResponses(
    request: requests.ListWorkRequestsRequest
  ): AsyncIterableIterator<responses.ListWorkRequestsResponse> {
    return paginateResponses(request, req => this.listWorkRequests(req));
  }

  /**
   * Updates the specified job.
   * @param UpdateJobRequest
   * @return UpdateJobResponse
   * @throws OciError when an error occurs
   */
  public async updateJob(
    updateJobRequest: requests.UpdateJobRequest
  ): Promise<responses.UpdateJobResponse> {
    const pathParams = {
      "{jobId}": updateJobRequest.jobId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": updateJobRequest.opcRequestId,
      "if-match": updateJobRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/jobs/{jobId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateJobRequest.updateJobDetails,
        "UpdateJobDetails",
        models.UpdateJobDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateJobResponse>{},
        body: await response.json(),
        bodyKey: "job",
        bodyModel: "model.Job",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates the specified stack object.
   * Use `UpdateStack` when you update your Terraform configuration
   * and want your changes to be reflected in the execution plan.
   * For more information, see [Update a Stack](https://docs.cloud.oracle.com/iaas/Content/ResourceManager/Tasks/usingconsole.htm#UpdateStack) and
   * [Edit or Delete a Stack](https://docs.cloud.oracle.com/iaas/Content/ResourceManager/Tasks/usingconsole.htm#EditStack).
   *
   * @param UpdateStackRequest
   * @return UpdateStackResponse
   * @throws OciError when an error occurs
   */
  public async updateStack(
    updateStackRequest: requests.UpdateStackRequest
  ): Promise<responses.UpdateStackResponse> {
    const pathParams = {
      "{stackId}": updateStackRequest.stackId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": updateStackRequest.opcRequestId,
      "if-match": updateStackRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/stacks/{stackId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateStackRequest.updateStackDetails,
        "UpdateStackDetails",
        models.UpdateStackDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateStackResponse>{},
        body: await response.json(),
        bodyKey: "stack",
        bodyModel: "model.Stack",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }
}
