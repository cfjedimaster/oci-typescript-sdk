/**
 * File Storage API
 * API for the File Storage service. Use this API to manage file systems, mount targets, and snapshots. For more information, see [Overview of File Storage](/iaas/Content/File/Concepts/filestorageoverview.htm).

 * OpenAPI spec version: 20171215
 * 
 *
 * NOTE: This class is auto generated by OracleSDKGenerator.
 * Do not edit the class manually.
 *
 * Copyright (c) 2020, Oracle and/or its affiliates.  All rights reserved.
 * This software is dual-licensed to you under the Universal Permissive License (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl or Apache License 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose either license.
 */

import common = require("oci-common");
import * as requests from "./request";
import * as models from "./model";
import * as responses from "./response";
import { paginateRecords, paginateResponses } from "oci-common";
import { FileStorageWaiter } from "./filestorage-waiter";
import { composeResponse, composeRequest } from "oci-common";

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum FileStorageApiKeys {}

export class FileStorageClient {
  protected static serviceEndpointTemplate = "https://filestorage.{region}.{secondLevelDomain}";
  protected "_endpoint": string = "";
  protected "_defaultHeaders": any = {};
  protected "_waiters": FileStorageWaiter;

  protected _httpClient: common.HttpClient;

  constructor(params: common.AuthParams) {
    const requestSigner = params.authenticationDetailsProvider
      ? new common.DefaultRequestSigner(params.authenticationDetailsProvider)
      : null;
    this._httpClient = params.httpClient || new common.FetchHttpClient(requestSigner);

    if (
      params.authenticationDetailsProvider &&
      common.isRegionProvider(params.authenticationDetailsProvider)
    ) {
      const provider: common.RegionProvider = params.authenticationDetailsProvider;
      if (provider.getRegion()) {
        this.region = provider.getRegion();
      }
    }
  }

  /**
   * Sets the endpoint to call (ex, https://www.example.com).
   * @param endpoint The endpoint of the service.
   */
  public set endpoint(endpoint: string) {
    this._endpoint = endpoint;
    this._endpoint = this._endpoint + "/20171215";
  }

  /**
   * Sets the region to call (ex, Region.US_PHOENIX_1).
   * Note, this will call {@link #endpoint(String) endpoint} after resolving the endpoint.
   * @param region The region of the service.
   */
  public set region(region: common.Region) {
    this.endpoint = common.EndpointBuilder.createEndpointFromRegion(
      FileStorageClient.serviceEndpointTemplate,
      region
    );
  }

  /**
   * Sets the regionId to call (ex, 'us-phoenix-1').
   *
   * Note, this will first try to map the region ID to a known Region and call {@link #region(Region) region}.
   * If no known Region could be determined, it will create an endpoint assuming its in default Realm OC1
   * and then call {@link #endpoint(String) endpoint}.
   * @param regionId The public region ID.
   */
  public set regionId(regionId: string) {
    this.endpoint = common.EndpointBuilder.createEndpointFromRegionId(
      FileStorageClient.serviceEndpointTemplate,
      regionId
    );
  }

  /**
   * Creates a new FileStorageWaiter for resources for this service.
   *
   * @param config The waiter configuration for termination and delay strategy
   * @return The service waiters.
   */
  public createWaiters(config?: common.WaiterConfiguration): FileStorageWaiter {
    this._waiters = new FileStorageWaiter(this, config);
    return this._waiters;
  }

  /**
   * Gets the waiters available for resources for this service.
   *
   * @return The service waiters.
   */
  public getWaiters(): FileStorageWaiter {
    if (this._waiters) {
      return this._waiters;
    }
    throw Error("Waiters do not exist. Please create waiters.");
  }

  /**
   * Moves a file system and its associated snapshots into a different compartment within the same tenancy. For information about moving resources between compartments, see [Moving Resources to a Different Compartment](https://docs.cloud.oracle.com/iaas/Content/Identity/Tasks/managingcompartments.htm#moveRes)
   *
   * @param ChangeFileSystemCompartmentRequest
   * @return ChangeFileSystemCompartmentResponse
   * @throws OciError when an error occurs
   */
  public async changeFileSystemCompartment(
    changeFileSystemCompartmentRequest: requests.ChangeFileSystemCompartmentRequest
  ): Promise<responses.ChangeFileSystemCompartmentResponse> {
    const pathParams = {
      "{fileSystemId}": changeFileSystemCompartmentRequest.fileSystemId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": changeFileSystemCompartmentRequest.ifMatch,
      "opc-request-id": changeFileSystemCompartmentRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/fileSystems/{fileSystemId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeFileSystemCompartmentRequest.changeFileSystemCompartmentDetails,
        "ChangeFileSystemCompartmentDetails",
        models.ChangeFileSystemCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeFileSystemCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Moves a mount target and its associated export set into a different compartment within the same tenancy. For information about moving resources between compartments, see [Moving Resources to a Different Compartment](https://docs.cloud.oracle.com/iaas/Content/Identity/Tasks/managingcompartments.htm#moveRes)
   *
   * @param ChangeMountTargetCompartmentRequest
   * @return ChangeMountTargetCompartmentResponse
   * @throws OciError when an error occurs
   */
  public async changeMountTargetCompartment(
    changeMountTargetCompartmentRequest: requests.ChangeMountTargetCompartmentRequest
  ): Promise<responses.ChangeMountTargetCompartmentResponse> {
    const pathParams = {
      "{mountTargetId}": changeMountTargetCompartmentRequest.mountTargetId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": changeMountTargetCompartmentRequest.ifMatch,
      "opc-request-id": changeMountTargetCompartmentRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/mountTargets/{mountTargetId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeMountTargetCompartmentRequest.changeMountTargetCompartmentDetails,
        "ChangeMountTargetCompartmentDetails",
        models.ChangeMountTargetCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeMountTargetCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new export in the specified export set, path, and
   * file system.
   *
   * @param CreateExportRequest
   * @return CreateExportResponse
   * @throws OciError when an error occurs
   */
  public async createExport(
    createExportRequest: requests.CreateExportRequest
  ): Promise<responses.CreateExportResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createExportRequest.opcRetryToken,
      "opc-request-id": createExportRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/exports",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createExportRequest.createExportDetails,
        "CreateExportDetails",
        models.CreateExportDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateExportResponse>{},
        body: await response.json(),
        bodyKey: "export",
        bodyModel: "model.Export",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Creates a new file system in the specified compartment and
* availability domain. Instances can mount file systems in
* another availability domain, but doing so might increase
* latency when compared to mounting instances in the same
* availability domain.
* <p>
After you create a file system, you can associate it with a mount
* target. Instances can then mount the file system by connecting to the
* mount target's IP address. You can associate a file system with
* more than one mount target at a time.
* <p>
For information about access control and compartments, see
* [Overview of the IAM Service](https://docs.cloud.oracle.com/Content/Identity/Concepts/overview.htm).
* <p>
For information about Network Security Groups access control, see
* [Network Security Groups](https://docs.cloud.oracle.com/Content/Network/Concepts/networksecuritygroups.htm).
* <p>
For information about availability domains, see [Regions and
* Availability Domains](https://docs.cloud.oracle.com/Content/General/Concepts/regions.htm).
* To get a list of availability domains, use the
* `ListAvailabilityDomains` operation in the Identity and Access
* Management Service API.
* <p>
All Oracle Cloud Infrastructure resources, including
* file systems, get an Oracle-assigned, unique ID called an Oracle
* Cloud Identifier (OCID).  When you create a resource, you can
* find its OCID in the response. You can also retrieve a
* resource's OCID by using a List API operation on that resource
* type or by viewing the resource in the Console.
* 
     * @param CreateFileSystemRequest
     * @return CreateFileSystemResponse
     * @throws OciError when an error occurs
     */
  public async createFileSystem(
    createFileSystemRequest: requests.CreateFileSystemRequest
  ): Promise<responses.CreateFileSystemResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createFileSystemRequest.opcRetryToken,
      "opc-request-id": createFileSystemRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/fileSystems",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createFileSystemRequest.createFileSystemDetails,
        "CreateFileSystemDetails",
        models.CreateFileSystemDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateFileSystemResponse>{},
        body: await response.json(),
        bodyKey: "fileSystem",
        bodyModel: "model.FileSystem",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Creates a new mount target in the specified compartment and
* subnet. You can associate a file system with a mount
* target only when they exist in the same availability domain. Instances
* can connect to mount targets in another availablity domain, but
* you might see higher latency than with instances in the same
* availability domain as the mount target.
* <p>
Mount targets have one or more private IP addresses that you can
* provide as the host portion of remote target parameters in
* client mount commands. These private IP addresses are listed
* in the privateIpIds property of the mount target and are highly available. Mount
* targets also consume additional IP addresses in their subnet.
* Do not use /30 or smaller subnets for mount target creation because they
* do not have sufficient available IP addresses.
* Allow at least three IP addresses for each mount target.
* <p>
For information about access control and compartments, see
* [Overview of the IAM
* Service](https://docs.cloud.oracle.com/Content/Identity/Concepts/overview.htm).
* <p>
For information about availability domains, see [Regions and
* Availability Domains](https://docs.cloud.oracle.com/Content/General/Concepts/regions.htm).
* To get a list of availability domains, use the
* `ListAvailabilityDomains` operation in the Identity and Access
* Management Service API.
* <p>
All Oracle Cloud Infrastructure Services resources, including
* mount targets, get an Oracle-assigned, unique ID called an
* Oracle Cloud Identifier (OCID).  When you create a resource,
* you can find its OCID in the response. You can also retrieve a
* resource's OCID by using a List API operation on that resource
* type, or by viewing the resource in the Console.
* 
     * @param CreateMountTargetRequest
     * @return CreateMountTargetResponse
     * @throws OciError when an error occurs
     */
  public async createMountTarget(
    createMountTargetRequest: requests.CreateMountTargetRequest
  ): Promise<responses.CreateMountTargetResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createMountTargetRequest.opcRetryToken,
      "opc-request-id": createMountTargetRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/mountTargets",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createMountTargetRequest.createMountTargetDetails,
        "CreateMountTargetDetails",
        models.CreateMountTargetDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateMountTargetResponse>{},
        body: await response.json(),
        bodyKey: "mountTarget",
        bodyModel: "model.MountTarget",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new snapshot of the specified file system. You
   * can access the snapshot at `.snapshot/<name>`.
   *
   * @param CreateSnapshotRequest
   * @return CreateSnapshotResponse
   * @throws OciError when an error occurs
   */
  public async createSnapshot(
    createSnapshotRequest: requests.CreateSnapshotRequest
  ): Promise<responses.CreateSnapshotResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createSnapshotRequest.opcRetryToken,
      "opc-request-id": createSnapshotRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/snapshots",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createSnapshotRequest.createSnapshotDetails,
        "CreateSnapshotDetails",
        models.CreateSnapshotDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateSnapshotResponse>{},
        body: await response.json(),
        bodyKey: "snapshot",
        bodyModel: "model.Snapshot",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Deletes the specified export.
   *
   * @param DeleteExportRequest
   * @return DeleteExportResponse
   * @throws OciError when an error occurs
   */
  public async deleteExport(
    deleteExportRequest: requests.DeleteExportRequest
  ): Promise<responses.DeleteExportResponse> {
    const pathParams = {
      "{exportId}": deleteExportRequest.exportId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteExportRequest.ifMatch,
      "opc-request-id": deleteExportRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/exports/{exportId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteExportResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Deletes the specified file system. Before you delete the file system,
   * verify that no remaining export resources still reference it. Deleting a
   * file system also deletes all of its snapshots.
   *
   * @param DeleteFileSystemRequest
   * @return DeleteFileSystemResponse
   * @throws OciError when an error occurs
   */
  public async deleteFileSystem(
    deleteFileSystemRequest: requests.DeleteFileSystemRequest
  ): Promise<responses.DeleteFileSystemResponse> {
    const pathParams = {
      "{fileSystemId}": deleteFileSystemRequest.fileSystemId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteFileSystemRequest.ifMatch,
      "opc-request-id": deleteFileSystemRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/fileSystems/{fileSystemId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteFileSystemResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Deletes the specified mount target. This operation also deletes the
   * mount target's VNICs.
   *
   * @param DeleteMountTargetRequest
   * @return DeleteMountTargetResponse
   * @throws OciError when an error occurs
   */
  public async deleteMountTarget(
    deleteMountTargetRequest: requests.DeleteMountTargetRequest
  ): Promise<responses.DeleteMountTargetResponse> {
    const pathParams = {
      "{mountTargetId}": deleteMountTargetRequest.mountTargetId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteMountTargetRequest.ifMatch,
      "opc-request-id": deleteMountTargetRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/mountTargets/{mountTargetId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteMountTargetResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Deletes the specified snapshot.
   *
   * @param DeleteSnapshotRequest
   * @return DeleteSnapshotResponse
   * @throws OciError when an error occurs
   */
  public async deleteSnapshot(
    deleteSnapshotRequest: requests.DeleteSnapshotRequest
  ): Promise<responses.DeleteSnapshotResponse> {
    const pathParams = {
      "{snapshotId}": deleteSnapshotRequest.snapshotId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteSnapshotRequest.ifMatch,
      "opc-request-id": deleteSnapshotRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/snapshots/{snapshotId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteSnapshotResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the specified export's information.
   * @param GetExportRequest
   * @return GetExportResponse
   * @throws OciError when an error occurs
   */
  public async getExport(
    getExportRequest: requests.GetExportRequest
  ): Promise<responses.GetExportResponse> {
    const pathParams = {
      "{exportId}": getExportRequest.exportId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getExportRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/exports/{exportId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetExportResponse>{},
        body: await response.json(),
        bodyKey: "export",
        bodyModel: "model.Export",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the specified export set's information.
   * @param GetExportSetRequest
   * @return GetExportSetResponse
   * @throws OciError when an error occurs
   */
  public async getExportSet(
    getExportSetRequest: requests.GetExportSetRequest
  ): Promise<responses.GetExportSetResponse> {
    const pathParams = {
      "{exportSetId}": getExportSetRequest.exportSetId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getExportSetRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/exportSets/{exportSetId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetExportSetResponse>{},
        body: await response.json(),
        bodyKey: "exportSet",
        bodyModel: "model.ExportSet",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the specified file system's information.
   * @param GetFileSystemRequest
   * @return GetFileSystemResponse
   * @throws OciError when an error occurs
   */
  public async getFileSystem(
    getFileSystemRequest: requests.GetFileSystemRequest
  ): Promise<responses.GetFileSystemResponse> {
    const pathParams = {
      "{fileSystemId}": getFileSystemRequest.fileSystemId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getFileSystemRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/fileSystems/{fileSystemId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetFileSystemResponse>{},
        body: await response.json(),
        bodyKey: "fileSystem",
        bodyModel: "model.FileSystem",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the specified mount target's information.
   * @param GetMountTargetRequest
   * @return GetMountTargetResponse
   * @throws OciError when an error occurs
   */
  public async getMountTarget(
    getMountTargetRequest: requests.GetMountTargetRequest
  ): Promise<responses.GetMountTargetResponse> {
    const pathParams = {
      "{mountTargetId}": getMountTargetRequest.mountTargetId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getMountTargetRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/mountTargets/{mountTargetId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetMountTargetResponse>{},
        body: await response.json(),
        bodyKey: "mountTarget",
        bodyModel: "model.MountTarget",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the specified snapshot's information.
   * @param GetSnapshotRequest
   * @return GetSnapshotResponse
   * @throws OciError when an error occurs
   */
  public async getSnapshot(
    getSnapshotRequest: requests.GetSnapshotRequest
  ): Promise<responses.GetSnapshotResponse> {
    const pathParams = {
      "{snapshotId}": getSnapshotRequest.snapshotId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getSnapshotRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/snapshots/{snapshotId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetSnapshotResponse>{},
        body: await response.json(),
        bodyKey: "snapshot",
        bodyModel: "model.Snapshot",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Lists the export set resources in the specified compartment.
   *
   * @param ListExportSetsRequest
   * @return ListExportSetsResponse
   * @throws OciError when an error occurs
   */
  public async listExportSets(
    listExportSetsRequest: requests.ListExportSetsRequest
  ): Promise<responses.ListExportSetsResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listExportSetsRequest.compartmentId,
      "availabilityDomain": listExportSetsRequest.availabilityDomain,
      "limit": listExportSetsRequest.limit,
      "page": listExportSetsRequest.page,
      "displayName": listExportSetsRequest.displayName,
      "lifecycleState": listExportSetsRequest.lifecycleState,
      "id": listExportSetsRequest.id,
      "sortBy": listExportSetsRequest.sortBy,
      "sortOrder": listExportSetsRequest.sortOrder
    };

    let headerParams = {
      "opc-request-id": listExportSetsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/exportSets",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListExportSetsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "ExportSetSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.ExportSetSummary objects
   * contained in responses from the listExportSets operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllExportSets(
    request: requests.ListExportSetsRequest
  ): AsyncIterableIterator<models.ExportSetSummary> {
    return paginateRecords(request, req => this.listExportSets(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listExportSets operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllExportSetsResponses(
    request: requests.ListExportSetsRequest
  ): AsyncIterableIterator<responses.ListExportSetsResponse> {
    return paginateResponses(request, req => this.listExportSets(req));
  }

  /**
   * Lists export resources by compartment, file system, or export
   * set. You must specify an export set ID, a file system ID, and
   * / or a compartment ID.
   *
   * @param ListExportsRequest
   * @return ListExportsResponse
   * @throws OciError when an error occurs
   */
  public async listExports(
    listExportsRequest: requests.ListExportsRequest
  ): Promise<responses.ListExportsResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listExportsRequest.compartmentId,
      "limit": listExportsRequest.limit,
      "page": listExportsRequest.page,
      "exportSetId": listExportsRequest.exportSetId,
      "fileSystemId": listExportsRequest.fileSystemId,
      "lifecycleState": listExportsRequest.lifecycleState,
      "id": listExportsRequest.id,
      "sortBy": listExportsRequest.sortBy,
      "sortOrder": listExportsRequest.sortOrder
    };

    let headerParams = {
      "opc-request-id": listExportsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/exports",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListExportsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "ExportSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.ExportSummary objects
   * contained in responses from the listExports operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllExports(
    request: requests.ListExportsRequest
  ): AsyncIterableIterator<models.ExportSummary> {
    return paginateRecords(request, req => this.listExports(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listExports operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllExportsResponses(
    request: requests.ListExportsRequest
  ): AsyncIterableIterator<responses.ListExportsResponse> {
    return paginateResponses(request, req => this.listExports(req));
  }

  /**
   * Lists the file system resources in the specified compartment.
   *
   * @param ListFileSystemsRequest
   * @return ListFileSystemsResponse
   * @throws OciError when an error occurs
   */
  public async listFileSystems(
    listFileSystemsRequest: requests.ListFileSystemsRequest
  ): Promise<responses.ListFileSystemsResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listFileSystemsRequest.compartmentId,
      "availabilityDomain": listFileSystemsRequest.availabilityDomain,
      "limit": listFileSystemsRequest.limit,
      "page": listFileSystemsRequest.page,
      "displayName": listFileSystemsRequest.displayName,
      "lifecycleState": listFileSystemsRequest.lifecycleState,
      "id": listFileSystemsRequest.id,
      "sortBy": listFileSystemsRequest.sortBy,
      "sortOrder": listFileSystemsRequest.sortOrder
    };

    let headerParams = {
      "opc-request-id": listFileSystemsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/fileSystems",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListFileSystemsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "FileSystemSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.FileSystemSummary objects
   * contained in responses from the listFileSystems operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllFileSystems(
    request: requests.ListFileSystemsRequest
  ): AsyncIterableIterator<models.FileSystemSummary> {
    return paginateRecords(request, req => this.listFileSystems(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listFileSystems operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllFileSystemsResponses(
    request: requests.ListFileSystemsRequest
  ): AsyncIterableIterator<responses.ListFileSystemsResponse> {
    return paginateResponses(request, req => this.listFileSystems(req));
  }

  /**
   * Lists the mount target resources in the specified compartment.
   *
   * @param ListMountTargetsRequest
   * @return ListMountTargetsResponse
   * @throws OciError when an error occurs
   */
  public async listMountTargets(
    listMountTargetsRequest: requests.ListMountTargetsRequest
  ): Promise<responses.ListMountTargetsResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listMountTargetsRequest.compartmentId,
      "availabilityDomain": listMountTargetsRequest.availabilityDomain,
      "limit": listMountTargetsRequest.limit,
      "page": listMountTargetsRequest.page,
      "displayName": listMountTargetsRequest.displayName,
      "exportSetId": listMountTargetsRequest.exportSetId,
      "lifecycleState": listMountTargetsRequest.lifecycleState,
      "id": listMountTargetsRequest.id,
      "sortBy": listMountTargetsRequest.sortBy,
      "sortOrder": listMountTargetsRequest.sortOrder
    };

    let headerParams = {
      "opc-request-id": listMountTargetsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/mountTargets",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListMountTargetsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "MountTargetSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.MountTargetSummary objects
   * contained in responses from the listMountTargets operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllMountTargets(
    request: requests.ListMountTargetsRequest
  ): AsyncIterableIterator<models.MountTargetSummary> {
    return paginateRecords(request, req => this.listMountTargets(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listMountTargets operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllMountTargetsResponses(
    request: requests.ListMountTargetsRequest
  ): AsyncIterableIterator<responses.ListMountTargetsResponse> {
    return paginateResponses(request, req => this.listMountTargets(req));
  }

  /**
   * Lists snapshots of the specified file system.
   *
   * @param ListSnapshotsRequest
   * @return ListSnapshotsResponse
   * @throws OciError when an error occurs
   */
  public async listSnapshots(
    listSnapshotsRequest: requests.ListSnapshotsRequest
  ): Promise<responses.ListSnapshotsResponse> {
    const pathParams = {};

    const queryParams = {
      "fileSystemId": listSnapshotsRequest.fileSystemId,
      "limit": listSnapshotsRequest.limit,
      "page": listSnapshotsRequest.page,
      "lifecycleState": listSnapshotsRequest.lifecycleState,
      "id": listSnapshotsRequest.id,
      "sortOrder": listSnapshotsRequest.sortOrder
    };

    let headerParams = {
      "opc-request-id": listSnapshotsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/snapshots",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListSnapshotsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "SnapshotSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.SnapshotSummary objects
   * contained in responses from the listSnapshots operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllSnapshots(
    request: requests.ListSnapshotsRequest
  ): AsyncIterableIterator<models.SnapshotSummary> {
    return paginateRecords(request, req => this.listSnapshots(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listSnapshots operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllSnapshotsResponses(
    request: requests.ListSnapshotsRequest
  ): AsyncIterableIterator<responses.ListSnapshotsResponse> {
    return paginateResponses(request, req => this.listSnapshots(req));
  }

  /**
   * Updates the specified export's information.
   * @param UpdateExportRequest
   * @return UpdateExportResponse
   * @throws OciError when an error occurs
   */
  public async updateExport(
    updateExportRequest: requests.UpdateExportRequest
  ): Promise<responses.UpdateExportResponse> {
    const pathParams = {
      "{exportId}": updateExportRequest.exportId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateExportRequest.ifMatch,
      "opc-request-id": updateExportRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/exports/{exportId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateExportRequest.updateExportDetails,
        "UpdateExportDetails",
        models.UpdateExportDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateExportResponse>{},
        body: await response.json(),
        bodyKey: "export",
        bodyModel: "model.Export",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates the specified export set's information.
   * @param UpdateExportSetRequest
   * @return UpdateExportSetResponse
   * @throws OciError when an error occurs
   */
  public async updateExportSet(
    updateExportSetRequest: requests.UpdateExportSetRequest
  ): Promise<responses.UpdateExportSetResponse> {
    const pathParams = {
      "{exportSetId}": updateExportSetRequest.exportSetId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateExportSetRequest.ifMatch,
      "opc-request-id": updateExportSetRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/exportSets/{exportSetId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateExportSetRequest.updateExportSetDetails,
        "UpdateExportSetDetails",
        models.UpdateExportSetDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateExportSetResponse>{},
        body: await response.json(),
        bodyKey: "exportSet",
        bodyModel: "model.ExportSet",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates the specified file system's information.
   * You can use this operation to rename a file system.
   *
   * @param UpdateFileSystemRequest
   * @return UpdateFileSystemResponse
   * @throws OciError when an error occurs
   */
  public async updateFileSystem(
    updateFileSystemRequest: requests.UpdateFileSystemRequest
  ): Promise<responses.UpdateFileSystemResponse> {
    const pathParams = {
      "{fileSystemId}": updateFileSystemRequest.fileSystemId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateFileSystemRequest.ifMatch,
      "opc-request-id": updateFileSystemRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/fileSystems/{fileSystemId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateFileSystemRequest.updateFileSystemDetails,
        "UpdateFileSystemDetails",
        models.UpdateFileSystemDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateFileSystemResponse>{},
        body: await response.json(),
        bodyKey: "fileSystem",
        bodyModel: "model.FileSystem",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates the specified mount target's information.
   * @param UpdateMountTargetRequest
   * @return UpdateMountTargetResponse
   * @throws OciError when an error occurs
   */
  public async updateMountTarget(
    updateMountTargetRequest: requests.UpdateMountTargetRequest
  ): Promise<responses.UpdateMountTargetResponse> {
    const pathParams = {
      "{mountTargetId}": updateMountTargetRequest.mountTargetId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateMountTargetRequest.ifMatch,
      "opc-request-id": updateMountTargetRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/mountTargets/{mountTargetId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateMountTargetRequest.updateMountTargetDetails,
        "UpdateMountTargetDetails",
        models.UpdateMountTargetDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateMountTargetResponse>{},
        body: await response.json(),
        bodyKey: "mountTarget",
        bodyModel: "model.MountTarget",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates the specified snapshot's information.
   * @param UpdateSnapshotRequest
   * @return UpdateSnapshotResponse
   * @throws OciError when an error occurs
   */
  public async updateSnapshot(
    updateSnapshotRequest: requests.UpdateSnapshotRequest
  ): Promise<responses.UpdateSnapshotResponse> {
    const pathParams = {
      "{snapshotId}": updateSnapshotRequest.snapshotId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateSnapshotRequest.ifMatch,
      "opc-request-id": updateSnapshotRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/snapshots/{snapshotId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateSnapshotRequest.updateSnapshotDetails,
        "UpdateSnapshotDetails",
        models.UpdateSnapshotDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateSnapshotResponse>{},
        body: await response.json(),
        bodyKey: "snapshot",
        bodyModel: "model.Snapshot",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }
}
