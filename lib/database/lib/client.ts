/**
 * Database Service API
 * The API for the Database Service. Use this API to manage resources such as databases and DB Systems. For more information, see [Overview of the Database Service](/iaas/Content/Database/Concepts/databaseoverview.htm).

 * OpenAPI spec version: 20160918
 * Contact: sic_dbaas_cp_us_grp@oracle.com
 *
 * NOTE: This class is auto generated by OracleSDKGenerator.
 * Do not edit the class manually.
 *
 * Copyright (c) 2020, Oracle and/or its affiliates.  All rights reserved.
 * This software is dual-licensed to you under the Universal Permissive License (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl or Apache License 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose either license.
 */

import common = require("oci-common");
import * as requests from "./request";
import * as models from "./model";
import * as responses from "./response";
import { paginateRecords, paginateResponses } from "oci-common";
import { DatabaseWaiter } from "./database-waiter";
import { composeResponse, composeRequest } from "oci-common";

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum DatabaseApiKeys {}

export class DatabaseClient {
  protected static serviceEndpointTemplate = "https://database.{region}.{secondLevelDomain}";
  protected "_endpoint": string = "";
  protected "_defaultHeaders": any = {};
  protected "_waiters": DatabaseWaiter;

  protected _httpClient: common.HttpClient;

  constructor(params: common.AuthParams) {
    const requestSigner = params.authenticationDetailsProvider
      ? new common.DefaultRequestSigner(params.authenticationDetailsProvider)
      : null;
    this._httpClient = params.httpClient || new common.FetchHttpClient(requestSigner);

    if (
      params.authenticationDetailsProvider &&
      common.isRegionProvider(params.authenticationDetailsProvider)
    ) {
      const provider: common.RegionProvider = params.authenticationDetailsProvider;
      if (provider.getRegion()) {
        this.region = provider.getRegion();
      }
    }
  }

  /**
   * Sets the endpoint to call (ex, https://www.example.com).
   * @param endpoint The endpoint of the service.
   */
  public set endpoint(endpoint: string) {
    this._endpoint = endpoint;
    this._endpoint = this._endpoint + "/20160918";
  }

  /**
   * Sets the region to call (ex, Region.US_PHOENIX_1).
   * Note, this will call {@link #endpoint(String) endpoint} after resolving the endpoint.
   * @param region The region of the service.
   */
  public set region(region: common.Region) {
    this.endpoint = common.EndpointBuilder.createEndpointFromRegion(
      DatabaseClient.serviceEndpointTemplate,
      region
    );
  }

  /**
   * Sets the regionId to call (ex, 'us-phoenix-1').
   *
   * Note, this will first try to map the region ID to a known Region and call {@link #region(Region) region}.
   * If no known Region could be determined, it will create an endpoint assuming its in default Realm OC1
   * and then call {@link #endpoint(String) endpoint}.
   * @param regionId The public region ID.
   */
  public set regionId(regionId: string) {
    this.endpoint = common.EndpointBuilder.createEndpointFromRegionId(
      DatabaseClient.serviceEndpointTemplate,
      regionId
    );
  }

  /**
   * Creates a new DatabaseWaiter for resources for this service.
   *
   * @param config The waiter configuration for termination and delay strategy
   * @return The service waiters.
   */
  public createWaiters(config?: common.WaiterConfiguration): DatabaseWaiter {
    this._waiters = new DatabaseWaiter(this, config);
    return this._waiters;
  }

  /**
   * Gets the waiters available for resources for this service.
   *
   * @return The service waiters.
   */
  public getWaiters(): DatabaseWaiter {
    if (this._waiters) {
      return this._waiters;
    }
    throw Error("Waiters do not exist. Please create waiters.");
  }

  /**
   * Activates the specified Exadata infrastructure.
   * @param ActivateExadataInfrastructureRequest
   * @return ActivateExadataInfrastructureResponse
   * @throws OciError when an error occurs
   */
  public async activateExadataInfrastructure(
    activateExadataInfrastructureRequest: requests.ActivateExadataInfrastructureRequest
  ): Promise<responses.ActivateExadataInfrastructureResponse> {
    const pathParams = {
      "{exadataInfrastructureId}": activateExadataInfrastructureRequest.exadataInfrastructureId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": activateExadataInfrastructureRequest.opcRequestId,
      "opc-retry-token": activateExadataInfrastructureRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/exadataInfrastructures/{exadataInfrastructureId}/actions/activate",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        activateExadataInfrastructureRequest.activateExadataInfrastructureDetails,
        "ActivateExadataInfrastructureDetails",
        models.ActivateExadataInfrastructureDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ActivateExadataInfrastructureResponse>{},
        body: await response.json(),
        bodyKey: "exadataInfrastructure",
        bodyModel: "model.ExadataInfrastructure",
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Move the Autonomous Container Database and its dependent resources to the specified compartment.
   * For more information about moving Autonomous Container Databases, see
   * [Moving Database Resources to a Different Compartment](https://docs.cloud.oracle.com/Content/Database/Concepts/databaseoverview.htm#moveRes).
   *
   * @param ChangeAutonomousContainerDatabaseCompartmentRequest
   * @return ChangeAutonomousContainerDatabaseCompartmentResponse
   * @throws OciError when an error occurs
   */
  public async changeAutonomousContainerDatabaseCompartment(
    changeAutonomousContainerDatabaseCompartmentRequest: requests.ChangeAutonomousContainerDatabaseCompartmentRequest
  ): Promise<responses.ChangeAutonomousContainerDatabaseCompartmentResponse> {
    const pathParams = {
      "{autonomousContainerDatabaseId}":
        changeAutonomousContainerDatabaseCompartmentRequest.autonomousContainerDatabaseId
    };

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": changeAutonomousContainerDatabaseCompartmentRequest.opcRetryToken,
      "opc-request-id": changeAutonomousContainerDatabaseCompartmentRequest.opcRequestId,
      "if-match": changeAutonomousContainerDatabaseCompartmentRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path:
        "/autonomousContainerDatabases/{autonomousContainerDatabaseId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeAutonomousContainerDatabaseCompartmentRequest.changeCompartmentDetails,
        "ChangeCompartmentDetails",
        models.ChangeCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeAutonomousContainerDatabaseCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Move the Autonomous Database and its dependent resources to the specified compartment.
   * For more information about moving Autonomous Databases, see
   * [Moving Database Resources to a Different Compartment](https://docs.cloud.oracle.com/Content/Database/Concepts/databaseoverview.htm#moveRes).
   *
   * @param ChangeAutonomousDatabaseCompartmentRequest
   * @return ChangeAutonomousDatabaseCompartmentResponse
   * @throws OciError when an error occurs
   */
  public async changeAutonomousDatabaseCompartment(
    changeAutonomousDatabaseCompartmentRequest: requests.ChangeAutonomousDatabaseCompartmentRequest
  ): Promise<responses.ChangeAutonomousDatabaseCompartmentResponse> {
    const pathParams = {
      "{autonomousDatabaseId}": changeAutonomousDatabaseCompartmentRequest.autonomousDatabaseId
    };

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": changeAutonomousDatabaseCompartmentRequest.opcRetryToken,
      "opc-request-id": changeAutonomousDatabaseCompartmentRequest.opcRequestId,
      "if-match": changeAutonomousDatabaseCompartmentRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/autonomousDatabases/{autonomousDatabaseId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeAutonomousDatabaseCompartmentRequest.changeCompartmentDetails,
        "ChangeCompartmentDetails",
        models.ChangeCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeAutonomousDatabaseCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Move the Autonomous Exadata Infrastructure and its dependent resources to the specified compartment.
   * For more information about moving Autonomous Exadata Infrastructures, see
   * [Moving Database Resources to a Different Compartment](https://docs.cloud.oracle.com/Content/Database/Concepts/databaseoverview.htm#moveRes).
   *
   * @param ChangeAutonomousExadataInfrastructureCompartmentRequest
   * @return ChangeAutonomousExadataInfrastructureCompartmentResponse
   * @throws OciError when an error occurs
   */
  public async changeAutonomousExadataInfrastructureCompartment(
    changeAutonomousExadataInfrastructureCompartmentRequest: requests.ChangeAutonomousExadataInfrastructureCompartmentRequest
  ): Promise<responses.ChangeAutonomousExadataInfrastructureCompartmentResponse> {
    const pathParams = {
      "{autonomousExadataInfrastructureId}":
        changeAutonomousExadataInfrastructureCompartmentRequest.autonomousExadataInfrastructureId
    };

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": changeAutonomousExadataInfrastructureCompartmentRequest.opcRetryToken,
      "opc-request-id": changeAutonomousExadataInfrastructureCompartmentRequest.opcRequestId,
      "if-match": changeAutonomousExadataInfrastructureCompartmentRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path:
        "/autonomousExadataInfrastructures/{autonomousExadataInfrastructureId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeAutonomousExadataInfrastructureCompartmentRequest.changeCompartmentDetails,
        "ChangeCompartmentDetails",
        models.ChangeCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeAutonomousExadataInfrastructureCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Move the backup destination and its dependent resources to the specified compartment.
   * For more information about moving backup destinations, see
   * [Moving Database Resources to a Different Compartment](https://docs.cloud.oracle.com/Content/Database/Concepts/databaseoverview.htm#moveRes).
   *
   * @param ChangeBackupDestinationCompartmentRequest
   * @return ChangeBackupDestinationCompartmentResponse
   * @throws OciError when an error occurs
   */
  public async changeBackupDestinationCompartment(
    changeBackupDestinationCompartmentRequest: requests.ChangeBackupDestinationCompartmentRequest
  ): Promise<responses.ChangeBackupDestinationCompartmentResponse> {
    const pathParams = {
      "{backupDestinationId}": changeBackupDestinationCompartmentRequest.backupDestinationId
    };

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": changeBackupDestinationCompartmentRequest.opcRetryToken,
      "opc-request-id": changeBackupDestinationCompartmentRequest.opcRequestId,
      "if-match": changeBackupDestinationCompartmentRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/backupDestinations/{backupDestinationId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeBackupDestinationCompartmentRequest.changeCompartmentDetails,
        "ChangeCompartmentDetails",
        models.ChangeCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeBackupDestinationCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Move the DB system and its dependent resources to the specified compartment.
   * For more information about moving DB systems, see
   * [Moving Database Resources to a Different Compartment](https://docs.cloud.oracle.com/Content/Database/Concepts/databaseoverview.htm#moveRes).
   *
   * @param ChangeDbSystemCompartmentRequest
   * @return ChangeDbSystemCompartmentResponse
   * @throws OciError when an error occurs
   */
  public async changeDbSystemCompartment(
    changeDbSystemCompartmentRequest: requests.ChangeDbSystemCompartmentRequest
  ): Promise<responses.ChangeDbSystemCompartmentResponse> {
    const pathParams = {
      "{dbSystemId}": changeDbSystemCompartmentRequest.dbSystemId
    };

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": changeDbSystemCompartmentRequest.opcRetryToken,
      "opc-request-id": changeDbSystemCompartmentRequest.opcRequestId,
      "if-match": changeDbSystemCompartmentRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/dbSystems/{dbSystemId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeDbSystemCompartmentRequest.changeCompartmentDetails,
        "ChangeCompartmentDetails",
        models.ChangeCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeDbSystemCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * To move an Exadata infrastructure and its dependent resources to another compartment, use the
   * {@link #changeExadataInfrastructureCompartment(ChangeExadataInfrastructureCompartmentRequest) changeExadataInfrastructureCompartment} operation.
   *
   * @param ChangeExadataInfrastructureCompartmentRequest
   * @return ChangeExadataInfrastructureCompartmentResponse
   * @throws OciError when an error occurs
   */
  public async changeExadataInfrastructureCompartment(
    changeExadataInfrastructureCompartmentRequest: requests.ChangeExadataInfrastructureCompartmentRequest
  ): Promise<responses.ChangeExadataInfrastructureCompartmentResponse> {
    const pathParams = {
      "{exadataInfrastructureId}":
        changeExadataInfrastructureCompartmentRequest.exadataInfrastructureId
    };

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": changeExadataInfrastructureCompartmentRequest.opcRetryToken,
      "opc-request-id": changeExadataInfrastructureCompartmentRequest.opcRequestId,
      "if-match": changeExadataInfrastructureCompartmentRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/exadataInfrastructures/{exadataInfrastructureId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeExadataInfrastructureCompartmentRequest.changeExadataInfrastructureCompartmentDetails,
        "ChangeExadataInfrastructureCompartmentDetails",
        models.ChangeExadataInfrastructureCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeExadataInfrastructureCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * To move a VM cluster and its dependent resources to another compartment, use the
   * {@link #changeVmClusterCompartment(ChangeVmClusterCompartmentRequest) changeVmClusterCompartment} operation.
   *
   * @param ChangeVmClusterCompartmentRequest
   * @return ChangeVmClusterCompartmentResponse
   * @throws OciError when an error occurs
   */
  public async changeVmClusterCompartment(
    changeVmClusterCompartmentRequest: requests.ChangeVmClusterCompartmentRequest
  ): Promise<responses.ChangeVmClusterCompartmentResponse> {
    const pathParams = {
      "{vmClusterId}": changeVmClusterCompartmentRequest.vmClusterId
    };

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": changeVmClusterCompartmentRequest.opcRetryToken,
      "opc-request-id": changeVmClusterCompartmentRequest.opcRequestId,
      "if-match": changeVmClusterCompartmentRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/vmClusters/{vmClusterId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeVmClusterCompartmentRequest.changeVmClusterCompartmentDetails,
        "ChangeVmClusterCompartmentDetails",
        models.ChangeVmClusterCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeVmClusterCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Changes the status of the standalone backup resource to `ACTIVE` after the backup is created from the on-premises database and placed in Oracle Cloud Infrastructure Object Storage.
   * <p>
   **Note:** This API is used by an Oracle Cloud Infrastructure Python script that is packaged with the Oracle Cloud Infrastructure CLI. Oracle recommends that you use the script instead using the API directly. See [Migrating an On-Premises Database to Oracle Cloud Infrastructure by Creating a Backup in the Cloud](https://docs.cloud.oracle.com/Content/Database/Tasks/mig-onprembackup.htm) for more information.
   *
   * @param CompleteExternalBackupJobRequest
   * @return CompleteExternalBackupJobResponse
   * @throws OciError when an error occurs
   */
  public async completeExternalBackupJob(
    completeExternalBackupJobRequest: requests.CompleteExternalBackupJobRequest
  ): Promise<responses.CompleteExternalBackupJobResponse> {
    const pathParams = {
      "{backupId}": completeExternalBackupJobRequest.backupId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": completeExternalBackupJobRequest.ifMatch,
      "opc-retry-token": completeExternalBackupJobRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/externalBackupJobs/{backupId}/actions/complete",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        completeExternalBackupJobRequest.completeExternalBackupJobDetails,
        "CompleteExternalBackupJobDetails",
        models.CompleteExternalBackupJobDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CompleteExternalBackupJobResponse>{},
        body: await response.json(),
        bodyKey: "externalBackupJob",
        bodyModel: "model.ExternalBackupJob",
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Create a new Autonomous Container Database in the specified Autonomous Exadata Infrastructure.
   *
   * @param CreateAutonomousContainerDatabaseRequest
   * @return CreateAutonomousContainerDatabaseResponse
   * @throws OciError when an error occurs
   */
  public async createAutonomousContainerDatabase(
    createAutonomousContainerDatabaseRequest: requests.CreateAutonomousContainerDatabaseRequest
  ): Promise<responses.CreateAutonomousContainerDatabaseResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createAutonomousContainerDatabaseRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/autonomousContainerDatabases",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createAutonomousContainerDatabaseRequest.createAutonomousContainerDatabaseDetails,
        "CreateAutonomousContainerDatabaseDetails",
        models.CreateAutonomousContainerDatabaseDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateAutonomousContainerDatabaseResponse>{},
        body: await response.json(),
        bodyKey: "autonomousContainerDatabase",
        bodyModel: "model.AutonomousContainerDatabase",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * **Deprecated.** To create a new Autonomous Data Warehouse, use the {@link #createAutonomousDatabase(CreateAutonomousDatabaseRequest) createAutonomousDatabase} operation and specify `DW` as the workload type.
   *
   * @param CreateAutonomousDataWarehouseRequest
   * @return CreateAutonomousDataWarehouseResponse
   * @throws OciError when an error occurs
   */
  public async createAutonomousDataWarehouse(
    createAutonomousDataWarehouseRequest: requests.CreateAutonomousDataWarehouseRequest
  ): Promise<responses.CreateAutonomousDataWarehouseResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createAutonomousDataWarehouseRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/autonomousDataWarehouses",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createAutonomousDataWarehouseRequest.createAutonomousDataWarehouseDetails,
        "CreateAutonomousDataWarehouseDetails",
        models.CreateAutonomousDataWarehouseDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateAutonomousDataWarehouseResponse>{},
        body: await response.json(),
        bodyKey: "autonomousDataWarehouse",
        bodyModel: "model.AutonomousDataWarehouse",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * **Deprecated.** To create a new Autonomous Data Warehouse backup for a specified database, use the {@link #createAutonomousDatabaseBackup(CreateAutonomousDatabaseBackupRequest) createAutonomousDatabaseBackup} operation.
   *
   * @param CreateAutonomousDataWarehouseBackupRequest
   * @return CreateAutonomousDataWarehouseBackupResponse
   * @throws OciError when an error occurs
   */
  public async createAutonomousDataWarehouseBackup(
    createAutonomousDataWarehouseBackupRequest: requests.CreateAutonomousDataWarehouseBackupRequest
  ): Promise<responses.CreateAutonomousDataWarehouseBackupResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createAutonomousDataWarehouseBackupRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/autonomousDataWarehouseBackups",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createAutonomousDataWarehouseBackupRequest.createAutonomousDataWarehouseBackupDetails,
        "CreateAutonomousDataWarehouseBackupDetails",
        models.CreateAutonomousDataWarehouseBackupDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateAutonomousDataWarehouseBackupResponse>{},
        body: await response.json(),
        bodyKey: "autonomousDataWarehouseBackup",
        bodyModel: "model.AutonomousDataWarehouseBackup",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new Autonomous Database.
   *
   * @param CreateAutonomousDatabaseRequest
   * @return CreateAutonomousDatabaseResponse
   * @throws OciError when an error occurs
   */
  public async createAutonomousDatabase(
    createAutonomousDatabaseRequest: requests.CreateAutonomousDatabaseRequest
  ): Promise<responses.CreateAutonomousDatabaseResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createAutonomousDatabaseRequest.opcRetryToken,
      "opc-request-id": createAutonomousDatabaseRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/autonomousDatabases",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createAutonomousDatabaseRequest.createAutonomousDatabaseDetails,
        "CreateAutonomousDatabaseBase",
        models.CreateAutonomousDatabaseBase.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateAutonomousDatabaseResponse>{},
        body: await response.json(),
        bodyKey: "autonomousDatabase",
        bodyModel: "model.AutonomousDatabase",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new Autonomous Database backup for the specified database based on the provided request parameters.
   *
   * @param CreateAutonomousDatabaseBackupRequest
   * @return CreateAutonomousDatabaseBackupResponse
   * @throws OciError when an error occurs
   */
  public async createAutonomousDatabaseBackup(
    createAutonomousDatabaseBackupRequest: requests.CreateAutonomousDatabaseBackupRequest
  ): Promise<responses.CreateAutonomousDatabaseBackupResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createAutonomousDatabaseBackupRequest.opcRetryToken,
      "opc-request-id": createAutonomousDatabaseBackupRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/autonomousDatabaseBackups",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createAutonomousDatabaseBackupRequest.createAutonomousDatabaseBackupDetails,
        "CreateAutonomousDatabaseBackupDetails",
        models.CreateAutonomousDatabaseBackupDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateAutonomousDatabaseBackupResponse>{},
        body: await response.json(),
        bodyKey: "autonomousDatabaseBackup",
        bodyModel: "model.AutonomousDatabaseBackup",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new backup in the specified database based on the request parameters you provide. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
   *
   * @param CreateBackupRequest
   * @return CreateBackupResponse
   * @throws OciError when an error occurs
   */
  public async createBackup(
    createBackupRequest: requests.CreateBackupRequest
  ): Promise<responses.CreateBackupResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createBackupRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/backups",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createBackupRequest.createBackupDetails,
        "CreateBackupDetails",
        models.CreateBackupDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateBackupResponse>{},
        body: await response.json(),
        bodyKey: "backup",
        bodyModel: "model.Backup",
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a backup destination.
   *
   * @param CreateBackupDestinationRequest
   * @return CreateBackupDestinationResponse
   * @throws OciError when an error occurs
   */
  public async createBackupDestination(
    createBackupDestinationRequest: requests.CreateBackupDestinationRequest
  ): Promise<responses.CreateBackupDestinationResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createBackupDestinationRequest.opcRetryToken,
      "opc-request-id": createBackupDestinationRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/backupDestinations",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createBackupDestinationRequest.createBackupDestinationDetails,
        "CreateBackupDestinationDetails",
        models.CreateBackupDestinationDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateBackupDestinationResponse>{},
        body: await response.json(),
        bodyKey: "backupDestination",
        bodyModel: "model.BackupDestination",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Creates a new Data Guard association.  A Data Guard association represents the replication relationship between the
* specified database and a peer database. For more information, see [Using Oracle Data Guard](https://docs.cloud.oracle.com/Content/Database/Tasks/usingdataguard.htm).
* <p>
All Oracle Cloud Infrastructure resources, including Data Guard associations, get an Oracle-assigned, unique ID
* called an Oracle Cloud Identifier (OCID). When you create a resource, you can find its OCID in the response.
* You can also retrieve a resource's OCID by using a List API operation on that resource type, or by viewing the
* resource in the Console. For more information, see
* [Resource Identifiers](https://docs.cloud.oracle.com/Content/General/Concepts/identifiers.htm).
* 
     * @param CreateDataGuardAssociationRequest
     * @return CreateDataGuardAssociationResponse
     * @throws OciError when an error occurs
     */
  public async createDataGuardAssociation(
    createDataGuardAssociationRequest: requests.CreateDataGuardAssociationRequest
  ): Promise<responses.CreateDataGuardAssociationResponse> {
    const pathParams = {
      "{databaseId}": createDataGuardAssociationRequest.databaseId
    };

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createDataGuardAssociationRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/databases/{databaseId}/dataGuardAssociations",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createDataGuardAssociationRequest.createDataGuardAssociationDetails,
        "CreateDataGuardAssociationDetails",
        models.CreateDataGuardAssociationDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateDataGuardAssociationResponse>{},
        body: await response.json(),
        bodyKey: "dataGuardAssociation",
        bodyModel: "model.DataGuardAssociation",
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new database in the specified Database Home. If the database version is provided, it must match the version of the Database Home. Applies only to Exadata DB systems.
   *
   * @param CreateDatabaseRequest
   * @return CreateDatabaseResponse
   * @throws OciError when an error occurs
   */
  public async createDatabase(
    createDatabaseRequest: requests.CreateDatabaseRequest
  ): Promise<responses.CreateDatabaseResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createDatabaseRequest.opcRetryToken,
      "opc-request-id": createDatabaseRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/databases",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createDatabaseRequest.createNewDatabaseDetails,
        "CreateDatabaseBase",
        models.CreateDatabaseBase.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateDatabaseResponse>{},
        body: await response.json(),
        bodyKey: "database",
        bodyModel: "model.Database",
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new Database Home in the specified DB system based on the request parameters you provide. Applies only to bare metal and Exadata DB systems.
   *
   * @param CreateDbHomeRequest
   * @return CreateDbHomeResponse
   * @throws OciError when an error occurs
   */
  public async createDbHome(
    createDbHomeRequest: requests.CreateDbHomeRequest
  ): Promise<responses.CreateDbHomeResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createDbHomeRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/dbHomes",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createDbHomeRequest.createDbHomeWithDbSystemIdDetails,
        "CreateDbHomeBase",
        models.CreateDbHomeBase.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateDbHomeResponse>{},
        body: await response.json(),
        bodyKey: "dbHome",
        bodyModel: "model.DbHome",
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Create Exadata infrastructure.
   * @param CreateExadataInfrastructureRequest
   * @return CreateExadataInfrastructureResponse
   * @throws OciError when an error occurs
   */
  public async createExadataInfrastructure(
    createExadataInfrastructureRequest: requests.CreateExadataInfrastructureRequest
  ): Promise<responses.CreateExadataInfrastructureResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createExadataInfrastructureRequest.opcRetryToken,
      "opc-request-id": createExadataInfrastructureRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/exadataInfrastructures",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createExadataInfrastructureRequest.createExadataInfrastructureDetails,
        "CreateExadataInfrastructureDetails",
        models.CreateExadataInfrastructureDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateExadataInfrastructureResponse>{},
        body: await response.json(),
        bodyKey: "exadataInfrastructure",
        bodyModel: "model.ExadataInfrastructure",
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new backup resource and returns the information the caller needs to back up an on-premises Oracle Database to Oracle Cloud Infrastructure.
   * <p>
   **Note:** This API is used by an Oracle Cloud Infrastructure Python script that is packaged with the Oracle Cloud Infrastructure CLI. Oracle recommends that you use the script instead using the API directly. See [Migrating an On-Premises Database to Oracle Cloud Infrastructure by Creating a Backup in the Cloud](https://docs.cloud.oracle.com/Content/Database/Tasks/mig-onprembackup.htm) for more information.
   *
   * @param CreateExternalBackupJobRequest
   * @return CreateExternalBackupJobResponse
   * @throws OciError when an error occurs
   */
  public async createExternalBackupJob(
    createExternalBackupJobRequest: requests.CreateExternalBackupJobRequest
  ): Promise<responses.CreateExternalBackupJobResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createExternalBackupJobRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/externalBackupJobs",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createExternalBackupJobRequest.createExternalBackupJobDetails,
        "CreateExternalBackupJobDetails",
        models.CreateExternalBackupJobDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateExternalBackupJobResponse>{},
        body: await response.json(),
        bodyKey: "externalBackupJob",
        bodyModel: "model.ExternalBackupJob",
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a VM cluster.
   *
   * @param CreateVmClusterRequest
   * @return CreateVmClusterResponse
   * @throws OciError when an error occurs
   */
  public async createVmCluster(
    createVmClusterRequest: requests.CreateVmClusterRequest
  ): Promise<responses.CreateVmClusterResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createVmClusterRequest.opcRetryToken,
      "opc-request-id": createVmClusterRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/vmClusters",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createVmClusterRequest.createVmClusterDetails,
        "CreateVmClusterDetails",
        models.CreateVmClusterDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateVmClusterResponse>{},
        body: await response.json(),
        bodyKey: "vmCluster",
        bodyModel: "model.VmCluster",
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates the VM cluster network.
   *
   * @param CreateVmClusterNetworkRequest
   * @return CreateVmClusterNetworkResponse
   * @throws OciError when an error occurs
   */
  public async createVmClusterNetwork(
    createVmClusterNetworkRequest: requests.CreateVmClusterNetworkRequest
  ): Promise<responses.CreateVmClusterNetworkResponse> {
    const pathParams = {
      "{exadataInfrastructureId}": createVmClusterNetworkRequest.exadataInfrastructureId
    };

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createVmClusterNetworkRequest.opcRetryToken,
      "opc-request-id": createVmClusterNetworkRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/exadataInfrastructures/{exadataInfrastructureId}/vmClusterNetworks",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createVmClusterNetworkRequest.vmClusterNetworkDetails,
        "VmClusterNetworkDetails",
        models.VmClusterNetworkDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateVmClusterNetworkResponse>{},
        body: await response.json(),
        bodyKey: "vmClusterNetwork",
        bodyModel: "model.VmClusterNetwork",
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Performs one of the following power actions on the specified DB node:
   * - start - power on
   * - stop - power off
   * - softreset - ACPI shutdown and power on
   * - reset - power off and power on
   * <p>
   **Note:** Stopping a node affects billing differently, depending on the type of DB system:
   * *Bare metal and Exadata DB systems* - The _stop_ state has no effect on the resources you consume.
   * Billing continues for DB nodes that you stop, and related resources continue
   * to apply against any relevant quotas. You must terminate the DB system
   * ({@link #terminateDbSystem(TerminateDbSystemRequest) terminateDbSystem})
   * to remove its resources from billing and quotas.
   * *Virtual machine DB systems* - Stopping a node stops billing for all OCPUs associated with that node, and billing resumes when you restart the node.
   *
   * @param DbNodeActionRequest
   * @return DbNodeActionResponse
   * @throws OciError when an error occurs
   */
  public async dbNodeAction(
    dbNodeActionRequest: requests.DbNodeActionRequest
  ): Promise<responses.DbNodeActionResponse> {
    const pathParams = {
      "{dbNodeId}": dbNodeActionRequest.dbNodeId
    };

    const queryParams = {
      "action": dbNodeActionRequest.action
    };

    let headerParams = {
      "opc-retry-token": dbNodeActionRequest.opcRetryToken,
      "if-match": dbNodeActionRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/dbNodes/{dbNodeId}",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DbNodeActionResponse>{},
        body: await response.json(),
        bodyKey: "dbNode",
        bodyModel: "model.DbNode",
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * **Deprecated.** To delete an Autonomous Data Warehouse, use the {@link #deleteAutonomousDatabase(DeleteAutonomousDatabaseRequest) deleteAutonomousDatabase} operation.
   *
   * @param DeleteAutonomousDataWarehouseRequest
   * @return DeleteAutonomousDataWarehouseResponse
   * @throws OciError when an error occurs
   */
  public async deleteAutonomousDataWarehouse(
    deleteAutonomousDataWarehouseRequest: requests.DeleteAutonomousDataWarehouseRequest
  ): Promise<responses.DeleteAutonomousDataWarehouseResponse> {
    const pathParams = {
      "{autonomousDataWarehouseId}": deleteAutonomousDataWarehouseRequest.autonomousDataWarehouseId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteAutonomousDataWarehouseRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/autonomousDataWarehouses/{autonomousDataWarehouseId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteAutonomousDataWarehouseResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Deletes the specified Autonomous Database.
   *
   * @param DeleteAutonomousDatabaseRequest
   * @return DeleteAutonomousDatabaseResponse
   * @throws OciError when an error occurs
   */
  public async deleteAutonomousDatabase(
    deleteAutonomousDatabaseRequest: requests.DeleteAutonomousDatabaseRequest
  ): Promise<responses.DeleteAutonomousDatabaseResponse> {
    const pathParams = {
      "{autonomousDatabaseId}": deleteAutonomousDatabaseRequest.autonomousDatabaseId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteAutonomousDatabaseRequest.ifMatch,
      "opc-request-id": deleteAutonomousDatabaseRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/autonomousDatabases/{autonomousDatabaseId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteAutonomousDatabaseResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Deletes a full backup. You cannot delete automatic backups using this API.
   * @param DeleteBackupRequest
   * @return DeleteBackupResponse
   * @throws OciError when an error occurs
   */
  public async deleteBackup(
    deleteBackupRequest: requests.DeleteBackupRequest
  ): Promise<responses.DeleteBackupResponse> {
    const pathParams = {
      "{backupId}": deleteBackupRequest.backupId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteBackupRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/backups/{backupId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteBackupResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Deletes a backup destination.
   *
   * @param DeleteBackupDestinationRequest
   * @return DeleteBackupDestinationResponse
   * @throws OciError when an error occurs
   */
  public async deleteBackupDestination(
    deleteBackupDestinationRequest: requests.DeleteBackupDestinationRequest
  ): Promise<responses.DeleteBackupDestinationResponse> {
    const pathParams = {
      "{backupDestinationId}": deleteBackupDestinationRequest.backupDestinationId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteBackupDestinationRequest.ifMatch,
      "opc-request-id": deleteBackupDestinationRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/backupDestinations/{backupDestinationId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteBackupDestinationResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Deletes the database. Applies only to Exadata DB systems.
* <p>
The data in this database is local to the DB system and will be lost when the database is deleted. Oracle recommends that you back up any data in the DB system prior to deleting it. You can use the `performFinalBackup` parameter to have the Exadata DB system database backed up before it is deleted.
* 
     * @param DeleteDatabaseRequest
     * @return DeleteDatabaseResponse
     * @throws OciError when an error occurs
     */
  public async deleteDatabase(
    deleteDatabaseRequest: requests.DeleteDatabaseRequest
  ): Promise<responses.DeleteDatabaseResponse> {
    const pathParams = {
      "{databaseId}": deleteDatabaseRequest.databaseId
    };

    const queryParams = {
      "performFinalBackup": deleteDatabaseRequest.performFinalBackup
    };

    let headerParams = {
      "if-match": deleteDatabaseRequest.ifMatch,
      "opc-request-id": deleteDatabaseRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/databases/{databaseId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteDatabaseResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Deletes a Database Home. Applies only to bare metal and Exadata DB systems.
* <p>
The Database Home and its database data are local to the DB system, and on a bare metal DB system, both are lost when you delete the Database Home. Oracle recommends that you back up any data on the DB system before you delete it. You can use the `performFinalBackup` parameter with this operation on bare metal DB systems.
* <p>
On an Exadata DB system, the delete request is rejected if the Database Home is not empty. You must terminate all databases in the Database Home before you delete the home. The `performFinalBackup` parameter is not used with this operation on Exadata DB systems.
* 
     * @param DeleteDbHomeRequest
     * @return DeleteDbHomeResponse
     * @throws OciError when an error occurs
     */
  public async deleteDbHome(
    deleteDbHomeRequest: requests.DeleteDbHomeRequest
  ): Promise<responses.DeleteDbHomeResponse> {
    const pathParams = {
      "{dbHomeId}": deleteDbHomeRequest.dbHomeId
    };

    const queryParams = {
      "performFinalBackup": deleteDbHomeRequest.performFinalBackup
    };

    let headerParams = {
      "if-match": deleteDbHomeRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/dbHomes/{dbHomeId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteDbHomeResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Deletes the Exadata infrastructure.
   *
   * @param DeleteExadataInfrastructureRequest
   * @return DeleteExadataInfrastructureResponse
   * @throws OciError when an error occurs
   */
  public async deleteExadataInfrastructure(
    deleteExadataInfrastructureRequest: requests.DeleteExadataInfrastructureRequest
  ): Promise<responses.DeleteExadataInfrastructureResponse> {
    const pathParams = {
      "{exadataInfrastructureId}": deleteExadataInfrastructureRequest.exadataInfrastructureId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteExadataInfrastructureRequest.ifMatch,
      "opc-request-id": deleteExadataInfrastructureRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/exadataInfrastructures/{exadataInfrastructureId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteExadataInfrastructureResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Deletes the specified VM cluster.
   *
   * @param DeleteVmClusterRequest
   * @return DeleteVmClusterResponse
   * @throws OciError when an error occurs
   */
  public async deleteVmCluster(
    deleteVmClusterRequest: requests.DeleteVmClusterRequest
  ): Promise<responses.DeleteVmClusterResponse> {
    const pathParams = {
      "{vmClusterId}": deleteVmClusterRequest.vmClusterId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteVmClusterRequest.ifMatch,
      "opc-request-id": deleteVmClusterRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/vmClusters/{vmClusterId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteVmClusterResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Deletes the specified VM cluster network.
   *
   * @param DeleteVmClusterNetworkRequest
   * @return DeleteVmClusterNetworkResponse
   * @throws OciError when an error occurs
   */
  public async deleteVmClusterNetwork(
    deleteVmClusterNetworkRequest: requests.DeleteVmClusterNetworkRequest
  ): Promise<responses.DeleteVmClusterNetworkResponse> {
    const pathParams = {
      "{exadataInfrastructureId}": deleteVmClusterNetworkRequest.exadataInfrastructureId,
      "{vmClusterNetworkId}": deleteVmClusterNetworkRequest.vmClusterNetworkId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteVmClusterNetworkRequest.ifMatch,
      "opc-request-id": deleteVmClusterNetworkRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path:
        "/exadataInfrastructures/{exadataInfrastructureId}/vmClusterNetworks/{vmClusterNetworkId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteVmClusterNetworkResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Asynchronously deregisters this Autonomous Database with Data Safe.
   *
   * @param DeregisterAutonomousDatabaseDataSafeRequest
   * @return DeregisterAutonomousDatabaseDataSafeResponse
   * @throws OciError when an error occurs
   */
  public async deregisterAutonomousDatabaseDataSafe(
    deregisterAutonomousDatabaseDataSafeRequest: requests.DeregisterAutonomousDatabaseDataSafeRequest
  ): Promise<responses.DeregisterAutonomousDatabaseDataSafeResponse> {
    const pathParams = {
      "{autonomousDatabaseId}": deregisterAutonomousDatabaseDataSafeRequest.autonomousDatabaseId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": deregisterAutonomousDatabaseDataSafeRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/autonomousDatabases/{autonomousDatabaseId}/actions/deregisterDataSafe",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeregisterAutonomousDatabaseDataSafeResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Downloads the configuration file for the specified Exadata infrastructure.
   *
   * @param DownloadExadataInfrastructureConfigFileRequest
   * @return DownloadExadataInfrastructureConfigFileResponse
   * @throws OciError when an error occurs
   */
  public async downloadExadataInfrastructureConfigFile(
    downloadExadataInfrastructureConfigFileRequest: requests.DownloadExadataInfrastructureConfigFileRequest
  ): Promise<responses.DownloadExadataInfrastructureConfigFileResponse> {
    const pathParams = {
      "{exadataInfrastructureId}":
        downloadExadataInfrastructureConfigFileRequest.exadataInfrastructureId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": downloadExadataInfrastructureConfigFileRequest.opcRequestId,
      "opc-retry-token": downloadExadataInfrastructureConfigFileRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/exadataInfrastructures/{exadataInfrastructureId}/actions/downloadConfigFile",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DownloadExadataInfrastructureConfigFileResponse>{},

        body: response.body!,
        bodyKey: "value",
        bodyModel: "string",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("content-length"),
            key: "contentLength",
            dataType: "number"
          },
          {
            value: response.headers.get("last-modified"),
            key: "lastModified",
            dataType: "Date"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Downloads the configuration file for the specified VM Cluster Network.
   *
   * @param DownloadVmClusterNetworkConfigFileRequest
   * @return DownloadVmClusterNetworkConfigFileResponse
   * @throws OciError when an error occurs
   */
  public async downloadVmClusterNetworkConfigFile(
    downloadVmClusterNetworkConfigFileRequest: requests.DownloadVmClusterNetworkConfigFileRequest
  ): Promise<responses.DownloadVmClusterNetworkConfigFileResponse> {
    const pathParams = {
      "{exadataInfrastructureId}":
        downloadVmClusterNetworkConfigFileRequest.exadataInfrastructureId,
      "{vmClusterNetworkId}": downloadVmClusterNetworkConfigFileRequest.vmClusterNetworkId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": downloadVmClusterNetworkConfigFileRequest.opcRequestId,
      "opc-retry-token": downloadVmClusterNetworkConfigFileRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path:
        "/exadataInfrastructures/{exadataInfrastructureId}/vmClusterNetworks/{vmClusterNetworkId}/actions/downloadConfigFile",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DownloadVmClusterNetworkConfigFileResponse>{},

        body: response.body!,
        bodyKey: "value",
        bodyModel: "string",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("content-length"),
            key: "contentLength",
            dataType: "number"
          },
          {
            value: response.headers.get("last-modified"),
            key: "lastModified",
            dataType: "Date"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Performs a failover to transition the standby database identified by the `databaseId` parameter into the
* specified Data Guard association's primary role after the existing primary database fails or becomes unreachable.
* <p>
A failover might result in data loss depending on the protection mode in effect at the time of the primary
* database failure.
* 
     * @param FailoverDataGuardAssociationRequest
     * @return FailoverDataGuardAssociationResponse
     * @throws OciError when an error occurs
     */
  public async failoverDataGuardAssociation(
    failoverDataGuardAssociationRequest: requests.FailoverDataGuardAssociationRequest
  ): Promise<responses.FailoverDataGuardAssociationResponse> {
    const pathParams = {
      "{databaseId}": failoverDataGuardAssociationRequest.databaseId,
      "{dataGuardAssociationId}": failoverDataGuardAssociationRequest.dataGuardAssociationId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": failoverDataGuardAssociationRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path:
        "/databases/{databaseId}/dataGuardAssociations/{dataGuardAssociationId}/actions/failover",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        failoverDataGuardAssociationRequest.failoverDataGuardAssociationDetails,
        "FailoverDataGuardAssociationDetails",
        models.FailoverDataGuardAssociationDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.FailoverDataGuardAssociationResponse>{},
        body: await response.json(),
        bodyKey: "dataGuardAssociation",
        bodyModel: "model.DataGuardAssociation",
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * **Deprecated.** To create and download a wallet for an Autonomous Data Warehouse, use the {@link #generateAutonomousDatabaseWallet(GenerateAutonomousDatabaseWalletRequest) generateAutonomousDatabaseWallet} operation.
   *
   * @param GenerateAutonomousDataWarehouseWalletRequest
   * @return GenerateAutonomousDataWarehouseWalletResponse
   * @throws OciError when an error occurs
   */
  public async generateAutonomousDataWarehouseWallet(
    generateAutonomousDataWarehouseWalletRequest: requests.GenerateAutonomousDataWarehouseWalletRequest
  ): Promise<responses.GenerateAutonomousDataWarehouseWalletResponse> {
    const pathParams = {
      "{autonomousDataWarehouseId}":
        generateAutonomousDataWarehouseWalletRequest.autonomousDataWarehouseId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": generateAutonomousDataWarehouseWalletRequest.opcRequestId,
      "opc-retry-token": generateAutonomousDataWarehouseWalletRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/autonomousDataWarehouses/{autonomousDataWarehouseId}/actions/generateWallet",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        generateAutonomousDataWarehouseWalletRequest.generateAutonomousDataWarehouseWalletDetails,
        "GenerateAutonomousDataWarehouseWalletDetails",
        models.GenerateAutonomousDataWarehouseWalletDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GenerateAutonomousDataWarehouseWalletResponse>{},

        body: response.body!,
        bodyKey: "value",
        bodyModel: "string",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("content-length"),
            key: "contentLength",
            dataType: "number"
          },
          {
            value: response.headers.get("last-modified"),
            key: "lastModified",
            dataType: "Date"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates and downloads a wallet for the specified Autonomous Database.
   *
   * @param GenerateAutonomousDatabaseWalletRequest
   * @return GenerateAutonomousDatabaseWalletResponse
   * @throws OciError when an error occurs
   */
  public async generateAutonomousDatabaseWallet(
    generateAutonomousDatabaseWalletRequest: requests.GenerateAutonomousDatabaseWalletRequest
  ): Promise<responses.GenerateAutonomousDatabaseWalletResponse> {
    const pathParams = {
      "{autonomousDatabaseId}": generateAutonomousDatabaseWalletRequest.autonomousDatabaseId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": generateAutonomousDatabaseWalletRequest.opcRequestId,
      "opc-retry-token": generateAutonomousDatabaseWalletRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/autonomousDatabases/{autonomousDatabaseId}/actions/generateWallet",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        generateAutonomousDatabaseWalletRequest.generateAutonomousDatabaseWalletDetails,
        "GenerateAutonomousDatabaseWalletDetails",
        models.GenerateAutonomousDatabaseWalletDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GenerateAutonomousDatabaseWalletResponse>{},

        body: response.body!,
        bodyKey: "value",
        bodyModel: "string",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("content-length"),
            key: "contentLength",
            dataType: "number"
          },
          {
            value: response.headers.get("last-modified"),
            key: "lastModified",
            dataType: "Date"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Generates a recommended VM cluster network configuration.
   *
   * @param GenerateRecommendedVmClusterNetworkRequest
   * @return GenerateRecommendedVmClusterNetworkResponse
   * @throws OciError when an error occurs
   */
  public async generateRecommendedVmClusterNetwork(
    generateRecommendedVmClusterNetworkRequest: requests.GenerateRecommendedVmClusterNetworkRequest
  ): Promise<responses.GenerateRecommendedVmClusterNetworkResponse> {
    const pathParams = {
      "{exadataInfrastructureId}":
        generateRecommendedVmClusterNetworkRequest.exadataInfrastructureId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": generateRecommendedVmClusterNetworkRequest.opcRequestId,
      "opc-retry-token": generateRecommendedVmClusterNetworkRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path:
        "/exadataInfrastructures/{exadataInfrastructureId}/vmClusterNetworks/actions/generateRecommendedNetwork",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        generateRecommendedVmClusterNetworkRequest.generateRecommendedNetworkDetails,
        "GenerateRecommendedNetworkDetails",
        models.GenerateRecommendedNetworkDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GenerateRecommendedVmClusterNetworkResponse>{},
        body: await response.json(),
        bodyKey: "vmClusterNetworkDetails",
        bodyModel: "model.VmClusterNetworkDetails",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets information about the specified Autonomous Container Database.
   * @param GetAutonomousContainerDatabaseRequest
   * @return GetAutonomousContainerDatabaseResponse
   * @throws OciError when an error occurs
   */
  public async getAutonomousContainerDatabase(
    getAutonomousContainerDatabaseRequest: requests.GetAutonomousContainerDatabaseRequest
  ): Promise<responses.GetAutonomousContainerDatabaseResponse> {
    const pathParams = {
      "{autonomousContainerDatabaseId}":
        getAutonomousContainerDatabaseRequest.autonomousContainerDatabaseId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/autonomousContainerDatabases/{autonomousContainerDatabaseId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetAutonomousContainerDatabaseResponse>{},
        body: await response.json(),
        bodyKey: "autonomousContainerDatabase",
        bodyModel: "model.AutonomousContainerDatabase",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * **Deprecated.** To get the details of an Autonomous Data Warehouse, use the {@link #getAutonomousDatabase(GetAutonomousDatabaseRequest) getAutonomousDatabase} operation.
   *
   * @param GetAutonomousDataWarehouseRequest
   * @return GetAutonomousDataWarehouseResponse
   * @throws OciError when an error occurs
   */
  public async getAutonomousDataWarehouse(
    getAutonomousDataWarehouseRequest: requests.GetAutonomousDataWarehouseRequest
  ): Promise<responses.GetAutonomousDataWarehouseResponse> {
    const pathParams = {
      "{autonomousDataWarehouseId}": getAutonomousDataWarehouseRequest.autonomousDataWarehouseId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/autonomousDataWarehouses/{autonomousDataWarehouseId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetAutonomousDataWarehouseResponse>{},
        body: await response.json(),
        bodyKey: "autonomousDataWarehouse",
        bodyModel: "model.AutonomousDataWarehouse",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * **Deprecated.** To get information about a specified Autonomous Data Warehouse backup, use the {@link #getAutonomousDatabaseBackup(GetAutonomousDatabaseBackupRequest) getAutonomousDatabaseBackup} operation.
   *
   * @param GetAutonomousDataWarehouseBackupRequest
   * @return GetAutonomousDataWarehouseBackupResponse
   * @throws OciError when an error occurs
   */
  public async getAutonomousDataWarehouseBackup(
    getAutonomousDataWarehouseBackupRequest: requests.GetAutonomousDataWarehouseBackupRequest
  ): Promise<responses.GetAutonomousDataWarehouseBackupResponse> {
    const pathParams = {
      "{autonomousDataWarehouseBackupId}":
        getAutonomousDataWarehouseBackupRequest.autonomousDataWarehouseBackupId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/autonomousDataWarehouseBackups/{autonomousDataWarehouseBackupId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetAutonomousDataWarehouseBackupResponse>{},
        body: await response.json(),
        bodyKey: "autonomousDataWarehouseBackup",
        bodyModel: "model.AutonomousDataWarehouseBackup",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the details of the specified Autonomous Database.
   *
   * @param GetAutonomousDatabaseRequest
   * @return GetAutonomousDatabaseResponse
   * @throws OciError when an error occurs
   */
  public async getAutonomousDatabase(
    getAutonomousDatabaseRequest: requests.GetAutonomousDatabaseRequest
  ): Promise<responses.GetAutonomousDatabaseResponse> {
    const pathParams = {
      "{autonomousDatabaseId}": getAutonomousDatabaseRequest.autonomousDatabaseId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getAutonomousDatabaseRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/autonomousDatabases/{autonomousDatabaseId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetAutonomousDatabaseResponse>{},
        body: await response.json(),
        bodyKey: "autonomousDatabase",
        bodyModel: "model.AutonomousDatabase",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets information about the specified Autonomous Database backup.
   * @param GetAutonomousDatabaseBackupRequest
   * @return GetAutonomousDatabaseBackupResponse
   * @throws OciError when an error occurs
   */
  public async getAutonomousDatabaseBackup(
    getAutonomousDatabaseBackupRequest: requests.GetAutonomousDatabaseBackupRequest
  ): Promise<responses.GetAutonomousDatabaseBackupResponse> {
    const pathParams = {
      "{autonomousDatabaseBackupId}": getAutonomousDatabaseBackupRequest.autonomousDatabaseBackupId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getAutonomousDatabaseBackupRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/autonomousDatabaseBackups/{autonomousDatabaseBackupId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetAutonomousDatabaseBackupResponse>{},
        body: await response.json(),
        bodyKey: "autonomousDatabaseBackup",
        bodyModel: "model.AutonomousDatabaseBackup",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the Autonomous Database regional wallet details.
   *
   * @param GetAutonomousDatabaseRegionalWalletRequest
   * @return GetAutonomousDatabaseRegionalWalletResponse
   * @throws OciError when an error occurs
   */
  public async getAutonomousDatabaseRegionalWallet(
    getAutonomousDatabaseRegionalWalletRequest: requests.GetAutonomousDatabaseRegionalWalletRequest
  ): Promise<responses.GetAutonomousDatabaseRegionalWalletResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getAutonomousDatabaseRegionalWalletRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/autonomousDatabases/wallet",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetAutonomousDatabaseRegionalWalletResponse>{},
        body: await response.json(),
        bodyKey: "autonomousDatabaseWallet",
        bodyModel: "model.AutonomousDatabaseWallet",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the wallet details for the specified Autonomous Database.
   *
   * @param GetAutonomousDatabaseWalletRequest
   * @return GetAutonomousDatabaseWalletResponse
   * @throws OciError when an error occurs
   */
  public async getAutonomousDatabaseWallet(
    getAutonomousDatabaseWalletRequest: requests.GetAutonomousDatabaseWalletRequest
  ): Promise<responses.GetAutonomousDatabaseWalletResponse> {
    const pathParams = {
      "{autonomousDatabaseId}": getAutonomousDatabaseWalletRequest.autonomousDatabaseId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getAutonomousDatabaseWalletRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/autonomousDatabases/{autonomousDatabaseId}/wallet",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetAutonomousDatabaseWalletResponse>{},
        body: await response.json(),
        bodyKey: "autonomousDatabaseWallet",
        bodyModel: "model.AutonomousDatabaseWallet",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets information about the specified Autonomous Exadata Infrastructure.
   * @param GetAutonomousExadataInfrastructureRequest
   * @return GetAutonomousExadataInfrastructureResponse
   * @throws OciError when an error occurs
   */
  public async getAutonomousExadataInfrastructure(
    getAutonomousExadataInfrastructureRequest: requests.GetAutonomousExadataInfrastructureRequest
  ): Promise<responses.GetAutonomousExadataInfrastructureResponse> {
    const pathParams = {
      "{autonomousExadataInfrastructureId}":
        getAutonomousExadataInfrastructureRequest.autonomousExadataInfrastructureId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/autonomousExadataInfrastructures/{autonomousExadataInfrastructureId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetAutonomousExadataInfrastructureResponse>{},
        body: await response.json(),
        bodyKey: "autonomousExadataInfrastructure",
        bodyModel: "model.AutonomousExadataInfrastructure",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets information about the specified backup.
   * @param GetBackupRequest
   * @return GetBackupResponse
   * @throws OciError when an error occurs
   */
  public async getBackup(
    getBackupRequest: requests.GetBackupRequest
  ): Promise<responses.GetBackupResponse> {
    const pathParams = {
      "{backupId}": getBackupRequest.backupId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/backups/{backupId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetBackupResponse>{},
        body: await response.json(),
        bodyKey: "backup",
        bodyModel: "model.Backup",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets information about the specified backup destination.
   *
   * @param GetBackupDestinationRequest
   * @return GetBackupDestinationResponse
   * @throws OciError when an error occurs
   */
  public async getBackupDestination(
    getBackupDestinationRequest: requests.GetBackupDestinationRequest
  ): Promise<responses.GetBackupDestinationResponse> {
    const pathParams = {
      "{backupDestinationId}": getBackupDestinationRequest.backupDestinationId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getBackupDestinationRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/backupDestinations/{backupDestinationId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetBackupDestinationResponse>{},
        body: await response.json(),
        bodyKey: "backupDestination",
        bodyModel: "model.BackupDestination",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the specified Data Guard association's configuration information.
   *
   * @param GetDataGuardAssociationRequest
   * @return GetDataGuardAssociationResponse
   * @throws OciError when an error occurs
   */
  public async getDataGuardAssociation(
    getDataGuardAssociationRequest: requests.GetDataGuardAssociationRequest
  ): Promise<responses.GetDataGuardAssociationResponse> {
    const pathParams = {
      "{databaseId}": getDataGuardAssociationRequest.databaseId,
      "{dataGuardAssociationId}": getDataGuardAssociationRequest.dataGuardAssociationId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/databases/{databaseId}/dataGuardAssociations/{dataGuardAssociationId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetDataGuardAssociationResponse>{},
        body: await response.json(),
        bodyKey: "dataGuardAssociation",
        bodyModel: "model.DataGuardAssociation",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets information about a specific database.
   * @param GetDatabaseRequest
   * @return GetDatabaseResponse
   * @throws OciError when an error occurs
   */
  public async getDatabase(
    getDatabaseRequest: requests.GetDatabaseRequest
  ): Promise<responses.GetDatabaseResponse> {
    const pathParams = {
      "{databaseId}": getDatabaseRequest.databaseId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/databases/{databaseId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetDatabaseResponse>{},
        body: await response.json(),
        bodyKey: "database",
        bodyModel: "model.Database",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets information about the specified Database Home.
   * @param GetDbHomeRequest
   * @return GetDbHomeResponse
   * @throws OciError when an error occurs
   */
  public async getDbHome(
    getDbHomeRequest: requests.GetDbHomeRequest
  ): Promise<responses.GetDbHomeResponse> {
    const pathParams = {
      "{dbHomeId}": getDbHomeRequest.dbHomeId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/dbHomes/{dbHomeId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetDbHomeResponse>{},
        body: await response.json(),
        bodyKey: "dbHome",
        bodyModel: "model.DbHome",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets information about a specified patch package.
   *
   * @param GetDbHomePatchRequest
   * @return GetDbHomePatchResponse
   * @throws OciError when an error occurs
   */
  public async getDbHomePatch(
    getDbHomePatchRequest: requests.GetDbHomePatchRequest
  ): Promise<responses.GetDbHomePatchResponse> {
    const pathParams = {
      "{dbHomeId}": getDbHomePatchRequest.dbHomeId,
      "{patchId}": getDbHomePatchRequest.patchId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/dbHomes/{dbHomeId}/patches/{patchId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetDbHomePatchResponse>{},
        body: await response.json(),
        bodyKey: "patch",
        bodyModel: "model.Patch",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the patch history details for the specified patchHistoryEntryId
   *
   * @param GetDbHomePatchHistoryEntryRequest
   * @return GetDbHomePatchHistoryEntryResponse
   * @throws OciError when an error occurs
   */
  public async getDbHomePatchHistoryEntry(
    getDbHomePatchHistoryEntryRequest: requests.GetDbHomePatchHistoryEntryRequest
  ): Promise<responses.GetDbHomePatchHistoryEntryResponse> {
    const pathParams = {
      "{dbHomeId}": getDbHomePatchHistoryEntryRequest.dbHomeId,
      "{patchHistoryEntryId}": getDbHomePatchHistoryEntryRequest.patchHistoryEntryId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/dbHomes/{dbHomeId}/patchHistoryEntries/{patchHistoryEntryId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetDbHomePatchHistoryEntryResponse>{},
        body: await response.json(),
        bodyKey: "patchHistoryEntry",
        bodyModel: "model.PatchHistoryEntry",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets information about the specified database node.
   * @param GetDbNodeRequest
   * @return GetDbNodeResponse
   * @throws OciError when an error occurs
   */
  public async getDbNode(
    getDbNodeRequest: requests.GetDbNodeRequest
  ): Promise<responses.GetDbNodeResponse> {
    const pathParams = {
      "{dbNodeId}": getDbNodeRequest.dbNodeId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/dbNodes/{dbNodeId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetDbNodeResponse>{},
        body: await response.json(),
        bodyKey: "dbNode",
        bodyModel: "model.DbNode",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets information about the specified DB system.
   * @param GetDbSystemRequest
   * @return GetDbSystemResponse
   * @throws OciError when an error occurs
   */
  public async getDbSystem(
    getDbSystemRequest: requests.GetDbSystemRequest
  ): Promise<responses.GetDbSystemResponse> {
    const pathParams = {
      "{dbSystemId}": getDbSystemRequest.dbSystemId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/dbSystems/{dbSystemId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetDbSystemResponse>{},
        body: await response.json(),
        bodyKey: "dbSystem",
        bodyModel: "model.DbSystem",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets information about a specified patch package.
   *
   * @param GetDbSystemPatchRequest
   * @return GetDbSystemPatchResponse
   * @throws OciError when an error occurs
   */
  public async getDbSystemPatch(
    getDbSystemPatchRequest: requests.GetDbSystemPatchRequest
  ): Promise<responses.GetDbSystemPatchResponse> {
    const pathParams = {
      "{dbSystemId}": getDbSystemPatchRequest.dbSystemId,
      "{patchId}": getDbSystemPatchRequest.patchId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/dbSystems/{dbSystemId}/patches/{patchId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetDbSystemPatchResponse>{},
        body: await response.json(),
        bodyKey: "patch",
        bodyModel: "model.Patch",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the patch history details for the specified patchHistoryEntryId.
   *
   * @param GetDbSystemPatchHistoryEntryRequest
   * @return GetDbSystemPatchHistoryEntryResponse
   * @throws OciError when an error occurs
   */
  public async getDbSystemPatchHistoryEntry(
    getDbSystemPatchHistoryEntryRequest: requests.GetDbSystemPatchHistoryEntryRequest
  ): Promise<responses.GetDbSystemPatchHistoryEntryResponse> {
    const pathParams = {
      "{dbSystemId}": getDbSystemPatchHistoryEntryRequest.dbSystemId,
      "{patchHistoryEntryId}": getDbSystemPatchHistoryEntryRequest.patchHistoryEntryId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/dbSystems/{dbSystemId}/patchHistoryEntries/{patchHistoryEntryId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetDbSystemPatchHistoryEntryResponse>{},
        body: await response.json(),
        bodyKey: "patchHistoryEntry",
        bodyModel: "model.PatchHistoryEntry",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets information about the specified Exadata infrastructure.
   * @param GetExadataInfrastructureRequest
   * @return GetExadataInfrastructureResponse
   * @throws OciError when an error occurs
   */
  public async getExadataInfrastructure(
    getExadataInfrastructureRequest: requests.GetExadataInfrastructureRequest
  ): Promise<responses.GetExadataInfrastructureResponse> {
    const pathParams = {
      "{exadataInfrastructureId}": getExadataInfrastructureRequest.exadataInfrastructureId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getExadataInfrastructureRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/exadataInfrastructures/{exadataInfrastructureId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetExadataInfrastructureResponse>{},
        body: await response.json(),
        bodyKey: "exadataInfrastructure",
        bodyModel: "model.ExadataInfrastructure",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets details of the available and consumed OCPUs for the specified Autonomous Exadata Infrastructure instance.
   *
   * @param GetExadataInfrastructureOcpusRequest
   * @return GetExadataInfrastructureOcpusResponse
   * @throws OciError when an error occurs
   */
  public async getExadataInfrastructureOcpus(
    getExadataInfrastructureOcpusRequest: requests.GetExadataInfrastructureOcpusRequest
  ): Promise<responses.GetExadataInfrastructureOcpusResponse> {
    const pathParams = {
      "{autonomousExadataInfrastructureId}":
        getExadataInfrastructureOcpusRequest.autonomousExadataInfrastructureId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getExadataInfrastructureOcpusRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/autonomousExadataInfrastructures/{autonomousExadataInfrastructureId}/ocpus",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetExadataInfrastructureOcpusResponse>{},
        body: await response.json(),
        bodyKey: "oCPUs",
        bodyModel: "model.OCPUs",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets `IORM` Setting for the requested Exadata DB System.
   * The default IORM Settings is pre-created in all the Exadata DB System.
   *
   * @param GetExadataIormConfigRequest
   * @return GetExadataIormConfigResponse
   * @throws OciError when an error occurs
   */
  public async getExadataIormConfig(
    getExadataIormConfigRequest: requests.GetExadataIormConfigRequest
  ): Promise<responses.GetExadataIormConfigResponse> {
    const pathParams = {
      "{dbSystemId}": getExadataIormConfigRequest.dbSystemId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getExadataIormConfigRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/dbSystems/{dbSystemId}/ExadataIormConfig",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetExadataIormConfigResponse>{},
        body: await response.json(),
        bodyKey: "exadataIormConfig",
        bodyModel: "model.ExadataIormConfig",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets information about the specified external backup job.
   * <p>
   **Note:** This API is used by an Oracle Cloud Infrastructure Python script that is packaged with the Oracle Cloud Infrastructure CLI. Oracle recommends that you use the script instead using the API directly. See [Migrating an On-Premises Database to Oracle Cloud Infrastructure by Creating a Backup in the Cloud](https://docs.cloud.oracle.com/Content/Database/Tasks/mig-onprembackup.htm) for more information.
   *
   * @param GetExternalBackupJobRequest
   * @return GetExternalBackupJobResponse
   * @throws OciError when an error occurs
   */
  public async getExternalBackupJob(
    getExternalBackupJobRequest: requests.GetExternalBackupJobRequest
  ): Promise<responses.GetExternalBackupJobResponse> {
    const pathParams = {
      "{backupId}": getExternalBackupJobRequest.backupId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/externalBackupJobs/{backupId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetExternalBackupJobResponse>{},
        body: await response.json(),
        bodyKey: "externalBackupJob",
        bodyModel: "model.ExternalBackupJob",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets information about the specified Maintenance Run.
   * @param GetMaintenanceRunRequest
   * @return GetMaintenanceRunResponse
   * @throws OciError when an error occurs
   */
  public async getMaintenanceRun(
    getMaintenanceRunRequest: requests.GetMaintenanceRunRequest
  ): Promise<responses.GetMaintenanceRunResponse> {
    const pathParams = {
      "{maintenanceRunId}": getMaintenanceRunRequest.maintenanceRunId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/maintenanceRuns/{maintenanceRunId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetMaintenanceRunResponse>{},
        body: await response.json(),
        bodyKey: "maintenanceRun",
        bodyModel: "model.MaintenanceRun",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets information about the specified VM cluster.
   * @param GetVmClusterRequest
   * @return GetVmClusterResponse
   * @throws OciError when an error occurs
   */
  public async getVmCluster(
    getVmClusterRequest: requests.GetVmClusterRequest
  ): Promise<responses.GetVmClusterResponse> {
    const pathParams = {
      "{vmClusterId}": getVmClusterRequest.vmClusterId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getVmClusterRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/vmClusters/{vmClusterId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetVmClusterResponse>{},
        body: await response.json(),
        bodyKey: "vmCluster",
        bodyModel: "model.VmCluster",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets information about the specified VM cluster network.
   * @param GetVmClusterNetworkRequest
   * @return GetVmClusterNetworkResponse
   * @throws OciError when an error occurs
   */
  public async getVmClusterNetwork(
    getVmClusterNetworkRequest: requests.GetVmClusterNetworkRequest
  ): Promise<responses.GetVmClusterNetworkResponse> {
    const pathParams = {
      "{exadataInfrastructureId}": getVmClusterNetworkRequest.exadataInfrastructureId,
      "{vmClusterNetworkId}": getVmClusterNetworkRequest.vmClusterNetworkId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getVmClusterNetworkRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path:
        "/exadataInfrastructures/{exadataInfrastructureId}/vmClusterNetworks/{vmClusterNetworkId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetVmClusterNetworkResponse>{},
        body: await response.json(),
        bodyKey: "vmClusterNetwork",
        bodyModel: "model.VmClusterNetwork",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Launches a new Autonomous Exadata Infrastructure in the specified compartment and availability domain.
   *
   * @param LaunchAutonomousExadataInfrastructureRequest
   * @return LaunchAutonomousExadataInfrastructureResponse
   * @throws OciError when an error occurs
   */
  public async launchAutonomousExadataInfrastructure(
    launchAutonomousExadataInfrastructureRequest: requests.LaunchAutonomousExadataInfrastructureRequest
  ): Promise<responses.LaunchAutonomousExadataInfrastructureResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": launchAutonomousExadataInfrastructureRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/autonomousExadataInfrastructures",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        launchAutonomousExadataInfrastructureRequest.launchAutonomousExadataInfrastructureDetails,
        "LaunchAutonomousExadataInfrastructureDetails",
        models.LaunchAutonomousExadataInfrastructureDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.LaunchAutonomousExadataInfrastructureResponse>{},
        body: await response.json(),
        bodyKey: "autonomousExadataInfrastructure",
        bodyModel: "model.AutonomousExadataInfrastructure",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Creates a new DB system in the specified compartment and availability domain. The Oracle
* Database edition that you specify applies to all the databases on that DB system. The selected edition cannot be changed.
* <p>
An initial database is created on the DB system based on the request parameters you provide and some default
* options. For detailed information about default options, see the following:
* <p>
- [Bare metal and virtual machine DB system default options](https://docs.cloud.oracle.com/Content/Database/Tasks/creatingDBsystem.htm#DefaultOptionsfortheInitialDatabase)
* - [Exadata DB system default options](https://docs.cloud.oracle.com/Content/Database/Tasks/exacreatingDBsystem.htm#DefaultOptionsfortheInitialDatabase)
* 
     * @param LaunchDbSystemRequest
     * @return LaunchDbSystemResponse
     * @throws OciError when an error occurs
     */
  public async launchDbSystem(
    launchDbSystemRequest: requests.LaunchDbSystemRequest
  ): Promise<responses.LaunchDbSystemResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": launchDbSystemRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/dbSystems",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        launchDbSystemRequest.launchDbSystemDetails,
        "LaunchDbSystemBase",
        models.LaunchDbSystemBase.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.LaunchDbSystemResponse>{},
        body: await response.json(),
        bodyKey: "dbSystem",
        bodyModel: "model.DbSystem",
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets a list of the Autonomous Container Databases in the specified compartment.
   *
   * @param ListAutonomousContainerDatabasesRequest
   * @return ListAutonomousContainerDatabasesResponse
   * @throws OciError when an error occurs
   */
  public async listAutonomousContainerDatabases(
    listAutonomousContainerDatabasesRequest: requests.ListAutonomousContainerDatabasesRequest
  ): Promise<responses.ListAutonomousContainerDatabasesResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listAutonomousContainerDatabasesRequest.compartmentId,
      "autonomousExadataInfrastructureId":
        listAutonomousContainerDatabasesRequest.autonomousExadataInfrastructureId,
      "limit": listAutonomousContainerDatabasesRequest.limit,
      "page": listAutonomousContainerDatabasesRequest.page,
      "sortBy": listAutonomousContainerDatabasesRequest.sortBy,
      "sortOrder": listAutonomousContainerDatabasesRequest.sortOrder,
      "lifecycleState": listAutonomousContainerDatabasesRequest.lifecycleState,
      "availabilityDomain": listAutonomousContainerDatabasesRequest.availabilityDomain,
      "displayName": listAutonomousContainerDatabasesRequest.displayName
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/autonomousContainerDatabases",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListAutonomousContainerDatabasesResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "AutonomousContainerDatabaseSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.AutonomousContainerDatabaseSummary objects
   * contained in responses from the listAutonomousContainerDatabases operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllAutonomousContainerDatabases(
    request: requests.ListAutonomousContainerDatabasesRequest
  ): AsyncIterableIterator<models.AutonomousContainerDatabaseSummary> {
    return paginateRecords(request, req => this.listAutonomousContainerDatabases(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listAutonomousContainerDatabases operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllAutonomousContainerDatabasesResponses(
    request: requests.ListAutonomousContainerDatabasesRequest
  ): AsyncIterableIterator<responses.ListAutonomousContainerDatabasesResponse> {
    return paginateResponses(request, req => this.listAutonomousContainerDatabases(req));
  }

  /**
   * **Deprecated.** To get a list of Autonomous Data Warehouse backups, use the {@link #listAutonomousDatabaseBackups(ListAutonomousDatabaseBackupsRequest) listAutonomousDatabaseBackups} operation.
   *
   * @param ListAutonomousDataWarehouseBackupsRequest
   * @return ListAutonomousDataWarehouseBackupsResponse
   * @throws OciError when an error occurs
   */
  public async listAutonomousDataWarehouseBackups(
    listAutonomousDataWarehouseBackupsRequest: requests.ListAutonomousDataWarehouseBackupsRequest
  ): Promise<responses.ListAutonomousDataWarehouseBackupsResponse> {
    const pathParams = {};

    const queryParams = {
      "autonomousDataWarehouseId":
        listAutonomousDataWarehouseBackupsRequest.autonomousDataWarehouseId,
      "compartmentId": listAutonomousDataWarehouseBackupsRequest.compartmentId,
      "limit": listAutonomousDataWarehouseBackupsRequest.limit,
      "page": listAutonomousDataWarehouseBackupsRequest.page,
      "sortBy": listAutonomousDataWarehouseBackupsRequest.sortBy,
      "sortOrder": listAutonomousDataWarehouseBackupsRequest.sortOrder,
      "lifecycleState": listAutonomousDataWarehouseBackupsRequest.lifecycleState,
      "displayName": listAutonomousDataWarehouseBackupsRequest.displayName
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/autonomousDataWarehouseBackups",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListAutonomousDataWarehouseBackupsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "AutonomousDataWarehouseBackupSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.AutonomousDataWarehouseBackupSummary objects
   * contained in responses from the listAutonomousDataWarehouseBackups operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllAutonomousDataWarehouseBackups(
    request: requests.ListAutonomousDataWarehouseBackupsRequest
  ): AsyncIterableIterator<models.AutonomousDataWarehouseBackupSummary> {
    return paginateRecords(request, req => this.listAutonomousDataWarehouseBackups(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listAutonomousDataWarehouseBackups operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllAutonomousDataWarehouseBackupsResponses(
    request: requests.ListAutonomousDataWarehouseBackupsRequest
  ): AsyncIterableIterator<responses.ListAutonomousDataWarehouseBackupsResponse> {
    return paginateResponses(request, req => this.listAutonomousDataWarehouseBackups(req));
  }

  /**
   * **Deprecated.** To get a list of Autonomous Data Warehouses, use the {@link #listAutonomousDatabases(ListAutonomousDatabasesRequest) listAutonomousDatabases} operation and specify `DW` as the workload type.
   *
   * @param ListAutonomousDataWarehousesRequest
   * @return ListAutonomousDataWarehousesResponse
   * @throws OciError when an error occurs
   */
  public async listAutonomousDataWarehouses(
    listAutonomousDataWarehousesRequest: requests.ListAutonomousDataWarehousesRequest
  ): Promise<responses.ListAutonomousDataWarehousesResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listAutonomousDataWarehousesRequest.compartmentId,
      "limit": listAutonomousDataWarehousesRequest.limit,
      "page": listAutonomousDataWarehousesRequest.page,
      "sortBy": listAutonomousDataWarehousesRequest.sortBy,
      "sortOrder": listAutonomousDataWarehousesRequest.sortOrder,
      "lifecycleState": listAutonomousDataWarehousesRequest.lifecycleState,
      "displayName": listAutonomousDataWarehousesRequest.displayName
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/autonomousDataWarehouses",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListAutonomousDataWarehousesResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "AutonomousDataWarehouseSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.AutonomousDataWarehouseSummary objects
   * contained in responses from the listAutonomousDataWarehouses operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllAutonomousDataWarehouses(
    request: requests.ListAutonomousDataWarehousesRequest
  ): AsyncIterableIterator<models.AutonomousDataWarehouseSummary> {
    return paginateRecords(request, req => this.listAutonomousDataWarehouses(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listAutonomousDataWarehouses operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllAutonomousDataWarehousesResponses(
    request: requests.ListAutonomousDataWarehousesRequest
  ): AsyncIterableIterator<responses.ListAutonomousDataWarehousesResponse> {
    return paginateResponses(request, req => this.listAutonomousDataWarehouses(req));
  }

  /**
   * Gets a list of Autonomous Database backups based on either the `autonomousDatabaseId` or `compartmentId` specified as a query parameter.
   *
   * @param ListAutonomousDatabaseBackupsRequest
   * @return ListAutonomousDatabaseBackupsResponse
   * @throws OciError when an error occurs
   */
  public async listAutonomousDatabaseBackups(
    listAutonomousDatabaseBackupsRequest: requests.ListAutonomousDatabaseBackupsRequest
  ): Promise<responses.ListAutonomousDatabaseBackupsResponse> {
    const pathParams = {};

    const queryParams = {
      "autonomousDatabaseId": listAutonomousDatabaseBackupsRequest.autonomousDatabaseId,
      "compartmentId": listAutonomousDatabaseBackupsRequest.compartmentId,
      "limit": listAutonomousDatabaseBackupsRequest.limit,
      "page": listAutonomousDatabaseBackupsRequest.page,
      "sortBy": listAutonomousDatabaseBackupsRequest.sortBy,
      "sortOrder": listAutonomousDatabaseBackupsRequest.sortOrder,
      "lifecycleState": listAutonomousDatabaseBackupsRequest.lifecycleState,
      "displayName": listAutonomousDatabaseBackupsRequest.displayName
    };

    let headerParams = {
      "opc-request-id": listAutonomousDatabaseBackupsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/autonomousDatabaseBackups",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListAutonomousDatabaseBackupsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "AutonomousDatabaseBackupSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.AutonomousDatabaseBackupSummary objects
   * contained in responses from the listAutonomousDatabaseBackups operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllAutonomousDatabaseBackups(
    request: requests.ListAutonomousDatabaseBackupsRequest
  ): AsyncIterableIterator<models.AutonomousDatabaseBackupSummary> {
    return paginateRecords(request, req => this.listAutonomousDatabaseBackups(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listAutonomousDatabaseBackups operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllAutonomousDatabaseBackupsResponses(
    request: requests.ListAutonomousDatabaseBackupsRequest
  ): AsyncIterableIterator<responses.ListAutonomousDatabaseBackupsResponse> {
    return paginateResponses(request, req => this.listAutonomousDatabaseBackups(req));
  }

  /**
   * Gets a list of Autonomous Databases.
   *
   * @param ListAutonomousDatabasesRequest
   * @return ListAutonomousDatabasesResponse
   * @throws OciError when an error occurs
   */
  public async listAutonomousDatabases(
    listAutonomousDatabasesRequest: requests.ListAutonomousDatabasesRequest
  ): Promise<responses.ListAutonomousDatabasesResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listAutonomousDatabasesRequest.compartmentId,
      "autonomousContainerDatabaseId": listAutonomousDatabasesRequest.autonomousContainerDatabaseId,
      "limit": listAutonomousDatabasesRequest.limit,
      "page": listAutonomousDatabasesRequest.page,
      "sortBy": listAutonomousDatabasesRequest.sortBy,
      "sortOrder": listAutonomousDatabasesRequest.sortOrder,
      "lifecycleState": listAutonomousDatabasesRequest.lifecycleState,
      "dbWorkload": listAutonomousDatabasesRequest.dbWorkload,
      "dbVersion": listAutonomousDatabasesRequest.dbVersion,
      "isFreeTier": listAutonomousDatabasesRequest.isFreeTier,
      "displayName": listAutonomousDatabasesRequest.displayName
    };

    let headerParams = {
      "opc-request-id": listAutonomousDatabasesRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/autonomousDatabases",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListAutonomousDatabasesResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "AutonomousDatabaseSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.AutonomousDatabaseSummary objects
   * contained in responses from the listAutonomousDatabases operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllAutonomousDatabases(
    request: requests.ListAutonomousDatabasesRequest
  ): AsyncIterableIterator<models.AutonomousDatabaseSummary> {
    return paginateRecords(request, req => this.listAutonomousDatabases(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listAutonomousDatabases operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllAutonomousDatabasesResponses(
    request: requests.ListAutonomousDatabasesRequest
  ): AsyncIterableIterator<responses.ListAutonomousDatabasesResponse> {
    return paginateResponses(request, req => this.listAutonomousDatabases(req));
  }

  /**
   * Gets a list of supported Autonomous Database versions. Note that preview version software is only available for
   * databases with [shared Exadata infrastructure](https://docs.cloud.oracle.com/Content/Database/Concepts/adboverview.htm#AEI).
   *
   * @param ListAutonomousDbPreviewVersionsRequest
   * @return ListAutonomousDbPreviewVersionsResponse
   * @throws OciError when an error occurs
   */
  public async listAutonomousDbPreviewVersions(
    listAutonomousDbPreviewVersionsRequest: requests.ListAutonomousDbPreviewVersionsRequest
  ): Promise<responses.ListAutonomousDbPreviewVersionsResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listAutonomousDbPreviewVersionsRequest.compartmentId,
      "limit": listAutonomousDbPreviewVersionsRequest.limit,
      "page": listAutonomousDbPreviewVersionsRequest.page,
      "sortBy": listAutonomousDbPreviewVersionsRequest.sortBy,
      "sortOrder": listAutonomousDbPreviewVersionsRequest.sortOrder
    };

    let headerParams = {
      "opc-request-id": listAutonomousDbPreviewVersionsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/autonomousDbPreviewVersions",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListAutonomousDbPreviewVersionsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "AutonomousDbPreviewVersionSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.AutonomousDbPreviewVersionSummary objects
   * contained in responses from the listAutonomousDbPreviewVersions operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllAutonomousDbPreviewVersions(
    request: requests.ListAutonomousDbPreviewVersionsRequest
  ): AsyncIterableIterator<models.AutonomousDbPreviewVersionSummary> {
    return paginateRecords(request, req => this.listAutonomousDbPreviewVersions(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listAutonomousDbPreviewVersions operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllAutonomousDbPreviewVersionsResponses(
    request: requests.ListAutonomousDbPreviewVersionsRequest
  ): AsyncIterableIterator<responses.ListAutonomousDbPreviewVersionsResponse> {
    return paginateResponses(request, req => this.listAutonomousDbPreviewVersions(req));
  }

  /**
   * Gets a list of supported Autonomous Database versions.
   * @param ListAutonomousDbVersionsRequest
   * @return ListAutonomousDbVersionsResponse
   * @throws OciError when an error occurs
   */
  public async listAutonomousDbVersions(
    listAutonomousDbVersionsRequest: requests.ListAutonomousDbVersionsRequest
  ): Promise<responses.ListAutonomousDbVersionsResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listAutonomousDbVersionsRequest.compartmentId,
      "limit": listAutonomousDbVersionsRequest.limit,
      "page": listAutonomousDbVersionsRequest.page,
      "dbWorkload": listAutonomousDbVersionsRequest.dbWorkload,
      "sortOrder": listAutonomousDbVersionsRequest.sortOrder
    };

    let headerParams = {
      "opc-request-id": listAutonomousDbVersionsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/autonomousDbVersions",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListAutonomousDbVersionsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "AutonomousDbVersionSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.AutonomousDbVersionSummary objects
   * contained in responses from the listAutonomousDbVersions operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllAutonomousDbVersions(
    request: requests.ListAutonomousDbVersionsRequest
  ): AsyncIterableIterator<models.AutonomousDbVersionSummary> {
    return paginateRecords(request, req => this.listAutonomousDbVersions(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listAutonomousDbVersions operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllAutonomousDbVersionsResponses(
    request: requests.ListAutonomousDbVersionsRequest
  ): AsyncIterableIterator<responses.ListAutonomousDbVersionsResponse> {
    return paginateResponses(request, req => this.listAutonomousDbVersions(req));
  }

  /**
   * Gets a list of the shapes that can be used to launch a new Autonomous Exadata Infrastructure DB system. The shape determines resources to allocate to the DB system (CPU cores, memory and storage).
   * @param ListAutonomousExadataInfrastructureShapesRequest
   * @return ListAutonomousExadataInfrastructureShapesResponse
   * @throws OciError when an error occurs
   */
  public async listAutonomousExadataInfrastructureShapes(
    listAutonomousExadataInfrastructureShapesRequest: requests.ListAutonomousExadataInfrastructureShapesRequest
  ): Promise<responses.ListAutonomousExadataInfrastructureShapesResponse> {
    const pathParams = {};

    const queryParams = {
      "availabilityDomain": listAutonomousExadataInfrastructureShapesRequest.availabilityDomain,
      "compartmentId": listAutonomousExadataInfrastructureShapesRequest.compartmentId,
      "limit": listAutonomousExadataInfrastructureShapesRequest.limit,
      "page": listAutonomousExadataInfrastructureShapesRequest.page
    };

    let headerParams = {
      "opc-request-id": listAutonomousExadataInfrastructureShapesRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/autonomousExadataInfrastructureShapes",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListAutonomousExadataInfrastructureShapesResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "AutonomousExadataInfrastructureShapeSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.AutonomousExadataInfrastructureShapeSummary objects
   * contained in responses from the listAutonomousExadataInfrastructureShapes operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllAutonomousExadataInfrastructureShapes(
    request: requests.ListAutonomousExadataInfrastructureShapesRequest
  ): AsyncIterableIterator<models.AutonomousExadataInfrastructureShapeSummary> {
    return paginateRecords(request, req => this.listAutonomousExadataInfrastructureShapes(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listAutonomousExadataInfrastructureShapes operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllAutonomousExadataInfrastructureShapesResponses(
    request: requests.ListAutonomousExadataInfrastructureShapesRequest
  ): AsyncIterableIterator<responses.ListAutonomousExadataInfrastructureShapesResponse> {
    return paginateResponses(request, req => this.listAutonomousExadataInfrastructureShapes(req));
  }

  /**
   * Gets a list of the Autonomous Exadata Infrastructures in the specified compartment.
   *
   * @param ListAutonomousExadataInfrastructuresRequest
   * @return ListAutonomousExadataInfrastructuresResponse
   * @throws OciError when an error occurs
   */
  public async listAutonomousExadataInfrastructures(
    listAutonomousExadataInfrastructuresRequest: requests.ListAutonomousExadataInfrastructuresRequest
  ): Promise<responses.ListAutonomousExadataInfrastructuresResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listAutonomousExadataInfrastructuresRequest.compartmentId,
      "limit": listAutonomousExadataInfrastructuresRequest.limit,
      "page": listAutonomousExadataInfrastructuresRequest.page,
      "sortBy": listAutonomousExadataInfrastructuresRequest.sortBy,
      "sortOrder": listAutonomousExadataInfrastructuresRequest.sortOrder,
      "lifecycleState": listAutonomousExadataInfrastructuresRequest.lifecycleState,
      "availabilityDomain": listAutonomousExadataInfrastructuresRequest.availabilityDomain,
      "displayName": listAutonomousExadataInfrastructuresRequest.displayName
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/autonomousExadataInfrastructures",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListAutonomousExadataInfrastructuresResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "AutonomousExadataInfrastructureSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.AutonomousExadataInfrastructureSummary objects
   * contained in responses from the listAutonomousExadataInfrastructures operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllAutonomousExadataInfrastructures(
    request: requests.ListAutonomousExadataInfrastructuresRequest
  ): AsyncIterableIterator<models.AutonomousExadataInfrastructureSummary> {
    return paginateRecords(request, req => this.listAutonomousExadataInfrastructures(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listAutonomousExadataInfrastructures operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllAutonomousExadataInfrastructuresResponses(
    request: requests.ListAutonomousExadataInfrastructuresRequest
  ): AsyncIterableIterator<responses.ListAutonomousExadataInfrastructuresResponse> {
    return paginateResponses(request, req => this.listAutonomousExadataInfrastructures(req));
  }

  /**
   * Gets a list of backup destinations in the specified compartment.
   *
   * @param ListBackupDestinationRequest
   * @return ListBackupDestinationResponse
   * @throws OciError when an error occurs
   */
  public async listBackupDestination(
    listBackupDestinationRequest: requests.ListBackupDestinationRequest
  ): Promise<responses.ListBackupDestinationResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listBackupDestinationRequest.compartmentId,
      "limit": listBackupDestinationRequest.limit,
      "page": listBackupDestinationRequest.page,
      "type": listBackupDestinationRequest.type
    };

    let headerParams = {
      "opc-request-id": listBackupDestinationRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/backupDestinations",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListBackupDestinationResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "BackupDestinationSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.BackupDestinationSummary objects
   * contained in responses from the listBackupDestination operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllBackupDestination(
    request: requests.ListBackupDestinationRequest
  ): AsyncIterableIterator<models.BackupDestinationSummary> {
    return paginateRecords(request, req => this.listBackupDestination(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listBackupDestination operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllBackupDestinationResponses(
    request: requests.ListBackupDestinationRequest
  ): AsyncIterableIterator<responses.ListBackupDestinationResponse> {
    return paginateResponses(request, req => this.listBackupDestination(req));
  }

  /**
   * Gets a list of backups based on the databaseId or compartmentId specified. Either one of the query parameters must be provided.
   *
   * @param ListBackupsRequest
   * @return ListBackupsResponse
   * @throws OciError when an error occurs
   */
  public async listBackups(
    listBackupsRequest: requests.ListBackupsRequest
  ): Promise<responses.ListBackupsResponse> {
    const pathParams = {};

    const queryParams = {
      "databaseId": listBackupsRequest.databaseId,
      "compartmentId": listBackupsRequest.compartmentId,
      "limit": listBackupsRequest.limit,
      "page": listBackupsRequest.page
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/backups",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListBackupsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "BackupSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.BackupSummary objects
   * contained in responses from the listBackups operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllBackups(
    request: requests.ListBackupsRequest
  ): AsyncIterableIterator<models.BackupSummary> {
    return paginateRecords(request, req => this.listBackups(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listBackups operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllBackupsResponses(
    request: requests.ListBackupsRequest
  ): AsyncIterableIterator<responses.ListBackupsResponse> {
    return paginateResponses(request, req => this.listBackups(req));
  }

  /**
   * Lists all Data Guard associations for the specified database.
   *
   * @param ListDataGuardAssociationsRequest
   * @return ListDataGuardAssociationsResponse
   * @throws OciError when an error occurs
   */
  public async listDataGuardAssociations(
    listDataGuardAssociationsRequest: requests.ListDataGuardAssociationsRequest
  ): Promise<responses.ListDataGuardAssociationsResponse> {
    const pathParams = {
      "{databaseId}": listDataGuardAssociationsRequest.databaseId
    };

    const queryParams = {
      "limit": listDataGuardAssociationsRequest.limit,
      "page": listDataGuardAssociationsRequest.page
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/databases/{databaseId}/dataGuardAssociations",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListDataGuardAssociationsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "DataGuardAssociationSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.DataGuardAssociationSummary objects
   * contained in responses from the listDataGuardAssociations operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllDataGuardAssociations(
    request: requests.ListDataGuardAssociationsRequest
  ): AsyncIterableIterator<models.DataGuardAssociationSummary> {
    return paginateRecords(request, req => this.listDataGuardAssociations(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listDataGuardAssociations operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllDataGuardAssociationsResponses(
    request: requests.ListDataGuardAssociationsRequest
  ): AsyncIterableIterator<responses.ListDataGuardAssociationsResponse> {
    return paginateResponses(request, req => this.listDataGuardAssociations(req));
  }

  /**
   * Gets a list of the databases in the specified Database Home.
   *
   * @param ListDatabasesRequest
   * @return ListDatabasesResponse
   * @throws OciError when an error occurs
   */
  public async listDatabases(
    listDatabasesRequest: requests.ListDatabasesRequest
  ): Promise<responses.ListDatabasesResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listDatabasesRequest.compartmentId,
      "dbHomeId": listDatabasesRequest.dbHomeId,
      "systemId": listDatabasesRequest.systemId,
      "limit": listDatabasesRequest.limit,
      "page": listDatabasesRequest.page,
      "sortBy": listDatabasesRequest.sortBy,
      "sortOrder": listDatabasesRequest.sortOrder,
      "lifecycleState": listDatabasesRequest.lifecycleState,
      "dbName": listDatabasesRequest.dbName
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/databases",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListDatabasesResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "DatabaseSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.DatabaseSummary objects
   * contained in responses from the listDatabases operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllDatabases(
    request: requests.ListDatabasesRequest
  ): AsyncIterableIterator<models.DatabaseSummary> {
    return paginateRecords(request, req => this.listDatabases(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listDatabases operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllDatabasesResponses(
    request: requests.ListDatabasesRequest
  ): AsyncIterableIterator<responses.ListDatabasesResponse> {
    return paginateResponses(request, req => this.listDatabases(req));
  }

  /**
   * Gets history of the actions taken for patches for the specified Database Home.
   *
   * @param ListDbHomePatchHistoryEntriesRequest
   * @return ListDbHomePatchHistoryEntriesResponse
   * @throws OciError when an error occurs
   */
  public async listDbHomePatchHistoryEntries(
    listDbHomePatchHistoryEntriesRequest: requests.ListDbHomePatchHistoryEntriesRequest
  ): Promise<responses.ListDbHomePatchHistoryEntriesResponse> {
    const pathParams = {
      "{dbHomeId}": listDbHomePatchHistoryEntriesRequest.dbHomeId
    };

    const queryParams = {
      "limit": listDbHomePatchHistoryEntriesRequest.limit,
      "page": listDbHomePatchHistoryEntriesRequest.page
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/dbHomes/{dbHomeId}/patchHistoryEntries",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListDbHomePatchHistoryEntriesResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "PatchHistoryEntrySummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.PatchHistoryEntrySummary objects
   * contained in responses from the listDbHomePatchHistoryEntries operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllDbHomePatchHistoryEntries(
    request: requests.ListDbHomePatchHistoryEntriesRequest
  ): AsyncIterableIterator<models.PatchHistoryEntrySummary> {
    return paginateRecords(request, req => this.listDbHomePatchHistoryEntries(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listDbHomePatchHistoryEntries operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllDbHomePatchHistoryEntriesResponses(
    request: requests.ListDbHomePatchHistoryEntriesRequest
  ): AsyncIterableIterator<responses.ListDbHomePatchHistoryEntriesResponse> {
    return paginateResponses(request, req => this.listDbHomePatchHistoryEntries(req));
  }

  /**
   * Lists patches applicable to the requested Database Home.
   *
   * @param ListDbHomePatchesRequest
   * @return ListDbHomePatchesResponse
   * @throws OciError when an error occurs
   */
  public async listDbHomePatches(
    listDbHomePatchesRequest: requests.ListDbHomePatchesRequest
  ): Promise<responses.ListDbHomePatchesResponse> {
    const pathParams = {
      "{dbHomeId}": listDbHomePatchesRequest.dbHomeId
    };

    const queryParams = {
      "limit": listDbHomePatchesRequest.limit,
      "page": listDbHomePatchesRequest.page
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/dbHomes/{dbHomeId}/patches",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListDbHomePatchesResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "PatchSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.PatchSummary objects
   * contained in responses from the listDbHomePatches operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllDbHomePatches(
    request: requests.ListDbHomePatchesRequest
  ): AsyncIterableIterator<models.PatchSummary> {
    return paginateRecords(request, req => this.listDbHomePatches(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listDbHomePatches operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllDbHomePatchesResponses(
    request: requests.ListDbHomePatchesRequest
  ): AsyncIterableIterator<responses.ListDbHomePatchesResponse> {
    return paginateResponses(request, req => this.listDbHomePatches(req));
  }

  /**
   * Gets a list of Database Homes in the specified DB system and compartment. A Database Home is a directory where Oracle Database software is installed.
   *
   * @param ListDbHomesRequest
   * @return ListDbHomesResponse
   * @throws OciError when an error occurs
   */
  public async listDbHomes(
    listDbHomesRequest: requests.ListDbHomesRequest
  ): Promise<responses.ListDbHomesResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listDbHomesRequest.compartmentId,
      "dbSystemId": listDbHomesRequest.dbSystemId,
      "vmClusterId": listDbHomesRequest.vmClusterId,
      "backupId": listDbHomesRequest.backupId,
      "limit": listDbHomesRequest.limit,
      "page": listDbHomesRequest.page,
      "sortBy": listDbHomesRequest.sortBy,
      "sortOrder": listDbHomesRequest.sortOrder,
      "lifecycleState": listDbHomesRequest.lifecycleState,
      "displayName": listDbHomesRequest.displayName
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/dbHomes",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListDbHomesResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "DbHomeSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.DbHomeSummary objects
   * contained in responses from the listDbHomes operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllDbHomes(
    request: requests.ListDbHomesRequest
  ): AsyncIterableIterator<models.DbHomeSummary> {
    return paginateRecords(request, req => this.listDbHomes(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listDbHomes operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllDbHomesResponses(
    request: requests.ListDbHomesRequest
  ): AsyncIterableIterator<responses.ListDbHomesResponse> {
    return paginateResponses(request, req => this.listDbHomes(req));
  }

  /**
   * Gets a list of database nodes in the specified DB system and compartment. A database node is a server running database software.
   *
   * @param ListDbNodesRequest
   * @return ListDbNodesResponse
   * @throws OciError when an error occurs
   */
  public async listDbNodes(
    listDbNodesRequest: requests.ListDbNodesRequest
  ): Promise<responses.ListDbNodesResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listDbNodesRequest.compartmentId,
      "dbSystemId": listDbNodesRequest.dbSystemId,
      "vmClusterId": listDbNodesRequest.vmClusterId,
      "limit": listDbNodesRequest.limit,
      "page": listDbNodesRequest.page,
      "sortBy": listDbNodesRequest.sortBy,
      "sortOrder": listDbNodesRequest.sortOrder,
      "lifecycleState": listDbNodesRequest.lifecycleState
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/dbNodes",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListDbNodesResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "DbNodeSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.DbNodeSummary objects
   * contained in responses from the listDbNodes operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllDbNodes(
    request: requests.ListDbNodesRequest
  ): AsyncIterableIterator<models.DbNodeSummary> {
    return paginateRecords(request, req => this.listDbNodes(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listDbNodes operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllDbNodesResponses(
    request: requests.ListDbNodesRequest
  ): AsyncIterableIterator<responses.ListDbNodesResponse> {
    return paginateResponses(request, req => this.listDbNodes(req));
  }

  /**
   * Gets the history of the patch actions performed on the specified DB system.
   *
   * @param ListDbSystemPatchHistoryEntriesRequest
   * @return ListDbSystemPatchHistoryEntriesResponse
   * @throws OciError when an error occurs
   */
  public async listDbSystemPatchHistoryEntries(
    listDbSystemPatchHistoryEntriesRequest: requests.ListDbSystemPatchHistoryEntriesRequest
  ): Promise<responses.ListDbSystemPatchHistoryEntriesResponse> {
    const pathParams = {
      "{dbSystemId}": listDbSystemPatchHistoryEntriesRequest.dbSystemId
    };

    const queryParams = {
      "limit": listDbSystemPatchHistoryEntriesRequest.limit,
      "page": listDbSystemPatchHistoryEntriesRequest.page
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/dbSystems/{dbSystemId}/patchHistoryEntries",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListDbSystemPatchHistoryEntriesResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "PatchHistoryEntrySummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.PatchHistoryEntrySummary objects
   * contained in responses from the listDbSystemPatchHistoryEntries operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllDbSystemPatchHistoryEntries(
    request: requests.ListDbSystemPatchHistoryEntriesRequest
  ): AsyncIterableIterator<models.PatchHistoryEntrySummary> {
    return paginateRecords(request, req => this.listDbSystemPatchHistoryEntries(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listDbSystemPatchHistoryEntries operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllDbSystemPatchHistoryEntriesResponses(
    request: requests.ListDbSystemPatchHistoryEntriesRequest
  ): AsyncIterableIterator<responses.ListDbSystemPatchHistoryEntriesResponse> {
    return paginateResponses(request, req => this.listDbSystemPatchHistoryEntries(req));
  }

  /**
   * Lists the patches applicable to the requested DB system.
   *
   * @param ListDbSystemPatchesRequest
   * @return ListDbSystemPatchesResponse
   * @throws OciError when an error occurs
   */
  public async listDbSystemPatches(
    listDbSystemPatchesRequest: requests.ListDbSystemPatchesRequest
  ): Promise<responses.ListDbSystemPatchesResponse> {
    const pathParams = {
      "{dbSystemId}": listDbSystemPatchesRequest.dbSystemId
    };

    const queryParams = {
      "limit": listDbSystemPatchesRequest.limit,
      "page": listDbSystemPatchesRequest.page
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/dbSystems/{dbSystemId}/patches",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListDbSystemPatchesResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "PatchSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.PatchSummary objects
   * contained in responses from the listDbSystemPatches operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllDbSystemPatches(
    request: requests.ListDbSystemPatchesRequest
  ): AsyncIterableIterator<models.PatchSummary> {
    return paginateRecords(request, req => this.listDbSystemPatches(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listDbSystemPatches operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllDbSystemPatchesResponses(
    request: requests.ListDbSystemPatchesRequest
  ): AsyncIterableIterator<responses.ListDbSystemPatchesResponse> {
    return paginateResponses(request, req => this.listDbSystemPatches(req));
  }

  /**
   * Gets a list of the shapes that can be used to launch a new DB system. The shape determines resources to allocate to the DB system - CPU cores and memory for VM shapes; CPU cores, memory and storage for non-VM (or bare metal) shapes.
   * @param ListDbSystemShapesRequest
   * @return ListDbSystemShapesResponse
   * @throws OciError when an error occurs
   */
  public async listDbSystemShapes(
    listDbSystemShapesRequest: requests.ListDbSystemShapesRequest
  ): Promise<responses.ListDbSystemShapesResponse> {
    const pathParams = {};

    const queryParams = {
      "availabilityDomain": listDbSystemShapesRequest.availabilityDomain,
      "compartmentId": listDbSystemShapesRequest.compartmentId,
      "limit": listDbSystemShapesRequest.limit,
      "page": listDbSystemShapesRequest.page
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/dbSystemShapes",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListDbSystemShapesResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "DbSystemShapeSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.DbSystemShapeSummary objects
   * contained in responses from the listDbSystemShapes operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllDbSystemShapes(
    request: requests.ListDbSystemShapesRequest
  ): AsyncIterableIterator<models.DbSystemShapeSummary> {
    return paginateRecords(request, req => this.listDbSystemShapes(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listDbSystemShapes operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllDbSystemShapesResponses(
    request: requests.ListDbSystemShapesRequest
  ): AsyncIterableIterator<responses.ListDbSystemShapesResponse> {
    return paginateResponses(request, req => this.listDbSystemShapes(req));
  }

  /**
   * Gets a list of the DB systems in the specified compartment. You can specify a backupId to list only the DB systems that support creating a database using this backup in this compartment.
   *
   *
   * @param ListDbSystemsRequest
   * @return ListDbSystemsResponse
   * @throws OciError when an error occurs
   */
  public async listDbSystems(
    listDbSystemsRequest: requests.ListDbSystemsRequest
  ): Promise<responses.ListDbSystemsResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listDbSystemsRequest.compartmentId,
      "limit": listDbSystemsRequest.limit,
      "page": listDbSystemsRequest.page,
      "backupId": listDbSystemsRequest.backupId,
      "sortBy": listDbSystemsRequest.sortBy,
      "sortOrder": listDbSystemsRequest.sortOrder,
      "lifecycleState": listDbSystemsRequest.lifecycleState,
      "availabilityDomain": listDbSystemsRequest.availabilityDomain,
      "displayName": listDbSystemsRequest.displayName
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/dbSystems",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListDbSystemsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "DbSystemSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.DbSystemSummary objects
   * contained in responses from the listDbSystems operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllDbSystems(
    request: requests.ListDbSystemsRequest
  ): AsyncIterableIterator<models.DbSystemSummary> {
    return paginateRecords(request, req => this.listDbSystems(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listDbSystems operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllDbSystemsResponses(
    request: requests.ListDbSystemsRequest
  ): AsyncIterableIterator<responses.ListDbSystemsResponse> {
    return paginateResponses(request, req => this.listDbSystems(req));
  }

  /**
   * Gets a list of supported Oracle Database versions.
   * @param ListDbVersionsRequest
   * @return ListDbVersionsResponse
   * @throws OciError when an error occurs
   */
  public async listDbVersions(
    listDbVersionsRequest: requests.ListDbVersionsRequest
  ): Promise<responses.ListDbVersionsResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listDbVersionsRequest.compartmentId,
      "limit": listDbVersionsRequest.limit,
      "page": listDbVersionsRequest.page,
      "dbSystemShape": listDbVersionsRequest.dbSystemShape,
      "dbSystemId": listDbVersionsRequest.dbSystemId,
      "storageManagement": listDbVersionsRequest.storageManagement
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/dbVersions",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListDbVersionsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "DbVersionSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.DbVersionSummary objects
   * contained in responses from the listDbVersions operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllDbVersions(
    request: requests.ListDbVersionsRequest
  ): AsyncIterableIterator<models.DbVersionSummary> {
    return paginateRecords(request, req => this.listDbVersions(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listDbVersions operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllDbVersionsResponses(
    request: requests.ListDbVersionsRequest
  ): AsyncIterableIterator<responses.ListDbVersionsResponse> {
    return paginateResponses(request, req => this.listDbVersions(req));
  }

  /**
   * Gets a list of the Exadata infrastructure in the specified compartment.
   *
   * @param ListExadataInfrastructuresRequest
   * @return ListExadataInfrastructuresResponse
   * @throws OciError when an error occurs
   */
  public async listExadataInfrastructures(
    listExadataInfrastructuresRequest: requests.ListExadataInfrastructuresRequest
  ): Promise<responses.ListExadataInfrastructuresResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listExadataInfrastructuresRequest.compartmentId,
      "limit": listExadataInfrastructuresRequest.limit,
      "page": listExadataInfrastructuresRequest.page,
      "sortBy": listExadataInfrastructuresRequest.sortBy,
      "sortOrder": listExadataInfrastructuresRequest.sortOrder,
      "lifecycleState": listExadataInfrastructuresRequest.lifecycleState,
      "displayName": listExadataInfrastructuresRequest.displayName
    };

    let headerParams = {
      "opc-request-id": listExadataInfrastructuresRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/exadataInfrastructures",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListExadataInfrastructuresResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "ExadataInfrastructureSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.ExadataInfrastructureSummary objects
   * contained in responses from the listExadataInfrastructures operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllExadataInfrastructures(
    request: requests.ListExadataInfrastructuresRequest
  ): AsyncIterableIterator<models.ExadataInfrastructureSummary> {
    return paginateRecords(request, req => this.listExadataInfrastructures(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listExadataInfrastructures operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllExadataInfrastructuresResponses(
    request: requests.ListExadataInfrastructuresRequest
  ): AsyncIterableIterator<responses.ListExadataInfrastructuresResponse> {
    return paginateResponses(request, req => this.listExadataInfrastructures(req));
  }

  /**
   * Gets a list of supported GI versions for VM Cluster.
   * @param ListGiVersionsRequest
   * @return ListGiVersionsResponse
   * @throws OciError when an error occurs
   */
  public async listGiVersions(
    listGiVersionsRequest: requests.ListGiVersionsRequest
  ): Promise<responses.ListGiVersionsResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listGiVersionsRequest.compartmentId,
      "limit": listGiVersionsRequest.limit,
      "page": listGiVersionsRequest.page,
      "sortOrder": listGiVersionsRequest.sortOrder,
      "shape": listGiVersionsRequest.shape
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/giVersions",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListGiVersionsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "GiVersionSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.GiVersionSummary objects
   * contained in responses from the listGiVersions operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllGiVersions(
    request: requests.ListGiVersionsRequest
  ): AsyncIterableIterator<models.GiVersionSummary> {
    return paginateRecords(request, req => this.listGiVersions(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listGiVersions operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllGiVersionsResponses(
    request: requests.ListGiVersionsRequest
  ): AsyncIterableIterator<responses.ListGiVersionsResponse> {
    return paginateResponses(request, req => this.listGiVersions(req));
  }

  /**
   * Gets a list of the Maintenance Runs in the specified compartment.
   *
   * @param ListMaintenanceRunsRequest
   * @return ListMaintenanceRunsResponse
   * @throws OciError when an error occurs
   */
  public async listMaintenanceRuns(
    listMaintenanceRunsRequest: requests.ListMaintenanceRunsRequest
  ): Promise<responses.ListMaintenanceRunsResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listMaintenanceRunsRequest.compartmentId,
      "targetResourceId": listMaintenanceRunsRequest.targetResourceId,
      "targetResourceType": listMaintenanceRunsRequest.targetResourceType,
      "maintenanceType": listMaintenanceRunsRequest.maintenanceType,
      "limit": listMaintenanceRunsRequest.limit,
      "page": listMaintenanceRunsRequest.page,
      "sortBy": listMaintenanceRunsRequest.sortBy,
      "sortOrder": listMaintenanceRunsRequest.sortOrder,
      "lifecycleState": listMaintenanceRunsRequest.lifecycleState,
      "availabilityDomain": listMaintenanceRunsRequest.availabilityDomain
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/maintenanceRuns",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListMaintenanceRunsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "MaintenanceRunSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.MaintenanceRunSummary objects
   * contained in responses from the listMaintenanceRuns operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllMaintenanceRuns(
    request: requests.ListMaintenanceRunsRequest
  ): AsyncIterableIterator<models.MaintenanceRunSummary> {
    return paginateRecords(request, req => this.listMaintenanceRuns(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listMaintenanceRuns operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllMaintenanceRunsResponses(
    request: requests.ListMaintenanceRunsRequest
  ): AsyncIterableIterator<responses.ListMaintenanceRunsResponse> {
    return paginateResponses(request, req => this.listMaintenanceRuns(req));
  }

  /**
   * Gets a list of the VM cluster networks in the specified compartment.
   *
   * @param ListVmClusterNetworksRequest
   * @return ListVmClusterNetworksResponse
   * @throws OciError when an error occurs
   */
  public async listVmClusterNetworks(
    listVmClusterNetworksRequest: requests.ListVmClusterNetworksRequest
  ): Promise<responses.ListVmClusterNetworksResponse> {
    const pathParams = {
      "{exadataInfrastructureId}": listVmClusterNetworksRequest.exadataInfrastructureId
    };

    const queryParams = {
      "compartmentId": listVmClusterNetworksRequest.compartmentId,
      "limit": listVmClusterNetworksRequest.limit,
      "page": listVmClusterNetworksRequest.page,
      "sortBy": listVmClusterNetworksRequest.sortBy,
      "sortOrder": listVmClusterNetworksRequest.sortOrder,
      "lifecycleState": listVmClusterNetworksRequest.lifecycleState,
      "displayName": listVmClusterNetworksRequest.displayName
    };

    let headerParams = {
      "opc-request-id": listVmClusterNetworksRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/exadataInfrastructures/{exadataInfrastructureId}/vmClusterNetworks",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListVmClusterNetworksResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "VmClusterNetworkSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.VmClusterNetworkSummary objects
   * contained in responses from the listVmClusterNetworks operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllVmClusterNetworks(
    request: requests.ListVmClusterNetworksRequest
  ): AsyncIterableIterator<models.VmClusterNetworkSummary> {
    return paginateRecords(request, req => this.listVmClusterNetworks(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listVmClusterNetworks operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllVmClusterNetworksResponses(
    request: requests.ListVmClusterNetworksRequest
  ): AsyncIterableIterator<responses.ListVmClusterNetworksResponse> {
    return paginateResponses(request, req => this.listVmClusterNetworks(req));
  }

  /**
   * Gets a list of the VM clusters in the specified compartment.
   *
   * @param ListVmClustersRequest
   * @return ListVmClustersResponse
   * @throws OciError when an error occurs
   */
  public async listVmClusters(
    listVmClustersRequest: requests.ListVmClustersRequest
  ): Promise<responses.ListVmClustersResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listVmClustersRequest.compartmentId,
      "exadataInfrastructureId": listVmClustersRequest.exadataInfrastructureId,
      "limit": listVmClustersRequest.limit,
      "page": listVmClustersRequest.page,
      "sortBy": listVmClustersRequest.sortBy,
      "sortOrder": listVmClustersRequest.sortOrder,
      "lifecycleState": listVmClustersRequest.lifecycleState,
      "displayName": listVmClustersRequest.displayName
    };

    let headerParams = {
      "opc-request-id": listVmClustersRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/vmClusters",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListVmClustersResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "VmClusterSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.VmClusterSummary objects
   * contained in responses from the listVmClusters operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllVmClusters(
    request: requests.ListVmClustersRequest
  ): AsyncIterableIterator<models.VmClusterSummary> {
    return paginateRecords(request, req => this.listVmClusters(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listVmClusters operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllVmClustersResponses(
    request: requests.ListVmClustersRequest
  ): AsyncIterableIterator<responses.ListVmClustersResponse> {
    return paginateResponses(request, req => this.listVmClusters(req));
  }

  /**
   * Asynchronously registers this Autonomous Database with Data Safe.
   *
   * @param RegisterAutonomousDatabaseDataSafeRequest
   * @return RegisterAutonomousDatabaseDataSafeResponse
   * @throws OciError when an error occurs
   */
  public async registerAutonomousDatabaseDataSafe(
    registerAutonomousDatabaseDataSafeRequest: requests.RegisterAutonomousDatabaseDataSafeRequest
  ): Promise<responses.RegisterAutonomousDatabaseDataSafeResponse> {
    const pathParams = {
      "{autonomousDatabaseId}": registerAutonomousDatabaseDataSafeRequest.autonomousDatabaseId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": registerAutonomousDatabaseDataSafeRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/autonomousDatabases/{autonomousDatabaseId}/actions/registerDataSafe",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.RegisterAutonomousDatabaseDataSafeResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Reinstates the database identified by the `databaseId` parameter into the standby role in a Data Guard association.
   *
   * @param ReinstateDataGuardAssociationRequest
   * @return ReinstateDataGuardAssociationResponse
   * @throws OciError when an error occurs
   */
  public async reinstateDataGuardAssociation(
    reinstateDataGuardAssociationRequest: requests.ReinstateDataGuardAssociationRequest
  ): Promise<responses.ReinstateDataGuardAssociationResponse> {
    const pathParams = {
      "{databaseId}": reinstateDataGuardAssociationRequest.databaseId,
      "{dataGuardAssociationId}": reinstateDataGuardAssociationRequest.dataGuardAssociationId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": reinstateDataGuardAssociationRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path:
        "/databases/{databaseId}/dataGuardAssociations/{dataGuardAssociationId}/actions/reinstate",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        reinstateDataGuardAssociationRequest.reinstateDataGuardAssociationDetails,
        "ReinstateDataGuardAssociationDetails",
        models.ReinstateDataGuardAssociationDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ReinstateDataGuardAssociationResponse>{},
        body: await response.json(),
        bodyKey: "dataGuardAssociation",
        bodyModel: "model.DataGuardAssociation",
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Rolling restarts the specified Autonomous Container Database.
   *
   * @param RestartAutonomousContainerDatabaseRequest
   * @return RestartAutonomousContainerDatabaseResponse
   * @throws OciError when an error occurs
   */
  public async restartAutonomousContainerDatabase(
    restartAutonomousContainerDatabaseRequest: requests.RestartAutonomousContainerDatabaseRequest
  ): Promise<responses.RestartAutonomousContainerDatabaseResponse> {
    const pathParams = {
      "{autonomousContainerDatabaseId}":
        restartAutonomousContainerDatabaseRequest.autonomousContainerDatabaseId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": restartAutonomousContainerDatabaseRequest.ifMatch,
      "opc-request-id": restartAutonomousContainerDatabaseRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/autonomousContainerDatabases/{autonomousContainerDatabaseId}/actions/restart",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.RestartAutonomousContainerDatabaseResponse>{},
        body: await response.json(),
        bodyKey: "autonomousContainerDatabase",
        bodyModel: "model.AutonomousContainerDatabase",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Restarts the specified Autonomous Database. Restart supported only for databases using dedicated Exadata infrastructure.
   *
   * @param RestartAutonomousDatabaseRequest
   * @return RestartAutonomousDatabaseResponse
   * @throws OciError when an error occurs
   */
  public async restartAutonomousDatabase(
    restartAutonomousDatabaseRequest: requests.RestartAutonomousDatabaseRequest
  ): Promise<responses.RestartAutonomousDatabaseResponse> {
    const pathParams = {
      "{autonomousDatabaseId}": restartAutonomousDatabaseRequest.autonomousDatabaseId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": restartAutonomousDatabaseRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/autonomousDatabases/{autonomousDatabaseId}/actions/restart",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.RestartAutonomousDatabaseResponse>{},
        body: await response.json(),
        bodyKey: "autonomousDatabase",
        bodyModel: "model.AutonomousDatabase",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * **Deprecated.** To restore an Autonomous Data Warehouse, use the {@link #restoreAutonomousDatabase(RestoreAutonomousDatabaseRequest) restoreAutonomousDatabase} operation.
   *
   * @param RestoreAutonomousDataWarehouseRequest
   * @return RestoreAutonomousDataWarehouseResponse
   * @throws OciError when an error occurs
   */
  public async restoreAutonomousDataWarehouse(
    restoreAutonomousDataWarehouseRequest: requests.RestoreAutonomousDataWarehouseRequest
  ): Promise<responses.RestoreAutonomousDataWarehouseResponse> {
    const pathParams = {
      "{autonomousDataWarehouseId}": restoreAutonomousDataWarehouseRequest.autonomousDataWarehouseId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": restoreAutonomousDataWarehouseRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/autonomousDataWarehouses/{autonomousDataWarehouseId}/actions/restore",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        restoreAutonomousDataWarehouseRequest.restoreAutonomousDataWarehouseDetails,
        "RestoreAutonomousDataWarehouseDetails",
        models.RestoreAutonomousDataWarehouseDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.RestoreAutonomousDataWarehouseResponse>{},
        body: await response.json(),
        bodyKey: "autonomousDataWarehouse",
        bodyModel: "model.AutonomousDataWarehouse",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Restores an Autonomous Database based on the provided request parameters.
   *
   * @param RestoreAutonomousDatabaseRequest
   * @return RestoreAutonomousDatabaseResponse
   * @throws OciError when an error occurs
   */
  public async restoreAutonomousDatabase(
    restoreAutonomousDatabaseRequest: requests.RestoreAutonomousDatabaseRequest
  ): Promise<responses.RestoreAutonomousDatabaseResponse> {
    const pathParams = {
      "{autonomousDatabaseId}": restoreAutonomousDatabaseRequest.autonomousDatabaseId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": restoreAutonomousDatabaseRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/autonomousDatabases/{autonomousDatabaseId}/actions/restore",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        restoreAutonomousDatabaseRequest.restoreAutonomousDatabaseDetails,
        "RestoreAutonomousDatabaseDetails",
        models.RestoreAutonomousDatabaseDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.RestoreAutonomousDatabaseResponse>{},
        body: await response.json(),
        bodyKey: "autonomousDatabase",
        bodyModel: "model.AutonomousDatabase",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Restore a Database based on the request parameters you provide.
   *
   * @param RestoreDatabaseRequest
   * @return RestoreDatabaseResponse
   * @throws OciError when an error occurs
   */
  public async restoreDatabase(
    restoreDatabaseRequest: requests.RestoreDatabaseRequest
  ): Promise<responses.RestoreDatabaseResponse> {
    const pathParams = {
      "{databaseId}": restoreDatabaseRequest.databaseId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": restoreDatabaseRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/databases/{databaseId}/actions/restore",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        restoreDatabaseRequest.restoreDatabaseDetails,
        "RestoreDatabaseDetails",
        models.RestoreDatabaseDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.RestoreDatabaseResponse>{},
        body: await response.json(),
        bodyKey: "database",
        bodyModel: "model.Database",
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * **Deprecated.** To start an Autonomous Data Warehouse, use the {@link #startAutonomousDatabase(StartAutonomousDatabaseRequest) startAutonomousDatabase} operation.
   *
   * @param StartAutonomousDataWarehouseRequest
   * @return StartAutonomousDataWarehouseResponse
   * @throws OciError when an error occurs
   */
  public async startAutonomousDataWarehouse(
    startAutonomousDataWarehouseRequest: requests.StartAutonomousDataWarehouseRequest
  ): Promise<responses.StartAutonomousDataWarehouseResponse> {
    const pathParams = {
      "{autonomousDataWarehouseId}": startAutonomousDataWarehouseRequest.autonomousDataWarehouseId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": startAutonomousDataWarehouseRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/autonomousDataWarehouses/{autonomousDataWarehouseId}/actions/start",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.StartAutonomousDataWarehouseResponse>{},
        body: await response.json(),
        bodyKey: "autonomousDataWarehouse",
        bodyModel: "model.AutonomousDataWarehouse",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Starts the specified Autonomous Database.
   *
   * @param StartAutonomousDatabaseRequest
   * @return StartAutonomousDatabaseResponse
   * @throws OciError when an error occurs
   */
  public async startAutonomousDatabase(
    startAutonomousDatabaseRequest: requests.StartAutonomousDatabaseRequest
  ): Promise<responses.StartAutonomousDatabaseResponse> {
    const pathParams = {
      "{autonomousDatabaseId}": startAutonomousDatabaseRequest.autonomousDatabaseId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": startAutonomousDatabaseRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/autonomousDatabases/{autonomousDatabaseId}/actions/start",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.StartAutonomousDatabaseResponse>{},
        body: await response.json(),
        bodyKey: "autonomousDatabase",
        bodyModel: "model.AutonomousDatabase",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * **Deprecated.** To stop an Autonomous Data Warehouse, use the {@link #stopAutonomousDatabase(StopAutonomousDatabaseRequest) stopAutonomousDatabase} operation.
   *
   * @param StopAutonomousDataWarehouseRequest
   * @return StopAutonomousDataWarehouseResponse
   * @throws OciError when an error occurs
   */
  public async stopAutonomousDataWarehouse(
    stopAutonomousDataWarehouseRequest: requests.StopAutonomousDataWarehouseRequest
  ): Promise<responses.StopAutonomousDataWarehouseResponse> {
    const pathParams = {
      "{autonomousDataWarehouseId}": stopAutonomousDataWarehouseRequest.autonomousDataWarehouseId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": stopAutonomousDataWarehouseRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/autonomousDataWarehouses/{autonomousDataWarehouseId}/actions/stop",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.StopAutonomousDataWarehouseResponse>{},
        body: await response.json(),
        bodyKey: "autonomousDataWarehouse",
        bodyModel: "model.AutonomousDataWarehouse",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Stops the specified Autonomous Database.
   *
   * @param StopAutonomousDatabaseRequest
   * @return StopAutonomousDatabaseResponse
   * @throws OciError when an error occurs
   */
  public async stopAutonomousDatabase(
    stopAutonomousDatabaseRequest: requests.StopAutonomousDatabaseRequest
  ): Promise<responses.StopAutonomousDatabaseResponse> {
    const pathParams = {
      "{autonomousDatabaseId}": stopAutonomousDatabaseRequest.autonomousDatabaseId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": stopAutonomousDatabaseRequest.ifMatch,
      "opc-request-id": stopAutonomousDatabaseRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/autonomousDatabases/{autonomousDatabaseId}/actions/stop",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.StopAutonomousDatabaseResponse>{},
        body: await response.json(),
        bodyKey: "autonomousDatabase",
        bodyModel: "model.AutonomousDatabase",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Performs a switchover to transition the primary database of a Data Guard association into a standby role. The
* standby database associated with the `dataGuardAssociationId` assumes the primary database role.
* <p>
A switchover guarantees no data loss.
* 
     * @param SwitchoverDataGuardAssociationRequest
     * @return SwitchoverDataGuardAssociationResponse
     * @throws OciError when an error occurs
     */
  public async switchoverDataGuardAssociation(
    switchoverDataGuardAssociationRequest: requests.SwitchoverDataGuardAssociationRequest
  ): Promise<responses.SwitchoverDataGuardAssociationResponse> {
    const pathParams = {
      "{databaseId}": switchoverDataGuardAssociationRequest.databaseId,
      "{dataGuardAssociationId}": switchoverDataGuardAssociationRequest.dataGuardAssociationId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": switchoverDataGuardAssociationRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path:
        "/databases/{databaseId}/dataGuardAssociations/{dataGuardAssociationId}/actions/switchover",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        switchoverDataGuardAssociationRequest.switchoverDataGuardAssociationDetails,
        "SwitchoverDataGuardAssociationDetails",
        models.SwitchoverDataGuardAssociationDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.SwitchoverDataGuardAssociationResponse>{},
        body: await response.json(),
        bodyKey: "dataGuardAssociation",
        bodyModel: "model.DataGuardAssociation",
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Terminates an Autonomous Container Database, which permanently deletes the container database and any databases within the container database. The database data is local to the Autonomous Exadata Infrastructure and will be lost when the container database is terminated. Oracle recommends that you back up any data in the Autonomous Container Database prior to terminating it.
   * @param TerminateAutonomousContainerDatabaseRequest
   * @return TerminateAutonomousContainerDatabaseResponse
   * @throws OciError when an error occurs
   */
  public async terminateAutonomousContainerDatabase(
    terminateAutonomousContainerDatabaseRequest: requests.TerminateAutonomousContainerDatabaseRequest
  ): Promise<responses.TerminateAutonomousContainerDatabaseResponse> {
    const pathParams = {
      "{autonomousContainerDatabaseId}":
        terminateAutonomousContainerDatabaseRequest.autonomousContainerDatabaseId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": terminateAutonomousContainerDatabaseRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/autonomousContainerDatabases/{autonomousContainerDatabaseId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.TerminateAutonomousContainerDatabaseResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Terminates an Autonomous Exadata Infrastructure, which permanently deletes the Exadata Infrastructure and any container databases and databases contained in the Exadata Infrastructure. The database data is local to the Autonomous Exadata Infrastructure and will be lost when the system is terminated. Oracle recommends that you back up any data in the Autonomous Exadata Infrastructure prior to terminating it.
   * @param TerminateAutonomousExadataInfrastructureRequest
   * @return TerminateAutonomousExadataInfrastructureResponse
   * @throws OciError when an error occurs
   */
  public async terminateAutonomousExadataInfrastructure(
    terminateAutonomousExadataInfrastructureRequest: requests.TerminateAutonomousExadataInfrastructureRequest
  ): Promise<responses.TerminateAutonomousExadataInfrastructureResponse> {
    const pathParams = {
      "{autonomousExadataInfrastructureId}":
        terminateAutonomousExadataInfrastructureRequest.autonomousExadataInfrastructureId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": terminateAutonomousExadataInfrastructureRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/autonomousExadataInfrastructures/{autonomousExadataInfrastructureId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.TerminateAutonomousExadataInfrastructureResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Terminates a DB system and permanently deletes it and any databases running on it, and any storage volumes attached to it. The database data is local to the DB system and will be lost when the system is terminated. Oracle recommends that you back up any data in the DB system prior to terminating it.
   * @param TerminateDbSystemRequest
   * @return TerminateDbSystemResponse
   * @throws OciError when an error occurs
   */
  public async terminateDbSystem(
    terminateDbSystemRequest: requests.TerminateDbSystemRequest
  ): Promise<responses.TerminateDbSystemResponse> {
    const pathParams = {
      "{dbSystemId}": terminateDbSystemRequest.dbSystemId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": terminateDbSystemRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/dbSystems/{dbSystemId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.TerminateDbSystemResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates the properties of an Autonomous Container Database, such as the OCPU core count and storage size.
   * @param UpdateAutonomousContainerDatabaseRequest
   * @return UpdateAutonomousContainerDatabaseResponse
   * @throws OciError when an error occurs
   */
  public async updateAutonomousContainerDatabase(
    updateAutonomousContainerDatabaseRequest: requests.UpdateAutonomousContainerDatabaseRequest
  ): Promise<responses.UpdateAutonomousContainerDatabaseResponse> {
    const pathParams = {
      "{autonomousContainerDatabaseId}":
        updateAutonomousContainerDatabaseRequest.autonomousContainerDatabaseId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateAutonomousContainerDatabaseRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/autonomousContainerDatabases/{autonomousContainerDatabaseId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateAutonomousContainerDatabaseRequest.updateAutonomousContainerDatabaseDetails,
        "UpdateAutonomousContainerDatabaseDetails",
        models.UpdateAutonomousContainerDatabaseDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateAutonomousContainerDatabaseResponse>{},
        body: await response.json(),
        bodyKey: "autonomousContainerDatabase",
        bodyModel: "model.AutonomousContainerDatabase",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * **Deprecated.** To update the CPU core count and storage size of an Autonomous Data Warehouse, use the {@link #updateAutonomousDatabase(UpdateAutonomousDatabaseRequest) updateAutonomousDatabase} operation.
   *
   * @param UpdateAutonomousDataWarehouseRequest
   * @return UpdateAutonomousDataWarehouseResponse
   * @throws OciError when an error occurs
   */
  public async updateAutonomousDataWarehouse(
    updateAutonomousDataWarehouseRequest: requests.UpdateAutonomousDataWarehouseRequest
  ): Promise<responses.UpdateAutonomousDataWarehouseResponse> {
    const pathParams = {
      "{autonomousDataWarehouseId}": updateAutonomousDataWarehouseRequest.autonomousDataWarehouseId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateAutonomousDataWarehouseRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/autonomousDataWarehouses/{autonomousDataWarehouseId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateAutonomousDataWarehouseRequest.updateAutonomousDataWarehouseDetails,
        "UpdateAutonomousDataWarehouseDetails",
        models.UpdateAutonomousDataWarehouseDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateAutonomousDataWarehouseResponse>{},
        body: await response.json(),
        bodyKey: "autonomousDataWarehouse",
        bodyModel: "model.AutonomousDataWarehouse",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates one or more attributes of the specified Autonomous Database. See the UpdateAutonomousDatabaseDetails resource for a full list of attributes that can be updated.
   *
   * @param UpdateAutonomousDatabaseRequest
   * @return UpdateAutonomousDatabaseResponse
   * @throws OciError when an error occurs
   */
  public async updateAutonomousDatabase(
    updateAutonomousDatabaseRequest: requests.UpdateAutonomousDatabaseRequest
  ): Promise<responses.UpdateAutonomousDatabaseResponse> {
    const pathParams = {
      "{autonomousDatabaseId}": updateAutonomousDatabaseRequest.autonomousDatabaseId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateAutonomousDatabaseRequest.ifMatch,
      "opc-request-id": updateAutonomousDatabaseRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/autonomousDatabases/{autonomousDatabaseId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateAutonomousDatabaseRequest.updateAutonomousDatabaseDetails,
        "UpdateAutonomousDatabaseDetails",
        models.UpdateAutonomousDatabaseDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateAutonomousDatabaseResponse>{},
        body: await response.json(),
        bodyKey: "autonomousDatabase",
        bodyModel: "model.AutonomousDatabase",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates the Autonomous Database regional wallet.
   *
   * @param UpdateAutonomousDatabaseRegionalWalletRequest
   * @return UpdateAutonomousDatabaseRegionalWalletResponse
   * @throws OciError when an error occurs
   */
  public async updateAutonomousDatabaseRegionalWallet(
    updateAutonomousDatabaseRegionalWalletRequest: requests.UpdateAutonomousDatabaseRegionalWalletRequest
  ): Promise<responses.UpdateAutonomousDatabaseRegionalWalletResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-request-id": updateAutonomousDatabaseRegionalWalletRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/autonomousDatabases/wallet",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateAutonomousDatabaseRegionalWalletRequest.updateAutonomousDatabaseWalletDetails,
        "UpdateAutonomousDatabaseWalletDetails",
        models.UpdateAutonomousDatabaseWalletDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateAutonomousDatabaseRegionalWalletResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates the wallet for the specified Autonomous Database.
   *
   * @param UpdateAutonomousDatabaseWalletRequest
   * @return UpdateAutonomousDatabaseWalletResponse
   * @throws OciError when an error occurs
   */
  public async updateAutonomousDatabaseWallet(
    updateAutonomousDatabaseWalletRequest: requests.UpdateAutonomousDatabaseWalletRequest
  ): Promise<responses.UpdateAutonomousDatabaseWalletResponse> {
    const pathParams = {
      "{autonomousDatabaseId}": updateAutonomousDatabaseWalletRequest.autonomousDatabaseId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": updateAutonomousDatabaseWalletRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/autonomousDatabases/{autonomousDatabaseId}/wallet",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateAutonomousDatabaseWalletRequest.updateAutonomousDatabaseWalletDetails,
        "UpdateAutonomousDatabaseWalletDetails",
        models.UpdateAutonomousDatabaseWalletDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateAutonomousDatabaseWalletResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates the properties of an Autonomous Exadata Infrastructure, such as the CPU core count.
   * @param UpdateAutonomousExadataInfrastructureRequest
   * @return UpdateAutonomousExadataInfrastructureResponse
   * @throws OciError when an error occurs
   */
  public async updateAutonomousExadataInfrastructure(
    updateAutonomousExadataInfrastructureRequest: requests.UpdateAutonomousExadataInfrastructureRequest
  ): Promise<responses.UpdateAutonomousExadataInfrastructureResponse> {
    const pathParams = {
      "{autonomousExadataInfrastructureId}":
        updateAutonomousExadataInfrastructureRequest.autonomousExadataInfrastructureId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateAutonomousExadataInfrastructureRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/autonomousExadataInfrastructures/{autonomousExadataInfrastructureId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateAutonomousExadataInfrastructureRequest.updateAutonomousExadataInfrastructuresDetails,
        "UpdateAutonomousExadataInfrastructureDetails",
        models.UpdateAutonomousExadataInfrastructureDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateAutonomousExadataInfrastructureResponse>{},
        body: await response.json(),
        bodyKey: "autonomousExadataInfrastructure",
        bodyModel: "model.AutonomousExadataInfrastructure",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * If no database is associated with the backup destination:
   * - For a RECOVERY_APPLIANCE backup destination, updates the connection string and/or the list of VPC users.
   * - For an NFS backup destination, updates the NFS location.
   *
   * @param UpdateBackupDestinationRequest
   * @return UpdateBackupDestinationResponse
   * @throws OciError when an error occurs
   */
  public async updateBackupDestination(
    updateBackupDestinationRequest: requests.UpdateBackupDestinationRequest
  ): Promise<responses.UpdateBackupDestinationResponse> {
    const pathParams = {
      "{backupDestinationId}": updateBackupDestinationRequest.backupDestinationId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateBackupDestinationRequest.ifMatch,
      "opc-request-id": updateBackupDestinationRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/backupDestinations/{backupDestinationId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateBackupDestinationRequest.updateBackupDestinationDetails,
        "UpdateBackupDestinationDetails",
        models.UpdateBackupDestinationDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateBackupDestinationResponse>{},
        body: await response.json(),
        bodyKey: "backupDestination",
        bodyModel: "model.BackupDestination",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Update a Database based on the request parameters you provide.
   *
   * @param UpdateDatabaseRequest
   * @return UpdateDatabaseResponse
   * @throws OciError when an error occurs
   */
  public async updateDatabase(
    updateDatabaseRequest: requests.UpdateDatabaseRequest
  ): Promise<responses.UpdateDatabaseResponse> {
    const pathParams = {
      "{databaseId}": updateDatabaseRequest.databaseId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateDatabaseRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/databases/{databaseId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateDatabaseRequest.updateDatabaseDetails,
        "UpdateDatabaseDetails",
        models.UpdateDatabaseDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateDatabaseResponse>{},
        body: await response.json(),
        bodyKey: "database",
        bodyModel: "model.Database",
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Patches the specified dbHome.
   * @param UpdateDbHomeRequest
   * @return UpdateDbHomeResponse
   * @throws OciError when an error occurs
   */
  public async updateDbHome(
    updateDbHomeRequest: requests.UpdateDbHomeRequest
  ): Promise<responses.UpdateDbHomeResponse> {
    const pathParams = {
      "{dbHomeId}": updateDbHomeRequest.dbHomeId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateDbHomeRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/dbHomes/{dbHomeId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateDbHomeRequest.updateDbHomeDetails,
        "UpdateDbHomeDetails",
        models.UpdateDbHomeDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateDbHomeResponse>{},
        body: await response.json(),
        bodyKey: "dbHome",
        bodyModel: "model.DbHome",
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates the properties of a DB system, such as the CPU core count.
   * @param UpdateDbSystemRequest
   * @return UpdateDbSystemResponse
   * @throws OciError when an error occurs
   */
  public async updateDbSystem(
    updateDbSystemRequest: requests.UpdateDbSystemRequest
  ): Promise<responses.UpdateDbSystemResponse> {
    const pathParams = {
      "{dbSystemId}": updateDbSystemRequest.dbSystemId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateDbSystemRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/dbSystems/{dbSystemId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateDbSystemRequest.updateDbSystemDetails,
        "UpdateDbSystemDetails",
        models.UpdateDbSystemDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateDbSystemResponse>{},
        body: await response.json(),
        bodyKey: "dbSystem",
        bodyModel: "model.DbSystem",
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates the Exadata infrastructure.
   *
   * @param UpdateExadataInfrastructureRequest
   * @return UpdateExadataInfrastructureResponse
   * @throws OciError when an error occurs
   */
  public async updateExadataInfrastructure(
    updateExadataInfrastructureRequest: requests.UpdateExadataInfrastructureRequest
  ): Promise<responses.UpdateExadataInfrastructureResponse> {
    const pathParams = {
      "{exadataInfrastructureId}": updateExadataInfrastructureRequest.exadataInfrastructureId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateExadataInfrastructureRequest.ifMatch,
      "opc-request-id": updateExadataInfrastructureRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/exadataInfrastructures/{exadataInfrastructureId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateExadataInfrastructureRequest.updateExadataInfrastructureDetails,
        "UpdateExadataInfrastructureDetails",
        models.UpdateExadataInfrastructureDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateExadataInfrastructureResponse>{},
        body: await response.json(),
        bodyKey: "exadataInfrastructure",
        bodyModel: "model.ExadataInfrastructure",
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Update `IORM` Settings for the requested Exadata DB System.
   *
   * @param UpdateExadataIormConfigRequest
   * @return UpdateExadataIormConfigResponse
   * @throws OciError when an error occurs
   */
  public async updateExadataIormConfig(
    updateExadataIormConfigRequest: requests.UpdateExadataIormConfigRequest
  ): Promise<responses.UpdateExadataIormConfigResponse> {
    const pathParams = {
      "{dbSystemId}": updateExadataIormConfigRequest.dbSystemId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": updateExadataIormConfigRequest.opcRequestId,
      "if-match": updateExadataIormConfigRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/dbSystems/{dbSystemId}/ExadataIormConfig",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateExadataIormConfigRequest.exadataIormConfigUpdateDetails,
        "ExadataIormConfigUpdateDetails",
        models.ExadataIormConfigUpdateDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateExadataIormConfigResponse>{},
        body: await response.json(),
        bodyKey: "exadataIormConfig",
        bodyModel: "model.ExadataIormConfig",
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates the properties of a Maintenance Run, such as the state of a Maintenance Run.
   * @param UpdateMaintenanceRunRequest
   * @return UpdateMaintenanceRunResponse
   * @throws OciError when an error occurs
   */
  public async updateMaintenanceRun(
    updateMaintenanceRunRequest: requests.UpdateMaintenanceRunRequest
  ): Promise<responses.UpdateMaintenanceRunResponse> {
    const pathParams = {
      "{maintenanceRunId}": updateMaintenanceRunRequest.maintenanceRunId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateMaintenanceRunRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/maintenanceRuns/{maintenanceRunId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateMaintenanceRunRequest.updateMaintenanceRunDetails,
        "UpdateMaintenanceRunDetails",
        models.UpdateMaintenanceRunDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateMaintenanceRunResponse>{},
        body: await response.json(),
        bodyKey: "maintenanceRun",
        bodyModel: "model.MaintenanceRun",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates the specified VM cluster.
   *
   * @param UpdateVmClusterRequest
   * @return UpdateVmClusterResponse
   * @throws OciError when an error occurs
   */
  public async updateVmCluster(
    updateVmClusterRequest: requests.UpdateVmClusterRequest
  ): Promise<responses.UpdateVmClusterResponse> {
    const pathParams = {
      "{vmClusterId}": updateVmClusterRequest.vmClusterId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateVmClusterRequest.ifMatch,
      "opc-request-id": updateVmClusterRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/vmClusters/{vmClusterId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateVmClusterRequest.updateVmClusterDetails,
        "UpdateVmClusterDetails",
        models.UpdateVmClusterDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateVmClusterResponse>{},
        body: await response.json(),
        bodyKey: "vmCluster",
        bodyModel: "model.VmCluster",
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates the specified VM cluster network.
   *
   * @param UpdateVmClusterNetworkRequest
   * @return UpdateVmClusterNetworkResponse
   * @throws OciError when an error occurs
   */
  public async updateVmClusterNetwork(
    updateVmClusterNetworkRequest: requests.UpdateVmClusterNetworkRequest
  ): Promise<responses.UpdateVmClusterNetworkResponse> {
    const pathParams = {
      "{exadataInfrastructureId}": updateVmClusterNetworkRequest.exadataInfrastructureId,
      "{vmClusterNetworkId}": updateVmClusterNetworkRequest.vmClusterNetworkId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateVmClusterNetworkRequest.ifMatch,
      "opc-request-id": updateVmClusterNetworkRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path:
        "/exadataInfrastructures/{exadataInfrastructureId}/vmClusterNetworks/{vmClusterNetworkId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateVmClusterNetworkRequest.updateVmClusterNetworkDetails,
        "UpdateVmClusterNetworkDetails",
        models.UpdateVmClusterNetworkDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateVmClusterNetworkResponse>{},
        body: await response.json(),
        bodyKey: "vmClusterNetwork",
        bodyModel: "model.VmClusterNetwork",
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Validates the specified VM cluster network.
   *
   * @param ValidateVmClusterNetworkRequest
   * @return ValidateVmClusterNetworkResponse
   * @throws OciError when an error occurs
   */
  public async validateVmClusterNetwork(
    validateVmClusterNetworkRequest: requests.ValidateVmClusterNetworkRequest
  ): Promise<responses.ValidateVmClusterNetworkResponse> {
    const pathParams = {
      "{exadataInfrastructureId}": validateVmClusterNetworkRequest.exadataInfrastructureId,
      "{vmClusterNetworkId}": validateVmClusterNetworkRequest.vmClusterNetworkId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": validateVmClusterNetworkRequest.opcRequestId,
      "opc-retry-token": validateVmClusterNetworkRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path:
        "/exadataInfrastructures/{exadataInfrastructureId}/vmClusterNetworks/{vmClusterNetworkId}/actions/validate",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ValidateVmClusterNetworkResponse>{},
        body: await response.json(),
        bodyKey: "vmClusterNetwork",
        bodyModel: "model.VmClusterNetwork",
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }
}
