/**
 * Key Management Service API
 * API for managing and performing operations with keys and vaults.
 * OpenAPI spec version: release
 * Contact: sparta_kms_us_grp@oracle.com
 *
 * NOTE: This class is auto generated by OracleSDKGenerator.
 * Do not edit the class manually.
 *
 * Copyright (c) 2020, Oracle and/or its affiliates.  All rights reserved.
 * This software is dual-licensed to you under the Universal Permissive License (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl or Apache License 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose either license.
 */

import common = require("oci-common");
import * as requests from "./request";
import * as models from "./model";
import * as responses from "./response";
import { paginateRecords, paginateResponses } from "oci-common";
import { KmsManagementWaiter } from "./kmsmanagement-waiter";
import { KmsVaultWaiter } from "./kmsvault-waiter";
import { composeResponse, composeRequest } from "oci-common";

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum KmsCryptoApiKeys {}

export class KmsCryptoClient {
  protected static serviceEndpointTemplate = "https://kms.{region}.{secondLevelDomain}";
  protected "_endpoint": string = "";
  protected "_defaultHeaders": any = {};

  protected _httpClient: common.HttpClient;

  constructor(params: common.AuthParams) {
    const requestSigner = params.authenticationDetailsProvider
      ? new common.DefaultRequestSigner(params.authenticationDetailsProvider)
      : null;
    this._httpClient = params.httpClient || new common.FetchHttpClient(requestSigner);
  }

  /**
   * Sets the endpoint to call (ex, https://www.example.com).
   * @param endpoint The endpoint of the service.
   */
  public set endpoint(endpoint: string) {
    this._endpoint = endpoint;
  }

  /**
   * Decrypts data using the given [DecryptDataDetails](https://docs.cloud.oracle.com/api/#/en/key/release/datatypes/DecryptDataDetails) resource.
   *
   * @param DecryptRequest
   * @return DecryptResponse
   * @throws OciError when an error occurs
   */
  public async decrypt(
    decryptRequest: requests.DecryptRequest
  ): Promise<responses.DecryptResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-request-id": decryptRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/decrypt",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        decryptRequest.decryptDataDetails,
        "DecryptDataDetails",
        models.DecryptDataDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DecryptResponse>{},
        body: await response.json(),
        bodyKey: "decryptedData",
        bodyModel: "model.DecryptedData",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Encrypts data using the given [EncryptDataDetails](https://docs.cloud.oracle.com/api/#/en/key/release/datatypes/EncryptDataDetails) resource.
   * Plaintext included in the example request is a base64-encoded value of a UTF-8 string.
   *
   * @param EncryptRequest
   * @return EncryptResponse
   * @throws OciError when an error occurs
   */
  public async encrypt(
    encryptRequest: requests.EncryptRequest
  ): Promise<responses.EncryptResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-request-id": encryptRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/encrypt",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        encryptRequest.encryptDataDetails,
        "EncryptDataDetails",
        models.EncryptDataDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.EncryptResponse>{},
        body: await response.json(),
        bodyKey: "encryptedData",
        bodyModel: "model.EncryptedData",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Generates a key that you can use to encrypt or decrypt data.
   *
   * @param GenerateDataEncryptionKeyRequest
   * @return GenerateDataEncryptionKeyResponse
   * @throws OciError when an error occurs
   */
  public async generateDataEncryptionKey(
    generateDataEncryptionKeyRequest: requests.GenerateDataEncryptionKeyRequest
  ): Promise<responses.GenerateDataEncryptionKeyResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-request-id": generateDataEncryptionKeyRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/generateDataEncryptionKey",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        generateDataEncryptionKeyRequest.generateKeyDetails,
        "GenerateKeyDetails",
        models.GenerateKeyDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GenerateDataEncryptionKeyResponse>{},
        body: await response.json(),
        bodyKey: "generatedKey",
        bodyModel: "model.GeneratedKey",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }
}
export enum KmsManagementApiKeys {}

export class KmsManagementClient {
  protected static serviceEndpointTemplate = "https://kms.{region}.{secondLevelDomain}";
  protected "_endpoint": string = "";
  protected "_defaultHeaders": any = {};
  protected "_waiters": KmsManagementWaiter;

  protected _httpClient: common.HttpClient;

  constructor(params: common.AuthParams) {
    const requestSigner = params.authenticationDetailsProvider
      ? new common.DefaultRequestSigner(params.authenticationDetailsProvider)
      : null;
    this._httpClient = params.httpClient || new common.FetchHttpClient(requestSigner);
  }

  /**
   * Sets the endpoint to call (ex, https://www.example.com).
   * @param endpoint The endpoint of the service.
   */
  public set endpoint(endpoint: string) {
    this._endpoint = endpoint;
  }

  /**
   * Creates a new KmsManagementWaiter for resources for this service.
   *
   * @param config The waiter configuration for termination and delay strategy
   * @return The service waiters.
   */
  public createWaiters(config?: common.WaiterConfiguration): KmsManagementWaiter {
    this._waiters = new KmsManagementWaiter(this, config);
    return this._waiters;
  }

  /**
   * Gets the waiters available for resources for this service.
   *
   * @return The service waiters.
   */
  public getWaiters(): KmsManagementWaiter {
    if (this._waiters) {
      return this._waiters;
    }
    throw Error("Waiters do not exist. Please create waiters.");
  }

  /**
   * Backs up an encrypted file that contains all key versions and metadata of the specified key so that you can restore
   * the key later. The file also contains the metadata of the vault that the key belonged to.
   *
   * @param BackupKeyRequest
   * @return BackupKeyResponse
   * @throws OciError when an error occurs
   */
  public async backupKey(
    backupKeyRequest: requests.BackupKeyRequest
  ): Promise<responses.BackupKeyResponse> {
    const pathParams = {
      "{keyId}": backupKeyRequest.keyId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": backupKeyRequest.ifMatch,
      "opc-request-id": backupKeyRequest.opcRequestId,
      "opc-retry-token": backupKeyRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/keys/{keyId}/actions/backup",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        backupKeyRequest.backupKeyDetails,
        "BackupKeyDetails",
        models.BackupKeyDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.BackupKeyResponse>{},
        body: await response.json(),
        bodyKey: "key",
        bodyModel: "model.Key",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Cancels the scheduled deletion of the specified key. Canceling
* a scheduled deletion restores the key's lifecycle state to what
* it was before its scheduled deletion.
* <p>
As a provisioning operation, this call is subject to a Key Management limit that applies to
* the total number of requests across all provisioning write operations. Key Management might
* throttle this call to reject an otherwise valid request when the total rate of provisioning
* write operations exceeds 10 requests per second for a given tenancy.
* 
     * @param CancelKeyDeletionRequest
     * @return CancelKeyDeletionResponse
     * @throws OciError when an error occurs
     */
  public async cancelKeyDeletion(
    cancelKeyDeletionRequest: requests.CancelKeyDeletionRequest
  ): Promise<responses.CancelKeyDeletionResponse> {
    const pathParams = {
      "{keyId}": cancelKeyDeletionRequest.keyId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": cancelKeyDeletionRequest.ifMatch,
      "opc-request-id": cancelKeyDeletionRequest.opcRequestId,
      "opc-retry-token": cancelKeyDeletionRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/keys/{keyId}/actions/cancelDeletion",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CancelKeyDeletionResponse>{},
        body: await response.json(),
        bodyKey: "key",
        bodyModel: "model.Key",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Cancels the scheduled deletion of the specified key version. Canceling
* a scheduled deletion restores the key version to its lifecycle state from
* before its scheduled deletion.
* <p>
As a provisioning operation, this call is subject to a Key Management limit that applies to
* the total number of requests across all provisioning write operations. Key Management might
* throttle this call to reject an otherwise valid request when the total rate of provisioning
* write operations exceeds 10 requests per second for a given tenancy.
* 
     * @param CancelKeyVersionDeletionRequest
     * @return CancelKeyVersionDeletionResponse
     * @throws OciError when an error occurs
     */
  public async cancelKeyVersionDeletion(
    cancelKeyVersionDeletionRequest: requests.CancelKeyVersionDeletionRequest
  ): Promise<responses.CancelKeyVersionDeletionResponse> {
    const pathParams = {
      "{keyId}": cancelKeyVersionDeletionRequest.keyId,
      "{keyVersionId}": cancelKeyVersionDeletionRequest.keyVersionId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": cancelKeyVersionDeletionRequest.ifMatch,
      "opc-request-id": cancelKeyVersionDeletionRequest.opcRequestId,
      "opc-retry-token": cancelKeyVersionDeletionRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/keys/{keyId}/keyVersions/{keyVersionId}/actions/cancelDeletion",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CancelKeyVersionDeletionResponse>{},
        body: await response.json(),
        bodyKey: "keyVersion",
        bodyModel: "model.KeyVersion",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Moves a key into a different compartment within the same tenancy. For information about
* moving resources between compartments, see [Moving Resources to a Different Compartment](https://docs.cloud.oracle.com/iaas/Content/Identity/Tasks/managingcompartments.htm#moveRes).
* <p>
When provided, if-match is checked against the ETag values of the key.
* <p>
As a provisioning operation, this call is subject to a Key Management limit that applies to
* the total number of requests across all provisioning write operations. Key Management might
* throttle this call to reject an otherwise valid request when the total rate of provisioning
* write operations exceeds 10 requests per second for a given tenancy.
* 
     * @param ChangeKeyCompartmentRequest
     * @return ChangeKeyCompartmentResponse
     * @throws OciError when an error occurs
     */
  public async changeKeyCompartment(
    changeKeyCompartmentRequest: requests.ChangeKeyCompartmentRequest
  ): Promise<responses.ChangeKeyCompartmentResponse> {
    const pathParams = {
      "{keyId}": changeKeyCompartmentRequest.keyId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": changeKeyCompartmentRequest.ifMatch,
      "opc-request-id": changeKeyCompartmentRequest.opcRequestId,
      "opc-retry-token": changeKeyCompartmentRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/keys/{keyId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeKeyCompartmentRequest.changeKeyCompartmentDetails,
        "ChangeKeyCompartmentDetails",
        models.ChangeKeyCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeKeyCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Creates a new master encryption key.
* <p>
As a management operation, this call is subject to a Key Management limit that applies to the total
* number of requests across all management write operations. Key Management might throttle this call
* to reject an otherwise valid request when the total rate of management write operations exceeds 10
* requests per second for a given tenancy.
* 
     * @param CreateKeyRequest
     * @return CreateKeyResponse
     * @throws OciError when an error occurs
     */
  public async createKey(
    createKeyRequest: requests.CreateKeyRequest
  ): Promise<responses.CreateKeyResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-request-id": createKeyRequest.opcRequestId,
      "opc-retry-token": createKeyRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/keys",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createKeyRequest.createKeyDetails,
        "CreateKeyDetails",
        models.CreateKeyDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateKeyResponse>{},
        body: await response.json(),
        bodyKey: "key",
        bodyModel: "model.Key",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Generates a new [KeyVersion](https://docs.cloud.oracle.com/api/#/en/key/release/KeyVersion/) resource that provides new cryptographic
* material for a master encryption key. The key must be in an `ENABLED` state to be rotated.
* <p>
As a management operation, this call is subject to a Key Management limit that applies to the total number
* of requests across all  management write operations. Key Management might throttle this call to reject an
* otherwise valid request when the total rate of management write operations exceeds 10 requests per second
* for a given tenancy.
* 
     * @param CreateKeyVersionRequest
     * @return CreateKeyVersionResponse
     * @throws OciError when an error occurs
     */
  public async createKeyVersion(
    createKeyVersionRequest: requests.CreateKeyVersionRequest
  ): Promise<responses.CreateKeyVersionResponse> {
    const pathParams = {
      "{keyId}": createKeyVersionRequest.keyId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": createKeyVersionRequest.opcRequestId,
      "opc-retry-token": createKeyVersionRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/keys/{keyId}/keyVersions",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateKeyVersionResponse>{},
        body: await response.json(),
        bodyKey: "keyVersion",
        bodyModel: "model.KeyVersion",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Disables a master encryption key so it can no longer be used for encryption, decryption, or
* generating new data encryption keys.
* <p>
As a management operation, this call is subject to a Key Management limit that applies to the total number
* of requests across all management write operations. Key Management might throttle this call to reject an
* otherwise valid request when the total rate of management write operations exceeds 10 requests per second
* for a given tenancy.
* 
     * @param DisableKeyRequest
     * @return DisableKeyResponse
     * @throws OciError when an error occurs
     */
  public async disableKey(
    disableKeyRequest: requests.DisableKeyRequest
  ): Promise<responses.DisableKeyResponse> {
    const pathParams = {
      "{keyId}": disableKeyRequest.keyId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": disableKeyRequest.ifMatch,
      "opc-request-id": disableKeyRequest.opcRequestId,
      "opc-retry-token": disableKeyRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/keys/{keyId}/actions/disable",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DisableKeyResponse>{},
        body: await response.json(),
        bodyKey: "key",
        bodyModel: "model.Key",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Enables a master encryption key so it can be used for encryption, decryption, or
* generating new data encryption keys.
* <p>
As a management operation, this call is subject to a Key Management limit that applies to the total number
* of requests across all management write operations. Key Management might throttle this call to reject an
* otherwise valid request when the total rate of management write operations exceeds 10 requests per second
* for a given tenancy.
* 
     * @param EnableKeyRequest
     * @return EnableKeyResponse
     * @throws OciError when an error occurs
     */
  public async enableKey(
    enableKeyRequest: requests.EnableKeyRequest
  ): Promise<responses.EnableKeyResponse> {
    const pathParams = {
      "{keyId}": enableKeyRequest.keyId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": enableKeyRequest.ifMatch,
      "opc-request-id": enableKeyRequest.opcRequestId,
      "opc-retry-token": enableKeyRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/keys/{keyId}/actions/enable",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.EnableKeyResponse>{},
        body: await response.json(),
        bodyKey: "key",
        bodyModel: "model.Key",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Gets information about the specified master encryption key.
* <p>
As a management operation, this call is subject to a Key Management limit that applies to the total number
* of requests across all management read operations. Key Management might throttle this call to reject an
* otherwise valid request when the total rate of management read operations exceeds 10 requests per second for
* a given tenancy.
* 
     * @param GetKeyRequest
     * @return GetKeyResponse
     * @throws OciError when an error occurs
     */
  public async getKey(getKeyRequest: requests.GetKeyRequest): Promise<responses.GetKeyResponse> {
    const pathParams = {
      "{keyId}": getKeyRequest.keyId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getKeyRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/keys/{keyId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetKeyResponse>{},
        body: await response.json(),
        bodyKey: "key",
        bodyModel: "model.Key",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Gets information about the specified key version.
* <p>
As a management operation, this call is subject to a Key Management limit that applies to the total number
* of requests across all management read operations. Key Management might throttle this call to reject an
* otherwise valid request when the total rate of management read operations exceeds 10 requests per second
* for a given tenancy.
* 
     * @param GetKeyVersionRequest
     * @return GetKeyVersionResponse
     * @throws OciError when an error occurs
     */
  public async getKeyVersion(
    getKeyVersionRequest: requests.GetKeyVersionRequest
  ): Promise<responses.GetKeyVersionResponse> {
    const pathParams = {
      "{keyId}": getKeyVersionRequest.keyId,
      "{keyVersionId}": getKeyVersionRequest.keyVersionId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getKeyVersionRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/keys/{keyId}/keyVersions/{keyVersionId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetKeyVersionResponse>{},
        body: await response.json(),
        bodyKey: "keyVersion",
        bodyModel: "model.KeyVersion",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets details about the public RSA wrapping key associated with the vault in the endpoint. Each vault has an RSA key-pair that wraps and
   * unwraps AES key material for import into Key Management.
   *
   * @param GetWrappingKeyRequest
   * @return GetWrappingKeyResponse
   * @throws OciError when an error occurs
   */
  public async getWrappingKey(
    getWrappingKeyRequest: requests.GetWrappingKeyRequest
  ): Promise<responses.GetWrappingKeyResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getWrappingKeyRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/wrappingKeys",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetWrappingKeyResponse>{},
        body: await response.json(),
        bodyKey: "wrappingKey",
        bodyModel: "model.WrappingKey",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Imports AES key material to create a new key with. The key material must be base64-encoded and
   * wrapped by the vault's public RSA wrapping key before you can import it. Key Management supports AES symmetric keys
   * that are exactly 16, 24, or 32 bytes. Furthermore, the key length must match what you specify at the time of import.
   *
   * @param ImportKeyRequest
   * @return ImportKeyResponse
   * @throws OciError when an error occurs
   */
  public async importKey(
    importKeyRequest: requests.ImportKeyRequest
  ): Promise<responses.ImportKeyResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-request-id": importKeyRequest.opcRequestId,
      "opc-retry-token": importKeyRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/keys/import",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        importKeyRequest.importKeyDetails,
        "ImportKeyDetails",
        models.ImportKeyDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ImportKeyResponse>{},
        body: await response.json(),
        bodyKey: "key",
        bodyModel: "model.Key",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Imports AES key material to create a new key version with, and then rotates the key to begin using the new
   * key version. The key material must be base64-encoded and wrapped by the vault's public RSA wrapping key
   * before you can import it. Key Management supports AES symmetric keys that are exactly 16, 24, or 32 bytes.
   * Furthermore, the key length must match the length of the specified key and what you specify as the length
   * at the time of import.
   *
   * @param ImportKeyVersionRequest
   * @return ImportKeyVersionResponse
   * @throws OciError when an error occurs
   */
  public async importKeyVersion(
    importKeyVersionRequest: requests.ImportKeyVersionRequest
  ): Promise<responses.ImportKeyVersionResponse> {
    const pathParams = {
      "{keyId}": importKeyVersionRequest.keyId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": importKeyVersionRequest.opcRequestId,
      "opc-retry-token": importKeyVersionRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/keys/{keyId}/keyVersions/import",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        importKeyVersionRequest.importKeyVersionDetails,
        "ImportKeyVersionDetails",
        models.ImportKeyVersionDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ImportKeyVersionResponse>{},
        body: await response.json(),
        bodyKey: "keyVersion",
        bodyModel: "model.KeyVersion",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Lists all [KeyVersion](https://docs.cloud.oracle.com/api/#/en/key/release/KeyVersion/) resources for the specified
* master encryption key.
* <p>
As a management operation, this call is subject to a Key Management limit that applies to the total number
* of requests across all management read operations. Key Management might throttle this call to reject an
* otherwise valid request when the total rate of management read operations exceeds 10 requests per second
* for a given tenancy.
* 
     * @param ListKeyVersionsRequest
     * @return ListKeyVersionsResponse
     * @throws OciError when an error occurs
     */
  public async listKeyVersions(
    listKeyVersionsRequest: requests.ListKeyVersionsRequest
  ): Promise<responses.ListKeyVersionsResponse> {
    const pathParams = {
      "{keyId}": listKeyVersionsRequest.keyId
    };

    const queryParams = {
      "limit": listKeyVersionsRequest.limit,
      "page": listKeyVersionsRequest.page,
      "sortBy": listKeyVersionsRequest.sortBy,
      "sortOrder": listKeyVersionsRequest.sortOrder
    };

    let headerParams = {
      "opc-request-id": listKeyVersionsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/keys/{keyId}/keyVersions",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListKeyVersionsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "KeyVersionSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.KeyVersionSummary objects
   * contained in responses from the listKeyVersions operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllKeyVersions(
    request: requests.ListKeyVersionsRequest
  ): AsyncIterableIterator<models.KeyVersionSummary> {
    return paginateRecords(request, req => this.listKeyVersions(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listKeyVersions operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllKeyVersionsResponses(
    request: requests.ListKeyVersionsRequest
  ): AsyncIterableIterator<responses.ListKeyVersionsResponse> {
    return paginateResponses(request, req => this.listKeyVersions(req));
  }

  /**
     * Lists the master encryption keys in the specified vault and compartment.
* <p>
As a management operation, this call is subject to a Key Management limit that applies to the total number
* of requests across all management read operations. Key Management might throttle this call to reject an
* otherwise valid request when the total rate of management read operations exceeds 10 requests per second
* for a given tenancy.
* 
     * @param ListKeysRequest
     * @return ListKeysResponse
     * @throws OciError when an error occurs
     */
  public async listKeys(
    listKeysRequest: requests.ListKeysRequest
  ): Promise<responses.ListKeysResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listKeysRequest.compartmentId,
      "limit": listKeysRequest.limit,
      "page": listKeysRequest.page,
      "sortBy": listKeysRequest.sortBy,
      "sortOrder": listKeysRequest.sortOrder
    };

    let headerParams = {
      "opc-request-id": listKeysRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/keys",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListKeysResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "KeySummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.KeySummary objects
   * contained in responses from the listKeys operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllKeys(request: requests.ListKeysRequest): AsyncIterableIterator<models.KeySummary> {
    return paginateRecords(request, req => this.listKeys(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listKeys operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllKeysResponses(
    request: requests.ListKeysRequest
  ): AsyncIterableIterator<responses.ListKeysResponse> {
    return paginateResponses(request, req => this.listKeys(req));
  }

  /**
   * Restores the specified key to the specified vault, based on information in the backup file provided.
   * If the vault doesn't exist, the operation returns a response with a 404 HTTP status error code. You
   * need to first restore the vault associated with the key.
   *
   * @param RestoreKeyFromFileRequest
   * @return RestoreKeyFromFileResponse
   * @throws OciError when an error occurs
   */
  public async restoreKeyFromFile(
    restoreKeyFromFileRequest: requests.RestoreKeyFromFileRequest
  ): Promise<responses.RestoreKeyFromFileResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "content-length": restoreKeyFromFileRequest.contentLength,
      "if-match": restoreKeyFromFileRequest.ifMatch,
      "content-md5": restoreKeyFromFileRequest.contentMd5,
      "opc-request-id": restoreKeyFromFileRequest.opcRequestId,
      "opc-retry-token": restoreKeyFromFileRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/keys/actions/restoreFromFile",
      method: "POST",
      bodyContent: restoreKeyFromFileRequest.restoreKeyFromFileDetails,
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.RestoreKeyFromFileResponse>{},
        body: await response.json(),
        bodyKey: "key",
        bodyModel: "model.Key",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-content-md5"),
            key: "opcContentMd5",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Restores the specified key to the specified vault from an Oracle Cloud Infrastructure
   * Object Storage location. If the vault doesn't exist, the operation returns a response with a
   * 404 HTTP status error code. You need to first restore the vault associated with the key.
   *
   * @param RestoreKeyFromObjectStoreRequest
   * @return RestoreKeyFromObjectStoreResponse
   * @throws OciError when an error occurs
   */
  public async restoreKeyFromObjectStore(
    restoreKeyFromObjectStoreRequest: requests.RestoreKeyFromObjectStoreRequest
  ): Promise<responses.RestoreKeyFromObjectStoreResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "if-match": restoreKeyFromObjectStoreRequest.ifMatch,
      "opc-request-id": restoreKeyFromObjectStoreRequest.opcRequestId,
      "opc-retry-token": restoreKeyFromObjectStoreRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/keys/actions/restoreFromObjectStore",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        restoreKeyFromObjectStoreRequest.restoreKeyFromObjectStoreDetails,
        "RestoreKeyFromObjectStoreDetails",
        models.RestoreKeyFromObjectStoreDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.RestoreKeyFromObjectStoreResponse>{},
        body: await response.json(),
        bodyKey: "key",
        bodyModel: "model.Key",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Schedules the deletion of the specified key. This sets the lifecycle state of the key
* to `PENDING_DELETION` and then deletes it after the specified retention period ends.
* <p>
As a provisioning operation, this call is subject to a Key Management limit that applies to
* the total number of requests across all provisioning write operations. Key Management might
* throttle this call to reject an otherwise valid request when the total rate of provisioning
* write operations exceeds 10 requests per second for a given tenancy.
* 
     * @param ScheduleKeyDeletionRequest
     * @return ScheduleKeyDeletionResponse
     * @throws OciError when an error occurs
     */
  public async scheduleKeyDeletion(
    scheduleKeyDeletionRequest: requests.ScheduleKeyDeletionRequest
  ): Promise<responses.ScheduleKeyDeletionResponse> {
    const pathParams = {
      "{keyId}": scheduleKeyDeletionRequest.keyId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": scheduleKeyDeletionRequest.ifMatch,
      "opc-request-id": scheduleKeyDeletionRequest.opcRequestId,
      "opc-retry-token": scheduleKeyDeletionRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/keys/{keyId}/actions/scheduleDeletion",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        scheduleKeyDeletionRequest.scheduleKeyDeletionDetails,
        "ScheduleKeyDeletionDetails",
        models.ScheduleKeyDeletionDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ScheduleKeyDeletionResponse>{},
        body: await response.json(),
        bodyKey: "key",
        bodyModel: "model.Key",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Schedules the deletion of the specified key version. This sets the lifecycle state of the key version
* to `PENDING_DELETION` and then deletes it after the specified retention period ends.
* <p>
As a provisioning operation, this call is subject to a Key Management limit that applies to
* the total number of requests across all provisioning write operations. Key Management might
* throttle this call to reject an otherwise valid request when the total rate of provisioning
* write operations exceeds 10 requests per second for a given tenancy.
* 
     * @param ScheduleKeyVersionDeletionRequest
     * @return ScheduleKeyVersionDeletionResponse
     * @throws OciError when an error occurs
     */
  public async scheduleKeyVersionDeletion(
    scheduleKeyVersionDeletionRequest: requests.ScheduleKeyVersionDeletionRequest
  ): Promise<responses.ScheduleKeyVersionDeletionResponse> {
    const pathParams = {
      "{keyId}": scheduleKeyVersionDeletionRequest.keyId,
      "{keyVersionId}": scheduleKeyVersionDeletionRequest.keyVersionId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": scheduleKeyVersionDeletionRequest.ifMatch,
      "opc-request-id": scheduleKeyVersionDeletionRequest.opcRequestId,
      "opc-retry-token": scheduleKeyVersionDeletionRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/keys/{keyId}/keyVersions/{keyVersionId}/actions/scheduleDeletion",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        scheduleKeyVersionDeletionRequest.scheduleKeyVersionDeletionDetails,
        "ScheduleKeyVersionDeletionDetails",
        models.ScheduleKeyVersionDeletionDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ScheduleKeyVersionDeletionResponse>{},
        body: await response.json(),
        bodyKey: "keyVersion",
        bodyModel: "model.KeyVersion",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Updates the properties of a master encryption key. Specifically, you can update the
* `displayName`, `freeformTags`, and `definedTags` properties. Furthermore,
* the key must in an ENABLED or CREATING state to be updated.
* <p>
As a management operation, this call is subject to a Key Management limit that applies to the total number
* of requests across all management write operations. Key Management might throttle this call to reject an
* otherwise valid request when the total rate of management write operations exceeds 10 requests per second
* for a given tenancy.
* 
     * @param UpdateKeyRequest
     * @return UpdateKeyResponse
     * @throws OciError when an error occurs
     */
  public async updateKey(
    updateKeyRequest: requests.UpdateKeyRequest
  ): Promise<responses.UpdateKeyResponse> {
    const pathParams = {
      "{keyId}": updateKeyRequest.keyId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateKeyRequest.ifMatch,
      "opc-request-id": updateKeyRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/keys/{keyId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateKeyRequest.updateKeyDetails,
        "UpdateKeyDetails",
        models.UpdateKeyDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateKeyResponse>{},
        body: await response.json(),
        bodyKey: "key",
        bodyModel: "model.Key",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }
}
export enum KmsVaultApiKeys {}

export class KmsVaultClient {
  protected static serviceEndpointTemplate = "https://kms.{region}.{secondLevelDomain}";
  protected "_endpoint": string = "";
  protected "_defaultHeaders": any = {};
  protected "_waiters": KmsVaultWaiter;

  protected _httpClient: common.HttpClient;

  constructor(params: common.AuthParams) {
    const requestSigner = params.authenticationDetailsProvider
      ? new common.DefaultRequestSigner(params.authenticationDetailsProvider)
      : null;
    this._httpClient = params.httpClient || new common.FetchHttpClient(requestSigner);

    if (
      params.authenticationDetailsProvider &&
      common.isRegionProvider(params.authenticationDetailsProvider)
    ) {
      const provider: common.RegionProvider = params.authenticationDetailsProvider;
      if (provider.getRegion()) {
        this.region = provider.getRegion();
      }
    }
  }

  /**
   * Sets the endpoint to call (ex, https://www.example.com).
   * @param endpoint The endpoint of the service.
   */
  public set endpoint(endpoint: string) {
    this._endpoint = endpoint;
  }

  /**
   * Sets the region to call (ex, Region.US_PHOENIX_1).
   * Note, this will call {@link #endpoint(String) endpoint} after resolving the endpoint.
   * @param region The region of the service.
   */
  public set region(region: common.Region) {
    this.endpoint = common.EndpointBuilder.createEndpointFromRegion(
      KmsVaultClient.serviceEndpointTemplate,
      region
    );
  }

  /**
   * Sets the regionId to call (ex, 'us-phoenix-1').
   *
   * Note, this will first try to map the region ID to a known Region and call {@link #region(Region) region}.
   * If no known Region could be determined, it will create an endpoint assuming its in default Realm OC1
   * and then call {@link #endpoint(String) endpoint}.
   * @param regionId The public region ID.
   */
  public set regionId(regionId: string) {
    this.endpoint = common.EndpointBuilder.createEndpointFromRegionId(
      KmsVaultClient.serviceEndpointTemplate,
      regionId
    );
  }

  /**
   * Creates a new KmsVaultWaiter for resources for this service.
   *
   * @param config The waiter configuration for termination and delay strategy
   * @return The service waiters.
   */
  public createWaiters(config?: common.WaiterConfiguration): KmsVaultWaiter {
    this._waiters = new KmsVaultWaiter(this, config);
    return this._waiters;
  }

  /**
   * Gets the waiters available for resources for this service.
   *
   * @return The service waiters.
   */
  public getWaiters(): KmsVaultWaiter {
    if (this._waiters) {
      return this._waiters;
    }
    throw Error("Waiters do not exist. Please create waiters.");
  }

  /**
   * Backs up an encrypted file that contains all the metadata of a vault so that you can restore the vault later.
   * You can backup a vault whether or not it contains keys. This operation only backs up the
   * metadata of the vault, and does not include key metadata.
   *
   * @param BackupVaultRequest
   * @return BackupVaultResponse
   * @throws OciError when an error occurs
   */
  public async backupVault(
    backupVaultRequest: requests.BackupVaultRequest
  ): Promise<responses.BackupVaultResponse> {
    const pathParams = {
      "{vaultId}": backupVaultRequest.vaultId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": backupVaultRequest.ifMatch,
      "opc-request-id": backupVaultRequest.opcRequestId,
      "opc-retry-token": backupVaultRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/vaults/{vaultId}/actions/backup",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        backupVaultRequest.backupVaultDetails,
        "BackupVaultDetails",
        models.BackupVaultDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.BackupVaultResponse>{},
        body: await response.json(),
        bodyKey: "vault",
        bodyModel: "model.Vault",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Cancels the scheduled deletion of the specified vault. Canceling a scheduled deletion
* restores the vault and all keys in it to their respective states from before their
* scheduled deletion. All keys that were scheduled for deletion prior to vault
* deletion retain their lifecycle state and time of deletion.
* <p>
As a provisioning operation, this call is subject to a Key Management limit that applies to
* the total number of requests across all provisioning write operations. Key Management might
* throttle this call to reject an otherwise valid request when the total rate of provisioning
* write operations exceeds 10 requests per second for a given tenancy.
* 
     * @param CancelVaultDeletionRequest
     * @return CancelVaultDeletionResponse
     * @throws OciError when an error occurs
     */
  public async cancelVaultDeletion(
    cancelVaultDeletionRequest: requests.CancelVaultDeletionRequest
  ): Promise<responses.CancelVaultDeletionResponse> {
    const pathParams = {
      "{vaultId}": cancelVaultDeletionRequest.vaultId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": cancelVaultDeletionRequest.ifMatch,
      "opc-request-id": cancelVaultDeletionRequest.opcRequestId,
      "opc-retry-token": cancelVaultDeletionRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/vaults/{vaultId}/actions/cancelDeletion",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CancelVaultDeletionResponse>{},
        body: await response.json(),
        bodyKey: "vault",
        bodyModel: "model.Vault",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Moves a vault into a different compartment within the same tenancy. For information about
* moving resources between compartments, see [Moving Resources to a Different Compartment](https://docs.cloud.oracle.com/iaas/Content/Identity/Tasks/managingcompartments.htm#moveRes).
* <p>
When provided, if-match is checked against the ETag values of the resource.
* <p>
As a provisioning operation, this call is subject to a Key Management limit that applies to
* the total number of requests across all provisioning write operations. Key Management might
* throttle this call to reject an otherwise valid request when the total rate of provisioning
* write operations exceeds 10 requests per second for a given tenancy.
* 
     * @param ChangeVaultCompartmentRequest
     * @return ChangeVaultCompartmentResponse
     * @throws OciError when an error occurs
     */
  public async changeVaultCompartment(
    changeVaultCompartmentRequest: requests.ChangeVaultCompartmentRequest
  ): Promise<responses.ChangeVaultCompartmentResponse> {
    const pathParams = {
      "{vaultId}": changeVaultCompartmentRequest.vaultId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": changeVaultCompartmentRequest.ifMatch,
      "opc-request-id": changeVaultCompartmentRequest.opcRequestId,
      "opc-retry-token": changeVaultCompartmentRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/vaults/{vaultId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeVaultCompartmentRequest.changeVaultCompartmentDetails,
        "ChangeVaultCompartmentDetails",
        models.ChangeVaultCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeVaultCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Creates a new vault. The type of vault you create determines key placement, pricing, and
* available options. Options include storage isolation, a dedicated service endpoint instead
* of a shared service endpoint for API calls, and either a dedicated hardware security module
* (HSM) or a multitenant HSM.
* <p>
As a provisioning operation, this call is subject to a Key Management limit that applies to
* the total number of requests across all provisioning write operations. Key Management might
* throttle this call to reject an otherwise valid request when the total rate of provisioning
* write operations exceeds 10 requests per second for a given tenancy.
* 
     * @param CreateVaultRequest
     * @return CreateVaultResponse
     * @throws OciError when an error occurs
     */
  public async createVault(
    createVaultRequest: requests.CreateVaultRequest
  ): Promise<responses.CreateVaultResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-request-id": createVaultRequest.opcRequestId,
      "opc-retry-token": createVaultRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/vaults",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createVaultRequest.createVaultDetails,
        "CreateVaultDetails",
        models.CreateVaultDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateVaultResponse>{},
        body: await response.json(),
        bodyKey: "vault",
        bodyModel: "model.Vault",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Gets the specified vault's configuration information.
* <p>
As a provisioning operation, this call is subject to a Key Management limit that applies to
* the total number of requests across all provisioning read operations. Key Management might
* throttle this call to reject an otherwise valid request when the total rate of provisioning
* read operations exceeds 10 requests per second for a given tenancy.
* 
     * @param GetVaultRequest
     * @return GetVaultResponse
     * @throws OciError when an error occurs
     */
  public async getVault(
    getVaultRequest: requests.GetVaultRequest
  ): Promise<responses.GetVaultResponse> {
    const pathParams = {
      "{vaultId}": getVaultRequest.vaultId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getVaultRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/vaults/{vaultId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetVaultResponse>{},
        body: await response.json(),
        bodyKey: "vault",
        bodyModel: "model.Vault",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the count of keys and key versions in the specified vault to calculate usage against service limits.
   *
   * @param GetVaultUsageRequest
   * @return GetVaultUsageResponse
   * @throws OciError when an error occurs
   */
  public async getVaultUsage(
    getVaultUsageRequest: requests.GetVaultUsageRequest
  ): Promise<responses.GetVaultUsageResponse> {
    const pathParams = {
      "{vaultId}": getVaultUsageRequest.vaultId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getVaultUsageRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/vaults/{vaultId}/usage",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetVaultUsageResponse>{},
        body: await response.json(),
        bodyKey: "vaultUsage",
        bodyModel: "model.VaultUsage",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Lists the vaults in the specified compartment.
* <p>
As a provisioning operation, this call is subject to a Key Management limit that applies to
* the total number of requests across all provisioning read operations. Key Management might
* throttle this call to reject an otherwise valid request when the total rate of provisioning
* read operations exceeds 10 requests per second for a given tenancy.
* 
     * @param ListVaultsRequest
     * @return ListVaultsResponse
     * @throws OciError when an error occurs
     */
  public async listVaults(
    listVaultsRequest: requests.ListVaultsRequest
  ): Promise<responses.ListVaultsResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listVaultsRequest.compartmentId,
      "limit": listVaultsRequest.limit,
      "page": listVaultsRequest.page,
      "sortBy": listVaultsRequest.sortBy,
      "sortOrder": listVaultsRequest.sortOrder
    };

    let headerParams = {
      "opc-request-id": listVaultsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/vaults",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListVaultsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "VaultSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.VaultSummary objects
   * contained in responses from the listVaults operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllVaults(
    request: requests.ListVaultsRequest
  ): AsyncIterableIterator<models.VaultSummary> {
    return paginateRecords(request, req => this.listVaults(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listVaults operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllVaultsResponses(
    request: requests.ListVaultsRequest
  ): AsyncIterableIterator<responses.ListVaultsResponse> {
    return paginateResponses(request, req => this.listVaults(req));
  }

  /**
   * Restores a vault from an encrypted backup file. If a vault
   * with the same OCID already exists, this operation returns a response with a
   * 409 HTTP status error code.
   *
   * @param RestoreVaultFromFileRequest
   * @return RestoreVaultFromFileResponse
   * @throws OciError when an error occurs
   */
  public async restoreVaultFromFile(
    restoreVaultFromFileRequest: requests.RestoreVaultFromFileRequest
  ): Promise<responses.RestoreVaultFromFileResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": restoreVaultFromFileRequest.compartmentId
    };

    let headerParams = {
      "content-length": restoreVaultFromFileRequest.contentLength,
      "if-match": restoreVaultFromFileRequest.ifMatch,
      "content-md5": restoreVaultFromFileRequest.contentMd5,
      "opc-request-id": restoreVaultFromFileRequest.opcRequestId,
      "opc-retry-token": restoreVaultFromFileRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/vaults/actions/restoreFromFile",
      method: "POST",
      bodyContent: restoreVaultFromFileRequest.restoreVaultFromFileDetails,
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.RestoreVaultFromFileResponse>{},
        body: await response.json(),
        bodyKey: "vault",
        bodyModel: "model.Vault",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-content-md5"),
            key: "opcContentMd5",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Restores a vault from an encrypted backup file stored in Oracle Cloud Infrastructure Object
   * Storage. If a vault with the same OCID already exists, this operation returns
   * a response with a 409 HTTP status error code.
   *
   * @param RestoreVaultFromObjectStoreRequest
   * @return RestoreVaultFromObjectStoreResponse
   * @throws OciError when an error occurs
   */
  public async restoreVaultFromObjectStore(
    restoreVaultFromObjectStoreRequest: requests.RestoreVaultFromObjectStoreRequest
  ): Promise<responses.RestoreVaultFromObjectStoreResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": restoreVaultFromObjectStoreRequest.compartmentId
    };

    let headerParams = {
      "if-match": restoreVaultFromObjectStoreRequest.ifMatch,
      "opc-request-id": restoreVaultFromObjectStoreRequest.opcRequestId,
      "opc-retry-token": restoreVaultFromObjectStoreRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/vaults/actions/restoreFromObjectStore",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        restoreVaultFromObjectStoreRequest.restoreVaultFromObjectStoreDetails,
        "RestoreVaultFromObjectStoreDetails",
        models.RestoreVaultFromObjectStoreDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.RestoreVaultFromObjectStoreResponse>{},
        body: await response.json(),
        bodyKey: "vault",
        bodyModel: "model.Vault",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Schedules the deletion of the specified vault. This sets the lifecycle state of the vault and all keys in it
* that are not already scheduled for deletion to `PENDING_DELETION` and then deletes them after the
* retention period ends. The lifecycle state and time of deletion for keys already scheduled for deletion won't
* change. If any keys in the vault are scheduled to be deleted after the specified time of
* deletion for the vault, the call is rejected with the error code 409.
* <p>
As a provisioning operation, this call is subject to a Key Management limit that applies to
* the total number of requests across all provisioning write operations. Key Management might
* throttle this call to reject an otherwise valid request when the total rate of provisioning
* write operations exceeds 10 requests per second for a given tenancy.
* 
     * @param ScheduleVaultDeletionRequest
     * @return ScheduleVaultDeletionResponse
     * @throws OciError when an error occurs
     */
  public async scheduleVaultDeletion(
    scheduleVaultDeletionRequest: requests.ScheduleVaultDeletionRequest
  ): Promise<responses.ScheduleVaultDeletionResponse> {
    const pathParams = {
      "{vaultId}": scheduleVaultDeletionRequest.vaultId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": scheduleVaultDeletionRequest.ifMatch,
      "opc-request-id": scheduleVaultDeletionRequest.opcRequestId,
      "opc-retry-token": scheduleVaultDeletionRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/vaults/{vaultId}/actions/scheduleDeletion",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        scheduleVaultDeletionRequest.scheduleVaultDeletionDetails,
        "ScheduleVaultDeletionDetails",
        models.ScheduleVaultDeletionDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ScheduleVaultDeletionResponse>{},
        body: await response.json(),
        bodyKey: "vault",
        bodyModel: "model.Vault",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Updates the properties of a vault. Specifically, you can update the
* `displayName`, `freeformTags`, and `definedTags` properties. Furthermore,
* the vault must be in an ACTIVE or CREATING state to be updated.
* <p>
As a provisioning operation, this call is subject to a Key Management limit that applies to
* the total number of requests across all provisioning write operations. Key Management might
* throttle this call to reject an otherwise valid request when the total rate of provisioning
* write operations exceeds 10 requests per second for a given tenancy.
* 
     * @param UpdateVaultRequest
     * @return UpdateVaultResponse
     * @throws OciError when an error occurs
     */
  public async updateVault(
    updateVaultRequest: requests.UpdateVaultRequest
  ): Promise<responses.UpdateVaultResponse> {
    const pathParams = {
      "{vaultId}": updateVaultRequest.vaultId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateVaultRequest.ifMatch,
      "opc-request-id": updateVaultRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/20180608/vaults/{vaultId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateVaultRequest.updateVaultDetails,
        "UpdateVaultDetails",
        models.UpdateVaultDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateVaultResponse>{},
        body: await response.json(),
        bodyKey: "vault",
        bodyModel: "model.Vault",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }
}
