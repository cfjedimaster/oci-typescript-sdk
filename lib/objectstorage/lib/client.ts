/**
 * Object Storage Service API
 * Common set of Object Storage and Archive Storage APIs for managing buckets, objects, and related resources.
For more information, see [Overview of Object Storage](/Content/Object/Concepts/objectstorageoverview.htm) and
[Overview of Archive Storage](/Content/Archive/Concepts/archivestorageoverview.htm).

 * OpenAPI spec version: 20160918
 * Contact: opc_casper_users_us_grp@oracle.com
 *
 * NOTE: This class is auto generated by OracleSDKGenerator.
 * Do not edit the class manually.
 *
 * Copyright (c) 2020, Oracle and/or its affiliates.  All rights reserved.
 * This software is dual-licensed to you under the Universal Permissive License (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl or Apache License 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose either license.
 */

import common = require("oci-common");
import * as requests from "./request";
import * as models from "./model";
import * as responses from "./response";
import {
  paginateRecords,
  paginateResponses,
  genericPaginateRecords,
  genericPaginateResponses
} from "oci-common";
import { ObjectStorageWaiter } from "./objectstorage-waiter";
import { composeResponse, composeRequest } from "oci-common";

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum ObjectStorageApiKeys {}

export class ObjectStorageClient {
  protected static serviceEndpointTemplate = "https://objectstorage.{region}.{secondLevelDomain}";
  protected "_endpoint": string = "";
  protected "_defaultHeaders": any = {};
  protected "_waiters": ObjectStorageWaiter;

  protected _httpClient: common.HttpClient;

  constructor(params: common.AuthParams) {
    const requestSigner = params.authenticationDetailsProvider
      ? new common.DefaultRequestSigner(params.authenticationDetailsProvider)
      : null;
    this._httpClient = params.httpClient || new common.FetchHttpClient(requestSigner);

    if (
      params.authenticationDetailsProvider &&
      common.isRegionProvider(params.authenticationDetailsProvider)
    ) {
      const provider: common.RegionProvider = params.authenticationDetailsProvider;
      if (provider.getRegion()) {
        this.region = provider.getRegion();
      }
    }
  }

  /**
   * Sets the endpoint to call (ex, https://www.example.com).
   * @param endpoint The endpoint of the service.
   */
  public set endpoint(endpoint: string) {
    this._endpoint = endpoint;
  }

  /**
   * Sets the region to call (ex, Region.US_PHOENIX_1).
   * Note, this will call {@link #endpoint(String) endpoint} after resolving the endpoint.
   * @param region The region of the service.
   */
  public set region(region: common.Region) {
    this.endpoint = common.EndpointBuilder.createEndpointFromRegion(
      ObjectStorageClient.serviceEndpointTemplate,
      region
    );
  }

  /**
   * Sets the regionId to call (ex, 'us-phoenix-1').
   *
   * Note, this will first try to map the region ID to a known Region and call {@link #region(Region) region}.
   * If no known Region could be determined, it will create an endpoint assuming its in default Realm OC1
   * and then call {@link #endpoint(String) endpoint}.
   * @param regionId The public region ID.
   */
  public set regionId(regionId: string) {
    this.endpoint = common.EndpointBuilder.createEndpointFromRegionId(
      ObjectStorageClient.serviceEndpointTemplate,
      regionId
    );
  }

  /**
   * Creates a new ObjectStorageWaiter for resources for this service.
   *
   * @param config The waiter configuration for termination and delay strategy
   * @return The service waiters.
   */
  public createWaiters(config?: common.WaiterConfiguration): ObjectStorageWaiter {
    this._waiters = new ObjectStorageWaiter(this, config);
    return this._waiters;
  }

  /**
   * Gets the waiters available for resources for this service.
   *
   * @return The service waiters.
   */
  public getWaiters(): ObjectStorageWaiter {
    if (this._waiters) {
      return this._waiters;
    }
    throw Error("Waiters do not exist. Please create waiters.");
  }

  /**
   * Aborts an in-progress multipart upload and deletes all parts that have been uploaded.
   *
   * @param AbortMultipartUploadRequest
   * @return AbortMultipartUploadResponse
   * @throws OciError when an error occurs
   */
  public async abortMultipartUpload(
    abortMultipartUploadRequest: requests.AbortMultipartUploadRequest
  ): Promise<responses.AbortMultipartUploadResponse> {
    const pathParams = {
      "{namespaceName}": abortMultipartUploadRequest.namespaceName,
      "{bucketName}": abortMultipartUploadRequest.bucketName,
      "{objectName}": abortMultipartUploadRequest.objectName
    };

    const queryParams = {
      "uploadId": abortMultipartUploadRequest.uploadId
    };

    let headerParams = {
      "opc-client-request-id": abortMultipartUploadRequest.opcClientRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/n/{namespaceName}/b/{bucketName}/u/{objectName}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.AbortMultipartUploadResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-client-request-id"),
            key: "opcClientRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Cancels a work request.
   *
   * @param CancelWorkRequestRequest
   * @return CancelWorkRequestResponse
   * @throws OciError when an error occurs
   */
  public async cancelWorkRequest(
    cancelWorkRequestRequest: requests.CancelWorkRequestRequest
  ): Promise<responses.CancelWorkRequestResponse> {
    const pathParams = {
      "{workRequestId}": cancelWorkRequestRequest.workRequestId
    };

    const queryParams = {};

    let headerParams = {
      "opc-client-request-id": cancelWorkRequestRequest.opcClientRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workRequests/{workRequestId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CancelWorkRequestResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-client-request-id"),
            key: "opcClientRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Commits a multipart upload, which involves checking part numbers and entity tags (ETags) of the parts, to create an aggregate object.
   *
   * @param CommitMultipartUploadRequest
   * @return CommitMultipartUploadResponse
   * @throws OciError when an error occurs
   */
  public async commitMultipartUpload(
    commitMultipartUploadRequest: requests.CommitMultipartUploadRequest
  ): Promise<responses.CommitMultipartUploadResponse> {
    const pathParams = {
      "{namespaceName}": commitMultipartUploadRequest.namespaceName,
      "{bucketName}": commitMultipartUploadRequest.bucketName,
      "{objectName}": commitMultipartUploadRequest.objectName
    };

    const queryParams = {
      "uploadId": commitMultipartUploadRequest.uploadId
    };

    let headerParams = {
      "if-match": commitMultipartUploadRequest.ifMatch,
      "if-none-match": commitMultipartUploadRequest.ifNoneMatch,
      "opc-client-request-id": commitMultipartUploadRequest.opcClientRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/n/{namespaceName}/b/{bucketName}/u/{objectName}",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        commitMultipartUploadRequest.commitMultipartUploadDetails,
        "CommitMultipartUploadDetails",
        models.CommitMultipartUploadDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CommitMultipartUploadResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-client-request-id"),
            key: "opcClientRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-multipart-md5"),
            key: "opcMultipartMd5",
            dataType: "string"
          },
          {
            value: response.headers.get("ETag"),
            key: "eTag",
            dataType: "string"
          },
          {
            value: response.headers.get("last-modified"),
            key: "lastModified",
            dataType: "Date"
          },
          {
            value: response.headers.get("version-id"),
            key: "versionId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a request to copy an object within a region or to another region.
   *
   * @param CopyObjectRequest
   * @return CopyObjectResponse
   * @throws OciError when an error occurs
   */
  public async copyObject(
    copyObjectRequest: requests.CopyObjectRequest
  ): Promise<responses.CopyObjectResponse> {
    const pathParams = {
      "{namespaceName}": copyObjectRequest.namespaceName,
      "{bucketName}": copyObjectRequest.bucketName
    };

    const queryParams = {};

    let headerParams = {
      "opc-client-request-id": copyObjectRequest.opcClientRequestId,
      "opc-sse-customer-algorithm": copyObjectRequest.opcSseCustomerAlgorithm,
      "opc-sse-customer-key": copyObjectRequest.opcSseCustomerKey,
      "opc-sse-customer-key-sha256": copyObjectRequest.opcSseCustomerKeySha256,
      "opc-source-sse-customer-algorithm": copyObjectRequest.opcSourceSseCustomerAlgorithm,
      "opc-source-sse-customer-key": copyObjectRequest.opcSourceSseCustomerKey,
      "opc-source-sse-customer-key-sha256": copyObjectRequest.opcSourceSseCustomerKeySha256
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/n/{namespaceName}/b/{bucketName}/actions/copyObject",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        copyObjectRequest.copyObjectDetails,
        "CopyObjectDetails",
        models.CopyObjectDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CopyObjectResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-client-request-id"),
            key: "opcClientRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a bucket in the given namespace with a bucket name and optional user-defined metadata. Avoid entering
   * confidential information in bucket names.
   *
   * @param CreateBucketRequest
   * @return CreateBucketResponse
   * @throws OciError when an error occurs
   */
  public async createBucket(
    createBucketRequest: requests.CreateBucketRequest
  ): Promise<responses.CreateBucketResponse> {
    const pathParams = {
      "{namespaceName}": createBucketRequest.namespaceName
    };

    const queryParams = {};

    let headerParams = {
      "opc-client-request-id": createBucketRequest.opcClientRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/n/{namespaceName}/b",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createBucketRequest.createBucketDetails,
        "CreateBucketDetails",
        models.CreateBucketDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateBucketResponse>{},
        body: await response.json(),
        bodyKey: "bucket",
        bodyModel: "model.Bucket",
        responseHeaders: [
          {
            value: response.headers.get("opc-client-request-id"),
            key: "opcClientRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("ETag"),
            key: "eTag",
            dataType: "string"
          },
          {
            value: response.headers.get("Location"),
            key: "location",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Starts a new multipart upload to a specific object in the given bucket in the given namespace.
   *
   * @param CreateMultipartUploadRequest
   * @return CreateMultipartUploadResponse
   * @throws OciError when an error occurs
   */
  public async createMultipartUpload(
    createMultipartUploadRequest: requests.CreateMultipartUploadRequest
  ): Promise<responses.CreateMultipartUploadResponse> {
    const pathParams = {
      "{namespaceName}": createMultipartUploadRequest.namespaceName,
      "{bucketName}": createMultipartUploadRequest.bucketName
    };

    const queryParams = {};

    let headerParams = {
      "if-match": createMultipartUploadRequest.ifMatch,
      "if-none-match": createMultipartUploadRequest.ifNoneMatch,
      "opc-client-request-id": createMultipartUploadRequest.opcClientRequestId,
      "opc-sse-customer-algorithm": createMultipartUploadRequest.opcSseCustomerAlgorithm,
      "opc-sse-customer-key": createMultipartUploadRequest.opcSseCustomerKey,
      "opc-sse-customer-key-sha256": createMultipartUploadRequest.opcSseCustomerKeySha256
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/n/{namespaceName}/b/{bucketName}/u",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createMultipartUploadRequest.createMultipartUploadDetails,
        "CreateMultipartUploadDetails",
        models.CreateMultipartUploadDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateMultipartUploadResponse>{},
        body: await response.json(),
        bodyKey: "multipartUpload",
        bodyModel: "model.MultipartUpload",
        responseHeaders: [
          {
            value: response.headers.get("opc-client-request-id"),
            key: "opcClientRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("Location"),
            key: "location",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a pre-authenticated request specific to the bucket.
   *
   * @param CreatePreauthenticatedRequestRequest
   * @return CreatePreauthenticatedRequestResponse
   * @throws OciError when an error occurs
   */
  public async createPreauthenticatedRequest(
    createPreauthenticatedRequestRequest: requests.CreatePreauthenticatedRequestRequest
  ): Promise<responses.CreatePreauthenticatedRequestResponse> {
    const pathParams = {
      "{namespaceName}": createPreauthenticatedRequestRequest.namespaceName,
      "{bucketName}": createPreauthenticatedRequestRequest.bucketName
    };

    const queryParams = {};

    let headerParams = {
      "opc-client-request-id": createPreauthenticatedRequestRequest.opcClientRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/n/{namespaceName}/b/{bucketName}/p",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createPreauthenticatedRequestRequest.createPreauthenticatedRequestDetails,
        "CreatePreauthenticatedRequestDetails",
        models.CreatePreauthenticatedRequestDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreatePreauthenticatedRequestResponse>{},
        body: await response.json(),
        bodyKey: "preauthenticatedRequest",
        bodyModel: "model.PreauthenticatedRequest",
        responseHeaders: [
          {
            value: response.headers.get("opc-client-request-id"),
            key: "opcClientRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a replication policy for the specified bucket.
   *
   * @param CreateReplicationPolicyRequest
   * @return CreateReplicationPolicyResponse
   * @throws OciError when an error occurs
   */
  public async createReplicationPolicy(
    createReplicationPolicyRequest: requests.CreateReplicationPolicyRequest
  ): Promise<responses.CreateReplicationPolicyResponse> {
    const pathParams = {
      "{namespaceName}": createReplicationPolicyRequest.namespaceName,
      "{bucketName}": createReplicationPolicyRequest.bucketName
    };

    const queryParams = {};

    let headerParams = {
      "opc-client-request-id": createReplicationPolicyRequest.opcClientRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/n/{namespaceName}/b/{bucketName}/replicationPolicies",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createReplicationPolicyRequest.createReplicationPolicyDetails,
        "CreateReplicationPolicyDetails",
        models.CreateReplicationPolicyDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateReplicationPolicyResponse>{},
        body: await response.json(),
        bodyKey: "replicationPolicy",
        bodyModel: "model.ReplicationPolicy",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-client-request-id"),
            key: "opcClientRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new retention rule in the specified bucket. The new rule will take effect typically within 30 seconds.
   * Note that a maximum of 100 rules are supported on a bucket.
   *
   * @param CreateRetentionRuleRequest
   * @return CreateRetentionRuleResponse
   * @throws OciError when an error occurs
   */
  public async createRetentionRule(
    createRetentionRuleRequest: requests.CreateRetentionRuleRequest
  ): Promise<responses.CreateRetentionRuleResponse> {
    const pathParams = {
      "{namespaceName}": createRetentionRuleRequest.namespaceName,
      "{bucketName}": createRetentionRuleRequest.bucketName
    };

    const queryParams = {};

    let headerParams = {
      "opc-client-request-id": createRetentionRuleRequest.opcClientRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/n/{namespaceName}/b/{bucketName}/retentionRules",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createRetentionRuleRequest.createRetentionRuleDetails,
        "CreateRetentionRuleDetails",
        models.CreateRetentionRuleDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateRetentionRuleResponse>{},
        body: await response.json(),
        bodyKey: "retentionRule",
        bodyModel: "model.RetentionRule",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-client-request-id"),
            key: "opcClientRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Deletes a bucket if the bucket is already empty. If the bucket is not empty, use
   * {@link #deleteObject(DeleteObjectRequest) deleteObject} first. In addition,
   * you cannot delete a bucket that has a multipart upload in progress or a pre-authenticated
   * request associated with that bucket.
   *
   * @param DeleteBucketRequest
   * @return DeleteBucketResponse
   * @throws OciError when an error occurs
   */
  public async deleteBucket(
    deleteBucketRequest: requests.DeleteBucketRequest
  ): Promise<responses.DeleteBucketResponse> {
    const pathParams = {
      "{namespaceName}": deleteBucketRequest.namespaceName,
      "{bucketName}": deleteBucketRequest.bucketName
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteBucketRequest.ifMatch,
      "opc-client-request-id": deleteBucketRequest.opcClientRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/n/{namespaceName}/b/{bucketName}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteBucketResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-client-request-id"),
            key: "opcClientRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Deletes an object.
   *
   * @param DeleteObjectRequest
   * @return DeleteObjectResponse
   * @throws OciError when an error occurs
   */
  public async deleteObject(
    deleteObjectRequest: requests.DeleteObjectRequest
  ): Promise<responses.DeleteObjectResponse> {
    const pathParams = {
      "{namespaceName}": deleteObjectRequest.namespaceName,
      "{bucketName}": deleteObjectRequest.bucketName,
      "{objectName}": deleteObjectRequest.objectName
    };

    const queryParams = {
      "versionId": deleteObjectRequest.versionId
    };

    let headerParams = {
      "if-match": deleteObjectRequest.ifMatch,
      "opc-client-request-id": deleteObjectRequest.opcClientRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/n/{namespaceName}/b/{bucketName}/o/{objectName}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteObjectResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-client-request-id"),
            key: "opcClientRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("last-modified"),
            key: "lastModified",
            dataType: "Date"
          },
          {
            value: response.headers.get("version-id"),
            key: "versionId",
            dataType: "string"
          },
          {
            value: response.headers.get("is-delete-marker"),
            key: "isDeleteMarker",
            dataType: "boolean"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Deletes the object lifecycle policy for the bucket.
   *
   * @param DeleteObjectLifecyclePolicyRequest
   * @return DeleteObjectLifecyclePolicyResponse
   * @throws OciError when an error occurs
   */
  public async deleteObjectLifecyclePolicy(
    deleteObjectLifecyclePolicyRequest: requests.DeleteObjectLifecyclePolicyRequest
  ): Promise<responses.DeleteObjectLifecyclePolicyResponse> {
    const pathParams = {
      "{namespaceName}": deleteObjectLifecyclePolicyRequest.namespaceName,
      "{bucketName}": deleteObjectLifecyclePolicyRequest.bucketName
    };

    const queryParams = {};

    let headerParams = {
      "opc-client-request-id": deleteObjectLifecyclePolicyRequest.opcClientRequestId,
      "if-match": deleteObjectLifecyclePolicyRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/n/{namespaceName}/b/{bucketName}/l",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteObjectLifecyclePolicyResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-client-request-id"),
            key: "opcClientRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Deletes the pre-authenticated request for the bucket.
   * @param DeletePreauthenticatedRequestRequest
   * @return DeletePreauthenticatedRequestResponse
   * @throws OciError when an error occurs
   */
  public async deletePreauthenticatedRequest(
    deletePreauthenticatedRequestRequest: requests.DeletePreauthenticatedRequestRequest
  ): Promise<responses.DeletePreauthenticatedRequestResponse> {
    const pathParams = {
      "{namespaceName}": deletePreauthenticatedRequestRequest.namespaceName,
      "{bucketName}": deletePreauthenticatedRequestRequest.bucketName,
      "{parId}": deletePreauthenticatedRequestRequest.parId
    };

    const queryParams = {};

    let headerParams = {
      "opc-client-request-id": deletePreauthenticatedRequestRequest.opcClientRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/n/{namespaceName}/b/{bucketName}/p/{parId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeletePreauthenticatedRequestResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-client-request-id"),
            key: "opcClientRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Deletes the replication policy associated with the source bucket.
   *
   * @param DeleteReplicationPolicyRequest
   * @return DeleteReplicationPolicyResponse
   * @throws OciError when an error occurs
   */
  public async deleteReplicationPolicy(
    deleteReplicationPolicyRequest: requests.DeleteReplicationPolicyRequest
  ): Promise<responses.DeleteReplicationPolicyResponse> {
    const pathParams = {
      "{namespaceName}": deleteReplicationPolicyRequest.namespaceName,
      "{bucketName}": deleteReplicationPolicyRequest.bucketName,
      "{replicationId}": deleteReplicationPolicyRequest.replicationId
    };

    const queryParams = {};

    let headerParams = {
      "opc-client-request-id": deleteReplicationPolicyRequest.opcClientRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/n/{namespaceName}/b/{bucketName}/replicationPolicies/{replicationId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteReplicationPolicyResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-client-request-id"),
            key: "opcClientRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Deletes the specified rule. The deletion takes effect typically within 30 seconds.
   * @param DeleteRetentionRuleRequest
   * @return DeleteRetentionRuleResponse
   * @throws OciError when an error occurs
   */
  public async deleteRetentionRule(
    deleteRetentionRuleRequest: requests.DeleteRetentionRuleRequest
  ): Promise<responses.DeleteRetentionRuleResponse> {
    const pathParams = {
      "{namespaceName}": deleteRetentionRuleRequest.namespaceName,
      "{bucketName}": deleteRetentionRuleRequest.bucketName,
      "{retentionRuleId}": deleteRetentionRuleRequest.retentionRuleId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteRetentionRuleRequest.ifMatch,
      "opc-client-request-id": deleteRetentionRuleRequest.opcClientRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/n/{namespaceName}/b/{bucketName}/retentionRules/{retentionRuleId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteRetentionRuleResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-client-request-id"),
            key: "opcClientRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the current representation of the given bucket in the given Object Storage namespace.
   *
   * @param GetBucketRequest
   * @return GetBucketResponse
   * @throws OciError when an error occurs
   */
  public async getBucket(
    getBucketRequest: requests.GetBucketRequest
  ): Promise<responses.GetBucketResponse> {
    const pathParams = {
      "{namespaceName}": getBucketRequest.namespaceName,
      "{bucketName}": getBucketRequest.bucketName
    };

    const queryParams = {
      "fields": getBucketRequest.fields
    };

    let headerParams = {
      "if-match": getBucketRequest.ifMatch,
      "if-none-match": getBucketRequest.ifNoneMatch,
      "opc-client-request-id": getBucketRequest.opcClientRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/n/{namespaceName}/b/{bucketName}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetBucketResponse>{},
        body: await response.json(),
        bodyKey: "bucket",
        bodyModel: "model.Bucket",
        responseHeaders: [
          {
            value: response.headers.get("opc-client-request-id"),
            key: "opcClientRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("ETag"),
            key: "eTag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Each Oracle Cloud Infrastructure tenant is assigned one unique and uneditable Object Storage namespace. The namespace
* is a system-generated string assigned during account creation. For some older tenancies, the namespace string may be
* the tenancy name in all lower-case letters. You cannot edit a namespace.
* <p>
GetNamespace returns the name of the Object Storage namespace for the user making the request.
* If an optional compartmentId query parameter is provided, GetNamespace returns the namespace name of the corresponding
* tenancy, provided the user has access to it.
* 
     * @param GetNamespaceRequest
     * @return GetNamespaceResponse
     * @throws OciError when an error occurs
     */
  public async getNamespace(
    getNamespaceRequest: requests.GetNamespaceRequest
  ): Promise<responses.GetNamespaceResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": getNamespaceRequest.compartmentId
    };

    let headerParams = {
      "opc-client-request-id": getNamespaceRequest.opcClientRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/n",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetNamespaceResponse>{},
        body: await response.json(),
        bodyKey: "value",
        bodyModel: "string",
        responseHeaders: []
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Gets the metadata for the Object Storage namespace, which contains defaultS3CompartmentId and
* defaultSwiftCompartmentId.
* <p>
Any user with the OBJECTSTORAGE_NAMESPACE_READ permission will be able to see the current metadata. If you are
* not authorized, talk to an administrator. If you are an administrator who needs to write policies
* to give users access, see
* [Getting Started with Policies](https://docs.cloud.oracle.com/Content/Identity/Concepts/policygetstarted.htm).
* 
     * @param GetNamespaceMetadataRequest
     * @return GetNamespaceMetadataResponse
     * @throws OciError when an error occurs
     */
  public async getNamespaceMetadata(
    getNamespaceMetadataRequest: requests.GetNamespaceMetadataRequest
  ): Promise<responses.GetNamespaceMetadataResponse> {
    const pathParams = {
      "{namespaceName}": getNamespaceMetadataRequest.namespaceName
    };

    const queryParams = {};

    let headerParams = {
      "opc-client-request-id": getNamespaceMetadataRequest.opcClientRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/n/{namespaceName}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetNamespaceMetadataResponse>{},
        body: await response.json(),
        bodyKey: "namespaceMetadata",
        bodyModel: "model.NamespaceMetadata",
        responseHeaders: [
          {
            value: response.headers.get("opc-client-request-id"),
            key: "opcClientRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the metadata and body of an object.
   *
   * @param GetObjectRequest
   * @return GetObjectResponse
   * @throws OciError when an error occurs
   */
  public async getObject(
    getObjectRequest: requests.GetObjectRequest
  ): Promise<responses.GetObjectResponse> {
    const pathParams = {
      "{namespaceName}": getObjectRequest.namespaceName,
      "{bucketName}": getObjectRequest.bucketName,
      "{objectName}": getObjectRequest.objectName
    };

    const queryParams = {
      "versionId": getObjectRequest.versionId
    };

    let headerParams = {
      "if-match": getObjectRequest.ifMatch,
      "if-none-match": getObjectRequest.ifNoneMatch,
      "opc-client-request-id": getObjectRequest.opcClientRequestId,
      "range": getObjectRequest.range,
      "opc-sse-customer-algorithm": getObjectRequest.opcSseCustomerAlgorithm,
      "opc-sse-customer-key": getObjectRequest.opcSseCustomerKey,
      "opc-sse-customer-key-sha256": getObjectRequest.opcSseCustomerKeySha256
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/n/{namespaceName}/b/{bucketName}/o/{objectName}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetObjectResponse>{},

        body: response.body!,
        bodyKey: "value",
        bodyModel: "string",
        responseHeaders: [
          {
            value: response.headers.get("opc-client-request-id"),
            key: "opcClientRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("ETag"),
            key: "eTag",
            dataType: "string"
          },
          {
            value: response.headers.get("content-length"),
            key: "contentLength",
            dataType: "number"
          },
          {
            value: response.headers.get("content-range"),
            key: "contentRange",
            dataType: "common.Range"
          },
          {
            value: response.headers.get("content-md5"),
            key: "contentMd5",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-multipart-md5"),
            key: "opcMultipartMd5",
            dataType: "string"
          },
          {
            value: response.headers.get("content-type"),
            key: "contentType",
            dataType: "string"
          },
          {
            value: response.headers.get("content-language"),
            key: "contentLanguage",
            dataType: "string"
          },
          {
            value: response.headers.get("content-encoding"),
            key: "contentEncoding",
            dataType: "string"
          },
          {
            value: response.headers.get("cache-control"),
            key: "cacheControl",
            dataType: "string"
          },
          {
            value: response.headers.get("content-disposition"),
            key: "contentDisposition",
            dataType: "string"
          },
          {
            value: response.headers.get("last-modified"),
            key: "lastModified",
            dataType: "Date"
          },
          {
            value: response.headers.get("archival-state"),
            key: "archivalState",
            dataType: "string"
          },
          {
            value: response.headers.get("time-of-archival"),
            key: "timeOfArchival",
            dataType: "Date"
          },
          {
            value: response.headers.get("version-id"),
            key: "versionId",
            dataType: "string"
          }
        ]
      });
      const opcMeta = {};
      const pattern: string = "opc-meta-";
      response.headers.forEach((k, v) => {
        if (k.startsWith(pattern)) {
          Object.assign(opcMeta, { k: v });
        }
      });
      sdkResponse.opcMeta = opcMeta;

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the object lifecycle policy for the bucket.
   *
   * @param GetObjectLifecyclePolicyRequest
   * @return GetObjectLifecyclePolicyResponse
   * @throws OciError when an error occurs
   */
  public async getObjectLifecyclePolicy(
    getObjectLifecyclePolicyRequest: requests.GetObjectLifecyclePolicyRequest
  ): Promise<responses.GetObjectLifecyclePolicyResponse> {
    const pathParams = {
      "{namespaceName}": getObjectLifecyclePolicyRequest.namespaceName,
      "{bucketName}": getObjectLifecyclePolicyRequest.bucketName
    };

    const queryParams = {};

    let headerParams = {
      "opc-client-request-id": getObjectLifecyclePolicyRequest.opcClientRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/n/{namespaceName}/b/{bucketName}/l",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetObjectLifecyclePolicyResponse>{},
        body: await response.json(),
        bodyKey: "objectLifecyclePolicy",
        bodyModel: "model.ObjectLifecyclePolicy",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-client-request-id"),
            key: "opcClientRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("ETag"),
            key: "eTag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the pre-authenticated request for the bucket.
   * @param GetPreauthenticatedRequestRequest
   * @return GetPreauthenticatedRequestResponse
   * @throws OciError when an error occurs
   */
  public async getPreauthenticatedRequest(
    getPreauthenticatedRequestRequest: requests.GetPreauthenticatedRequestRequest
  ): Promise<responses.GetPreauthenticatedRequestResponse> {
    const pathParams = {
      "{namespaceName}": getPreauthenticatedRequestRequest.namespaceName,
      "{bucketName}": getPreauthenticatedRequestRequest.bucketName,
      "{parId}": getPreauthenticatedRequestRequest.parId
    };

    const queryParams = {};

    let headerParams = {
      "opc-client-request-id": getPreauthenticatedRequestRequest.opcClientRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/n/{namespaceName}/b/{bucketName}/p/{parId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetPreauthenticatedRequestResponse>{},
        body: await response.json(),
        bodyKey: "preauthenticatedRequestSummary",
        bodyModel: "model.PreauthenticatedRequestSummary",
        responseHeaders: [
          {
            value: response.headers.get("opc-client-request-id"),
            key: "opcClientRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Get the replication policy.
   *
   * @param GetReplicationPolicyRequest
   * @return GetReplicationPolicyResponse
   * @throws OciError when an error occurs
   */
  public async getReplicationPolicy(
    getReplicationPolicyRequest: requests.GetReplicationPolicyRequest
  ): Promise<responses.GetReplicationPolicyResponse> {
    const pathParams = {
      "{namespaceName}": getReplicationPolicyRequest.namespaceName,
      "{bucketName}": getReplicationPolicyRequest.bucketName,
      "{replicationId}": getReplicationPolicyRequest.replicationId
    };

    const queryParams = {};

    let headerParams = {
      "opc-client-request-id": getReplicationPolicyRequest.opcClientRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/n/{namespaceName}/b/{bucketName}/replicationPolicies/{replicationId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetReplicationPolicyResponse>{},
        body: await response.json(),
        bodyKey: "replicationPolicy",
        bodyModel: "model.ReplicationPolicy",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-client-request-id"),
            key: "opcClientRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Get the specified retention rule.
   * @param GetRetentionRuleRequest
   * @return GetRetentionRuleResponse
   * @throws OciError when an error occurs
   */
  public async getRetentionRule(
    getRetentionRuleRequest: requests.GetRetentionRuleRequest
  ): Promise<responses.GetRetentionRuleResponse> {
    const pathParams = {
      "{namespaceName}": getRetentionRuleRequest.namespaceName,
      "{bucketName}": getRetentionRuleRequest.bucketName,
      "{retentionRuleId}": getRetentionRuleRequest.retentionRuleId
    };

    const queryParams = {};

    let headerParams = {
      "opc-client-request-id": getRetentionRuleRequest.opcClientRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/n/{namespaceName}/b/{bucketName}/retentionRules/{retentionRuleId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetRetentionRuleResponse>{},
        body: await response.json(),
        bodyKey: "retentionRule",
        bodyModel: "model.RetentionRule",
        responseHeaders: [
          {
            value: response.headers.get("opc-client-request-id"),
            key: "opcClientRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("last-modified"),
            key: "lastModified",
            dataType: "Date"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the status of the work request for the given ID.
   * @param GetWorkRequestRequest
   * @return GetWorkRequestResponse
   * @throws OciError when an error occurs
   */
  public async getWorkRequest(
    getWorkRequestRequest: requests.GetWorkRequestRequest
  ): Promise<responses.GetWorkRequestResponse> {
    const pathParams = {
      "{workRequestId}": getWorkRequestRequest.workRequestId
    };

    const queryParams = {};

    let headerParams = {
      "opc-client-request-id": getWorkRequestRequest.opcClientRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workRequests/{workRequestId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetWorkRequestResponse>{},
        body: await response.json(),
        bodyKey: "workRequest",
        bodyModel: "model.WorkRequest",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-client-request-id"),
            key: "opcClientRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("retry-after"),
            key: "retryAfter",
            dataType: "number"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Efficiently checks to see if a bucket exists and gets the current entity tag (ETag) for the bucket.
   *
   * @param HeadBucketRequest
   * @return HeadBucketResponse
   * @throws OciError when an error occurs
   */
  public async headBucket(
    headBucketRequest: requests.HeadBucketRequest
  ): Promise<responses.HeadBucketResponse> {
    const pathParams = {
      "{namespaceName}": headBucketRequest.namespaceName,
      "{bucketName}": headBucketRequest.bucketName
    };

    const queryParams = {};

    let headerParams = {
      "if-match": headBucketRequest.ifMatch,
      "if-none-match": headBucketRequest.ifNoneMatch,
      "opc-client-request-id": headBucketRequest.opcClientRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/n/{namespaceName}/b/{bucketName}",
      method: "HEAD",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.HeadBucketResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-client-request-id"),
            key: "opcClientRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("ETag"),
            key: "eTag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the user-defined metadata and entity tag (ETag) for an object.
   *
   * @param HeadObjectRequest
   * @return HeadObjectResponse
   * @throws OciError when an error occurs
   */
  public async headObject(
    headObjectRequest: requests.HeadObjectRequest
  ): Promise<responses.HeadObjectResponse> {
    const pathParams = {
      "{namespaceName}": headObjectRequest.namespaceName,
      "{bucketName}": headObjectRequest.bucketName,
      "{objectName}": headObjectRequest.objectName
    };

    const queryParams = {
      "versionId": headObjectRequest.versionId
    };

    let headerParams = {
      "if-match": headObjectRequest.ifMatch,
      "if-none-match": headObjectRequest.ifNoneMatch,
      "opc-client-request-id": headObjectRequest.opcClientRequestId,
      "opc-sse-customer-algorithm": headObjectRequest.opcSseCustomerAlgorithm,
      "opc-sse-customer-key": headObjectRequest.opcSseCustomerKey,
      "opc-sse-customer-key-sha256": headObjectRequest.opcSseCustomerKeySha256
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/n/{namespaceName}/b/{bucketName}/o/{objectName}",
      method: "HEAD",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.HeadObjectResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-client-request-id"),
            key: "opcClientRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("ETag"),
            key: "eTag",
            dataType: "string"
          },
          {
            value: response.headers.get("content-length"),
            key: "contentLength",
            dataType: "number"
          },
          {
            value: response.headers.get("content-md5"),
            key: "contentMd5",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-multipart-md5"),
            key: "opcMultipartMd5",
            dataType: "string"
          },
          {
            value: response.headers.get("content-type"),
            key: "contentType",
            dataType: "string"
          },
          {
            value: response.headers.get("content-language"),
            key: "contentLanguage",
            dataType: "string"
          },
          {
            value: response.headers.get("content-encoding"),
            key: "contentEncoding",
            dataType: "string"
          },
          {
            value: response.headers.get("cache-control"),
            key: "cacheControl",
            dataType: "string"
          },
          {
            value: response.headers.get("content-disposition"),
            key: "contentDisposition",
            dataType: "string"
          },
          {
            value: response.headers.get("last-modified"),
            key: "lastModified",
            dataType: "Date"
          },
          {
            value: response.headers.get("archival-state"),
            key: "archivalState",
            dataType: "string"
          },
          {
            value: response.headers.get("time-of-archival"),
            key: "timeOfArchival",
            dataType: "Date"
          },
          {
            value: response.headers.get("version-id"),
            key: "versionId",
            dataType: "string"
          }
        ]
      });
      const opcMeta = {};
      const pattern: string = "opc-meta-";
      response.headers.forEach((k, v) => {
        if (k.startsWith(pattern)) {
          Object.assign(opcMeta, { k: v });
        }
      });
      sdkResponse.opcMeta = opcMeta;

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Gets a list of all BucketSummary items in a compartment. A BucketSummary contains only summary fields for the bucket
* and does not contain fields like the user-defined metadata.
* <p>
To use this and other API operations, you must be authorized in an IAM policy. If you are not authorized,
* talk to an administrator. If you are an administrator who needs to write policies to give users access, see
* [Getting Started with Policies](https://docs.cloud.oracle.com/Content/Identity/Concepts/policygetstarted.htm).
* 
     * @param ListBucketsRequest
     * @return ListBucketsResponse
     * @throws OciError when an error occurs
     */
  public async listBuckets(
    listBucketsRequest: requests.ListBucketsRequest
  ): Promise<responses.ListBucketsResponse> {
    const pathParams = {
      "{namespaceName}": listBucketsRequest.namespaceName
    };

    const queryParams = {
      "compartmentId": listBucketsRequest.compartmentId,
      "limit": listBucketsRequest.limit,
      "page": listBucketsRequest.page,
      "fields": listBucketsRequest.fields
    };

    let headerParams = {
      "opc-client-request-id": listBucketsRequest.opcClientRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/n/{namespaceName}/b",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListBucketsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "BucketSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-client-request-id"),
            key: "opcClientRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.BucketSummary objects
   * contained in responses from the listBuckets operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllBuckets(
    request: requests.ListBucketsRequest
  ): AsyncIterableIterator<models.BucketSummary> {
    return paginateRecords(request, req => this.listBuckets(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listBuckets operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllBucketsResponses(
    request: requests.ListBucketsRequest
  ): AsyncIterableIterator<responses.ListBucketsResponse> {
    return paginateResponses(request, req => this.listBuckets(req));
  }

  /**
   * Lists the parts of an in-progress multipart upload.
   *
   * @param ListMultipartUploadPartsRequest
   * @return ListMultipartUploadPartsResponse
   * @throws OciError when an error occurs
   */
  public async listMultipartUploadParts(
    listMultipartUploadPartsRequest: requests.ListMultipartUploadPartsRequest
  ): Promise<responses.ListMultipartUploadPartsResponse> {
    const pathParams = {
      "{namespaceName}": listMultipartUploadPartsRequest.namespaceName,
      "{bucketName}": listMultipartUploadPartsRequest.bucketName,
      "{objectName}": listMultipartUploadPartsRequest.objectName
    };

    const queryParams = {
      "uploadId": listMultipartUploadPartsRequest.uploadId,
      "limit": listMultipartUploadPartsRequest.limit,
      "page": listMultipartUploadPartsRequest.page
    };

    let headerParams = {
      "opc-client-request-id": listMultipartUploadPartsRequest.opcClientRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/n/{namespaceName}/b/{bucketName}/u/{objectName}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListMultipartUploadPartsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "MultipartUploadPartSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-client-request-id"),
            key: "opcClientRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.MultipartUploadPartSummary objects
   * contained in responses from the listMultipartUploadParts operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllMultipartUploadParts(
    request: requests.ListMultipartUploadPartsRequest
  ): AsyncIterableIterator<models.MultipartUploadPartSummary> {
    return paginateRecords(request, req => this.listMultipartUploadParts(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listMultipartUploadParts operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllMultipartUploadPartsResponses(
    request: requests.ListMultipartUploadPartsRequest
  ): AsyncIterableIterator<responses.ListMultipartUploadPartsResponse> {
    return paginateResponses(request, req => this.listMultipartUploadParts(req));
  }

  /**
   * Lists all of the in-progress multipart uploads for the given bucket in the given Object Storage namespace.
   *
   * @param ListMultipartUploadsRequest
   * @return ListMultipartUploadsResponse
   * @throws OciError when an error occurs
   */
  public async listMultipartUploads(
    listMultipartUploadsRequest: requests.ListMultipartUploadsRequest
  ): Promise<responses.ListMultipartUploadsResponse> {
    const pathParams = {
      "{namespaceName}": listMultipartUploadsRequest.namespaceName,
      "{bucketName}": listMultipartUploadsRequest.bucketName
    };

    const queryParams = {
      "limit": listMultipartUploadsRequest.limit,
      "page": listMultipartUploadsRequest.page
    };

    let headerParams = {
      "opc-client-request-id": listMultipartUploadsRequest.opcClientRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/n/{namespaceName}/b/{bucketName}/u",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListMultipartUploadsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "MultipartUpload[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-client-request-id"),
            key: "opcClientRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.MultipartUpload objects
   * contained in responses from the listMultipartUploads operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllMultipartUploads(
    request: requests.ListMultipartUploadsRequest
  ): AsyncIterableIterator<models.MultipartUpload> {
    return paginateRecords(request, req => this.listMultipartUploads(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listMultipartUploads operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllMultipartUploadsResponses(
    request: requests.ListMultipartUploadsRequest
  ): AsyncIterableIterator<responses.ListMultipartUploadsResponse> {
    return paginateResponses(request, req => this.listMultipartUploads(req));
  }

  /**
     * Lists the object versions in a bucket.
* <p>
To use this and other API operations, you must be authorized in an IAM policy. If you are not authorized,
* talk to an administrator. If you are an administrator who needs to write policies to give users access, see
* [Getting Started with Policies](https://docs.cloud.oracle.com/Content/Identity/Concepts/policygetstarted.htm).
* 
     * @param ListObjectVersionsRequest
     * @return ListObjectVersionsResponse
     * @throws OciError when an error occurs
     */
  public async listObjectVersions(
    listObjectVersionsRequest: requests.ListObjectVersionsRequest
  ): Promise<responses.ListObjectVersionsResponse> {
    const pathParams = {
      "{namespaceName}": listObjectVersionsRequest.namespaceName,
      "{bucketName}": listObjectVersionsRequest.bucketName
    };

    const queryParams = {
      "prefix": listObjectVersionsRequest.prefix,
      "start": listObjectVersionsRequest.start,
      "end": listObjectVersionsRequest.end,
      "limit": listObjectVersionsRequest.limit,
      "delimiter": listObjectVersionsRequest.delimiter,
      "fields": listObjectVersionsRequest.fields,
      "startAfter": listObjectVersionsRequest.startAfter,
      "page": listObjectVersionsRequest.page
    };

    let headerParams = {
      "opc-client-request-id": listObjectVersionsRequest.opcClientRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/n/{namespaceName}/b/{bucketName}/objectversions",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListObjectVersionsResponse>{},
        body: await response.json(),
        bodyKey: "objectVersionCollection",
        bodyModel: "model.ObjectVersionCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-client-request-id"),
            key: "opcClientRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Lists the objects in a bucket.
* <p>
To use this and other API operations, you must be authorized in an IAM policy. If you are not authorized,
* talk to an administrator. If you are an administrator who needs to write policies to give users access, see
* [Getting Started with Policies](https://docs.cloud.oracle.com/Content/Identity/Concepts/policygetstarted.htm).
* 
     * @param ListObjectsRequest
     * @return ListObjectsResponse
     * @throws OciError when an error occurs
     */
  public async listObjects(
    listObjectsRequest: requests.ListObjectsRequest
  ): Promise<responses.ListObjectsResponse> {
    const pathParams = {
      "{namespaceName}": listObjectsRequest.namespaceName,
      "{bucketName}": listObjectsRequest.bucketName
    };

    const queryParams = {
      "prefix": listObjectsRequest.prefix,
      "start": listObjectsRequest.start,
      "end": listObjectsRequest.end,
      "limit": listObjectsRequest.limit,
      "delimiter": listObjectsRequest.delimiter,
      "fields": listObjectsRequest.fields,
      "startAfter": listObjectsRequest.startAfter
    };

    let headerParams = {
      "opc-client-request-id": listObjectsRequest.opcClientRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/n/{namespaceName}/b/{bucketName}/o",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListObjectsResponse>{},
        body: await response.json(),
        bodyKey: "listObjects",
        bodyModel: "model.ListObjects",
        responseHeaders: [
          {
            value: response.headers.get("opc-client-request-id"),
            key: "opcClientRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.ObjectSummary objects
   * contained in responses from the listObjects operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllObjects(
    request: requests.ListObjectsRequest
  ): AsyncIterableIterator<models.ObjectSummary> {
    return genericPaginateRecords(
      request,
      req => this.listObjects(req),
      res => res.listObjects.nextStartWith,
      (req, nextPageToken) => (req.start = nextPageToken),
      res => res.listObjects.objects
    );
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listObjects operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllObjectsResponses(
    request: requests.ListObjectsRequest
  ): AsyncIterableIterator<responses.ListObjectsResponse> {
    return genericPaginateResponses(
      request,
      req => this.listObjects(req),
      res => res.listObjects.nextStartWith,
      (req, nextPageToken) => (req.start = nextPageToken)
    );
  }

  /**
   * Lists pre-authenticated requests for the bucket.
   *
   * @param ListPreauthenticatedRequestsRequest
   * @return ListPreauthenticatedRequestsResponse
   * @throws OciError when an error occurs
   */
  public async listPreauthenticatedRequests(
    listPreauthenticatedRequestsRequest: requests.ListPreauthenticatedRequestsRequest
  ): Promise<responses.ListPreauthenticatedRequestsResponse> {
    const pathParams = {
      "{namespaceName}": listPreauthenticatedRequestsRequest.namespaceName,
      "{bucketName}": listPreauthenticatedRequestsRequest.bucketName
    };

    const queryParams = {
      "objectNamePrefix": listPreauthenticatedRequestsRequest.objectNamePrefix,
      "limit": listPreauthenticatedRequestsRequest.limit,
      "page": listPreauthenticatedRequestsRequest.page
    };

    let headerParams = {
      "opc-client-request-id": listPreauthenticatedRequestsRequest.opcClientRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/n/{namespaceName}/b/{bucketName}/p",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListPreauthenticatedRequestsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "PreauthenticatedRequestSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-client-request-id"),
            key: "opcClientRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.PreauthenticatedRequestSummary objects
   * contained in responses from the listPreauthenticatedRequests operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllPreauthenticatedRequests(
    request: requests.ListPreauthenticatedRequestsRequest
  ): AsyncIterableIterator<models.PreauthenticatedRequestSummary> {
    return paginateRecords(request, req => this.listPreauthenticatedRequests(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listPreauthenticatedRequests operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllPreauthenticatedRequestsResponses(
    request: requests.ListPreauthenticatedRequestsRequest
  ): AsyncIterableIterator<responses.ListPreauthenticatedRequestsResponse> {
    return paginateResponses(request, req => this.listPreauthenticatedRequests(req));
  }

  /**
   * List the replication policies associated with a bucket.
   *
   * @param ListReplicationPoliciesRequest
   * @return ListReplicationPoliciesResponse
   * @throws OciError when an error occurs
   */
  public async listReplicationPolicies(
    listReplicationPoliciesRequest: requests.ListReplicationPoliciesRequest
  ): Promise<responses.ListReplicationPoliciesResponse> {
    const pathParams = {
      "{namespaceName}": listReplicationPoliciesRequest.namespaceName,
      "{bucketName}": listReplicationPoliciesRequest.bucketName
    };

    const queryParams = {
      "page": listReplicationPoliciesRequest.page,
      "limit": listReplicationPoliciesRequest.limit
    };

    let headerParams = {
      "opc-client-request-id": listReplicationPoliciesRequest.opcClientRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/n/{namespaceName}/b/{bucketName}/replicationPolicies",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListReplicationPoliciesResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "ReplicationPolicySummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-client-request-id"),
            key: "opcClientRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.ReplicationPolicySummary objects
   * contained in responses from the listReplicationPolicies operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllReplicationPolicies(
    request: requests.ListReplicationPoliciesRequest
  ): AsyncIterableIterator<models.ReplicationPolicySummary> {
    return paginateRecords(request, req => this.listReplicationPolicies(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listReplicationPolicies operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllReplicationPoliciesResponses(
    request: requests.ListReplicationPoliciesRequest
  ): AsyncIterableIterator<responses.ListReplicationPoliciesResponse> {
    return paginateResponses(request, req => this.listReplicationPolicies(req));
  }

  /**
   * List the replication sources of a destination bucket.
   *
   * @param ListReplicationSourcesRequest
   * @return ListReplicationSourcesResponse
   * @throws OciError when an error occurs
   */
  public async listReplicationSources(
    listReplicationSourcesRequest: requests.ListReplicationSourcesRequest
  ): Promise<responses.ListReplicationSourcesResponse> {
    const pathParams = {
      "{namespaceName}": listReplicationSourcesRequest.namespaceName,
      "{bucketName}": listReplicationSourcesRequest.bucketName
    };

    const queryParams = {
      "page": listReplicationSourcesRequest.page,
      "limit": listReplicationSourcesRequest.limit
    };

    let headerParams = {
      "opc-client-request-id": listReplicationSourcesRequest.opcClientRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/n/{namespaceName}/b/{bucketName}/replicationSources",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListReplicationSourcesResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "ReplicationSource[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-client-request-id"),
            key: "opcClientRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.ReplicationSource objects
   * contained in responses from the listReplicationSources operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllReplicationSources(
    request: requests.ListReplicationSourcesRequest
  ): AsyncIterableIterator<models.ReplicationSource> {
    return paginateRecords(request, req => this.listReplicationSources(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listReplicationSources operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllReplicationSourcesResponses(
    request: requests.ListReplicationSourcesRequest
  ): AsyncIterableIterator<responses.ListReplicationSourcesResponse> {
    return paginateResponses(request, req => this.listReplicationSources(req));
  }

  /**
   * List the retention rules for a bucket. The retention rules are sorted based on creation time,
   * with the most recently created retention rule returned first.
   *
   * @param ListRetentionRulesRequest
   * @return ListRetentionRulesResponse
   * @throws OciError when an error occurs
   */
  public async listRetentionRules(
    listRetentionRulesRequest: requests.ListRetentionRulesRequest
  ): Promise<responses.ListRetentionRulesResponse> {
    const pathParams = {
      "{namespaceName}": listRetentionRulesRequest.namespaceName,
      "{bucketName}": listRetentionRulesRequest.bucketName
    };

    const queryParams = {
      "page": listRetentionRulesRequest.page
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/n/{namespaceName}/b/{bucketName}/retentionRules",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListRetentionRulesResponse>{},
        body: await response.json(),
        bodyKey: "retentionRuleCollection",
        bodyModel: "model.RetentionRuleCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-client-request-id"),
            key: "opcClientRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Lists the errors of the work request with the given ID.
   * @param ListWorkRequestErrorsRequest
   * @return ListWorkRequestErrorsResponse
   * @throws OciError when an error occurs
   */
  public async listWorkRequestErrors(
    listWorkRequestErrorsRequest: requests.ListWorkRequestErrorsRequest
  ): Promise<responses.ListWorkRequestErrorsResponse> {
    const pathParams = {
      "{workRequestId}": listWorkRequestErrorsRequest.workRequestId
    };

    const queryParams = {
      "page": listWorkRequestErrorsRequest.page,
      "limit": listWorkRequestErrorsRequest.limit
    };

    let headerParams = {
      "opc-client-request-id": listWorkRequestErrorsRequest.opcClientRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workRequests/{workRequestId}/errors",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListWorkRequestErrorsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "WorkRequestError[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-client-request-id"),
            key: "opcClientRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.WorkRequestError objects
   * contained in responses from the listWorkRequestErrors operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllWorkRequestErrors(
    request: requests.ListWorkRequestErrorsRequest
  ): AsyncIterableIterator<models.WorkRequestError> {
    return paginateRecords(request, req => this.listWorkRequestErrors(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listWorkRequestErrors operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllWorkRequestErrorsResponses(
    request: requests.ListWorkRequestErrorsRequest
  ): AsyncIterableIterator<responses.ListWorkRequestErrorsResponse> {
    return paginateResponses(request, req => this.listWorkRequestErrors(req));
  }

  /**
   * Lists the logs of the work request with the given ID.
   * @param ListWorkRequestLogsRequest
   * @return ListWorkRequestLogsResponse
   * @throws OciError when an error occurs
   */
  public async listWorkRequestLogs(
    listWorkRequestLogsRequest: requests.ListWorkRequestLogsRequest
  ): Promise<responses.ListWorkRequestLogsResponse> {
    const pathParams = {
      "{workRequestId}": listWorkRequestLogsRequest.workRequestId
    };

    const queryParams = {
      "page": listWorkRequestLogsRequest.page,
      "limit": listWorkRequestLogsRequest.limit
    };

    let headerParams = {
      "opc-client-request-id": listWorkRequestLogsRequest.opcClientRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workRequests/{workRequestId}/logs",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListWorkRequestLogsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "WorkRequestLogEntry[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-client-request-id"),
            key: "opcClientRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.WorkRequestLogEntry objects
   * contained in responses from the listWorkRequestLogs operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllWorkRequestLogs(
    request: requests.ListWorkRequestLogsRequest
  ): AsyncIterableIterator<models.WorkRequestLogEntry> {
    return paginateRecords(request, req => this.listWorkRequestLogs(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listWorkRequestLogs operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllWorkRequestLogsResponses(
    request: requests.ListWorkRequestLogsRequest
  ): AsyncIterableIterator<responses.ListWorkRequestLogsResponse> {
    return paginateResponses(request, req => this.listWorkRequestLogs(req));
  }

  /**
   * Lists the work requests in a compartment.
   *
   * @param ListWorkRequestsRequest
   * @return ListWorkRequestsResponse
   * @throws OciError when an error occurs
   */
  public async listWorkRequests(
    listWorkRequestsRequest: requests.ListWorkRequestsRequest
  ): Promise<responses.ListWorkRequestsResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listWorkRequestsRequest.compartmentId,
      "page": listWorkRequestsRequest.page,
      "limit": listWorkRequestsRequest.limit
    };

    let headerParams = {
      "opc-client-request-id": listWorkRequestsRequest.opcClientRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workRequests",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListWorkRequestsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "WorkRequestSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-client-request-id"),
            key: "opcClientRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.WorkRequestSummary objects
   * contained in responses from the listWorkRequests operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllWorkRequests(
    request: requests.ListWorkRequestsRequest
  ): AsyncIterableIterator<models.WorkRequestSummary> {
    return paginateRecords(request, req => this.listWorkRequests(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listWorkRequests operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllWorkRequestsResponses(
    request: requests.ListWorkRequestsRequest
  ): AsyncIterableIterator<responses.ListWorkRequestsResponse> {
    return paginateResponses(request, req => this.listWorkRequests(req));
  }

  /**
   * Stops replication to the destination bucket and removes the replication policy. When the replication
   * policy was created, this destination bucket became read-only except for new and changed objects replicated
   * automatically from the source bucket. MakeBucketWritable removes the replication policy. This bucket is no
   * longer the target for replication and is now writable, allowing users to make changes to bucket contents.
   *
   * @param MakeBucketWritableRequest
   * @return MakeBucketWritableResponse
   * @throws OciError when an error occurs
   */
  public async makeBucketWritable(
    makeBucketWritableRequest: requests.MakeBucketWritableRequest
  ): Promise<responses.MakeBucketWritableResponse> {
    const pathParams = {
      "{namespaceName}": makeBucketWritableRequest.namespaceName,
      "{bucketName}": makeBucketWritableRequest.bucketName
    };

    const queryParams = {};

    let headerParams = {
      "opc-client-request-id": makeBucketWritableRequest.opcClientRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/n/{namespaceName}/b/{bucketName}/actions/makeBucketWritable",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.MakeBucketWritableResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-client-request-id"),
            key: "opcClientRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Creates a new object or overwrites an existing object with the same name. The maximum object size allowed by
* PutObject is 50 GiB.
* <p>
See [Special Instructions for Object Storage PUT](https://docs.cloud.oracle.com/Content/API/Concepts/signingrequests.htm#ObjectStoragePut)
* for request signature requirements.
* 
     * @param PutObjectRequest
     * @return PutObjectResponse
     * @throws OciError when an error occurs
     */
  public async putObject(
    putObjectRequest: requests.PutObjectRequest
  ): Promise<responses.PutObjectResponse> {
    const pathParams = {
      "{namespaceName}": putObjectRequest.namespaceName,
      "{bucketName}": putObjectRequest.bucketName,
      "{objectName}": putObjectRequest.objectName
    };

    const queryParams = {};

    let headerParams = {
      "if-match": putObjectRequest.ifMatch,
      "if-none-match": putObjectRequest.ifNoneMatch,
      "opc-client-request-id": putObjectRequest.opcClientRequestId,
      "Expect": putObjectRequest.expect,
      "Content-Length": putObjectRequest.contentLength,
      "Content-MD5": putObjectRequest.contentMD5,
      "Content-Type": putObjectRequest.contentType,
      "Content-Language": putObjectRequest.contentLanguage,
      "Content-Encoding": putObjectRequest.contentEncoding,
      "Content-Disposition": putObjectRequest.contentDisposition,
      "Cache-Control": putObjectRequest.cacheControl,
      "opc-sse-customer-algorithm": putObjectRequest.opcSseCustomerAlgorithm,
      "opc-sse-customer-key": putObjectRequest.opcSseCustomerKey,
      "opc-sse-customer-key-sha256": putObjectRequest.opcSseCustomerKeySha256
    };

    if (putObjectRequest.opcMeta) {
      Object.entries(putObjectRequest.opcMeta).forEach(([key, value]) => {
        Object.assign(headerParams, { ["opc-meta-" + key]: value });
      });
    }
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/n/{namespaceName}/b/{bucketName}/o/{objectName}",
      method: "PUT",
      bodyContent: putObjectRequest.putObjectBody,
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request, true);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.PutObjectResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-client-request-id"),
            key: "opcClientRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-content-md5"),
            key: "opcContentMd5",
            dataType: "string"
          },
          {
            value: response.headers.get("ETag"),
            key: "eTag",
            dataType: "string"
          },
          {
            value: response.headers.get("last-modified"),
            key: "lastModified",
            dataType: "Date"
          },
          {
            value: response.headers.get("version-id"),
            key: "versionId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates or replaces the object lifecycle policy for the bucket.
   *
   * @param PutObjectLifecyclePolicyRequest
   * @return PutObjectLifecyclePolicyResponse
   * @throws OciError when an error occurs
   */
  public async putObjectLifecyclePolicy(
    putObjectLifecyclePolicyRequest: requests.PutObjectLifecyclePolicyRequest
  ): Promise<responses.PutObjectLifecyclePolicyResponse> {
    const pathParams = {
      "{namespaceName}": putObjectLifecyclePolicyRequest.namespaceName,
      "{bucketName}": putObjectLifecyclePolicyRequest.bucketName
    };

    const queryParams = {};

    let headerParams = {
      "opc-client-request-id": putObjectLifecyclePolicyRequest.opcClientRequestId,
      "if-match": putObjectLifecyclePolicyRequest.ifMatch,
      "if-none-match": putObjectLifecyclePolicyRequest.ifNoneMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/n/{namespaceName}/b/{bucketName}/l",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        putObjectLifecyclePolicyRequest.putObjectLifecyclePolicyDetails,
        "PutObjectLifecyclePolicyDetails",
        models.PutObjectLifecyclePolicyDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.PutObjectLifecyclePolicyResponse>{},
        body: await response.json(),
        bodyKey: "objectLifecyclePolicy",
        bodyModel: "model.ObjectLifecyclePolicy",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-client-request-id"),
            key: "opcClientRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("ETag"),
            key: "eTag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Re-encrypts the unique data encryption key that encrypts each object written to the bucket by using the most recent 
* version of the master encryption key assigned to the bucket. (All data encryption keys are encrypted by a master 
* encryption key. Master encryption keys are assigned to buckets and managed by Oracle by default, but you can assign 
* a key that you created and control through the Oracle Cloud Infrastructure Key Management service.) The kmsKeyId property 
* of the bucket determines which master encryption key is assigned to the bucket. If you assigned a different Key Management 
* master encryption key to the bucket, you can call this API to re-encrypt all data encryption keys with the newly 
* assigned key. Similarly, you might want to re-encrypt all data encryption keys if the assigned key has been rotated to 
* a new key version since objects were last added to the bucket. If you call this API and there is no kmsKeyId associated 
* with the bucket, the call will fail.
* <p>
Calling this API starts a work request task to re-encrypt the data encryption key of all objects in the bucket. Only 
* objects created before the time of the API call will be re-encrypted. The call can take a long time, depending on how many 
* objects are in the bucket and how big they are. This API returns a work request ID that you can use to retrieve the status 
* of the work request task.
* All the versions of objects will be re-encrypted whether versioning is enabled or suspended at the bucket.
* 
     * @param ReencryptBucketRequest
     * @return ReencryptBucketResponse
     * @throws OciError when an error occurs
     */
  public async reencryptBucket(
    reencryptBucketRequest: requests.ReencryptBucketRequest
  ): Promise<responses.ReencryptBucketResponse> {
    const pathParams = {
      "{namespaceName}": reencryptBucketRequest.namespaceName,
      "{bucketName}": reencryptBucketRequest.bucketName
    };

    const queryParams = {};

    let headerParams = {
      "opc-client-request-id": reencryptBucketRequest.opcClientRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/n/{namespaceName}/b/{bucketName}/actions/reencrypt",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ReencryptBucketResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-client-request-id"),
            key: "opcClientRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Rename an object in the given Object Storage namespace.
   *
   * @param RenameObjectRequest
   * @return RenameObjectResponse
   * @throws OciError when an error occurs
   */
  public async renameObject(
    renameObjectRequest: requests.RenameObjectRequest
  ): Promise<responses.RenameObjectResponse> {
    const pathParams = {
      "{namespaceName}": renameObjectRequest.namespaceName,
      "{bucketName}": renameObjectRequest.bucketName
    };

    const queryParams = {};

    let headerParams = {
      "opc-client-request-id": renameObjectRequest.opcClientRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/n/{namespaceName}/b/{bucketName}/actions/renameObject",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        renameObjectRequest.renameObjectDetails,
        "RenameObjectDetails",
        models.RenameObjectDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.RenameObjectResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-client-request-id"),
            key: "opcClientRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("ETag"),
            key: "eTag",
            dataType: "string"
          },
          {
            value: response.headers.get("last-modified"),
            key: "lastModified",
            dataType: "Date"
          },
          {
            value: response.headers.get("version-id"),
            key: "versionId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Restores one or more objects specified by the objectName parameter.
   * By default objects will be restored for 24 hours. Duration can be configured using the hours parameter.
   *
   * @param RestoreObjectsRequest
   * @return RestoreObjectsResponse
   * @throws OciError when an error occurs
   */
  public async restoreObjects(
    restoreObjectsRequest: requests.RestoreObjectsRequest
  ): Promise<responses.RestoreObjectsResponse> {
    const pathParams = {
      "{namespaceName}": restoreObjectsRequest.namespaceName,
      "{bucketName}": restoreObjectsRequest.bucketName
    };

    const queryParams = {};

    let headerParams = {
      "opc-client-request-id": restoreObjectsRequest.opcClientRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/n/{namespaceName}/b/{bucketName}/actions/restoreObjects",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        restoreObjectsRequest.restoreObjectsDetails,
        "RestoreObjectsDetails",
        models.RestoreObjectsDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.RestoreObjectsResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-client-request-id"),
            key: "opcClientRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Performs a partial or full update of a bucket's user-defined metadata.
* <p>
Use UpdateBucket to move a bucket from one compartment to another within the same tenancy. Supply the compartmentID
* of the compartment that you want to move the bucket to. For more information about moving resources between compartments,
* see [Moving Resources to a Different Compartment](https://docs.cloud.oracle.com/iaas/Content/Identity/Tasks/managingcompartments.htm#moveRes).
* 
     * @param UpdateBucketRequest
     * @return UpdateBucketResponse
     * @throws OciError when an error occurs
     */
  public async updateBucket(
    updateBucketRequest: requests.UpdateBucketRequest
  ): Promise<responses.UpdateBucketResponse> {
    const pathParams = {
      "{namespaceName}": updateBucketRequest.namespaceName,
      "{bucketName}": updateBucketRequest.bucketName
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateBucketRequest.ifMatch,
      "opc-client-request-id": updateBucketRequest.opcClientRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/n/{namespaceName}/b/{bucketName}",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        updateBucketRequest.updateBucketDetails,
        "UpdateBucketDetails",
        models.UpdateBucketDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateBucketResponse>{},
        body: await response.json(),
        bodyKey: "bucket",
        bodyModel: "model.Bucket",
        responseHeaders: [
          {
            value: response.headers.get("opc-client-request-id"),
            key: "opcClientRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("ETag"),
            key: "eTag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * By default, buckets created using the Amazon S3 Compatibility API or the Swift API are created in the root
* compartment of the Oracle Cloud Infrastructure tenancy.
* <p>
You can change the default Swift/Amazon S3 compartmentId designation to a different compartmentId. All
* subsequent bucket creations will use the new default compartment, but no previously created
* buckets will be modified. A user must have OBJECTSTORAGE_NAMESPACE_UPDATE permission to make changes to the default
* compartments for Amazon S3 and Swift.
* 
     * @param UpdateNamespaceMetadataRequest
     * @return UpdateNamespaceMetadataResponse
     * @throws OciError when an error occurs
     */
  public async updateNamespaceMetadata(
    updateNamespaceMetadataRequest: requests.UpdateNamespaceMetadataRequest
  ): Promise<responses.UpdateNamespaceMetadataResponse> {
    const pathParams = {
      "{namespaceName}": updateNamespaceMetadataRequest.namespaceName
    };

    const queryParams = {};

    let headerParams = {
      "opc-client-request-id": updateNamespaceMetadataRequest.opcClientRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/n/{namespaceName}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateNamespaceMetadataRequest.updateNamespaceMetadataDetails,
        "UpdateNamespaceMetadataDetails",
        models.UpdateNamespaceMetadataDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateNamespaceMetadataResponse>{},
        body: await response.json(),
        bodyKey: "namespaceMetadata",
        bodyModel: "model.NamespaceMetadata",
        responseHeaders: [
          {
            value: response.headers.get("opc-client-request-id"),
            key: "opcClientRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates the specified retention rule. Rule changes take effect typically within 30 seconds.
   *
   * @param UpdateRetentionRuleRequest
   * @return UpdateRetentionRuleResponse
   * @throws OciError when an error occurs
   */
  public async updateRetentionRule(
    updateRetentionRuleRequest: requests.UpdateRetentionRuleRequest
  ): Promise<responses.UpdateRetentionRuleResponse> {
    const pathParams = {
      "{namespaceName}": updateRetentionRuleRequest.namespaceName,
      "{bucketName}": updateRetentionRuleRequest.bucketName,
      "{retentionRuleId}": updateRetentionRuleRequest.retentionRuleId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateRetentionRuleRequest.ifMatch,
      "opc-client-request-id": updateRetentionRuleRequest.opcClientRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/n/{namespaceName}/b/{bucketName}/retentionRules/{retentionRuleId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateRetentionRuleRequest.updateRetentionRuleDetails,
        "UpdateRetentionRuleDetails",
        models.UpdateRetentionRuleDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateRetentionRuleResponse>{},
        body: await response.json(),
        bodyKey: "retentionRule",
        bodyModel: "model.RetentionRule",
        responseHeaders: [
          {
            value: response.headers.get("opc-client-request-id"),
            key: "opcClientRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Uploads a single part of a multipart upload.
   *
   * @param UploadPartRequest
   * @return UploadPartResponse
   * @throws OciError when an error occurs
   */
  public async uploadPart(
    uploadPartRequest: requests.UploadPartRequest
  ): Promise<responses.UploadPartResponse> {
    const pathParams = {
      "{namespaceName}": uploadPartRequest.namespaceName,
      "{bucketName}": uploadPartRequest.bucketName,
      "{objectName}": uploadPartRequest.objectName
    };

    const queryParams = {
      "uploadId": uploadPartRequest.uploadId,
      "uploadPartNum": uploadPartRequest.uploadPartNum
    };

    let headerParams = {
      "opc-client-request-id": uploadPartRequest.opcClientRequestId,
      "if-match": uploadPartRequest.ifMatch,
      "if-none-match": uploadPartRequest.ifNoneMatch,
      "Expect": uploadPartRequest.expect,
      "Content-Length": uploadPartRequest.contentLength,
      "Content-MD5": uploadPartRequest.contentMD5,
      "opc-sse-customer-algorithm": uploadPartRequest.opcSseCustomerAlgorithm,
      "opc-sse-customer-key": uploadPartRequest.opcSseCustomerKey,
      "opc-sse-customer-key-sha256": uploadPartRequest.opcSseCustomerKeySha256
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/n/{namespaceName}/b/{bucketName}/u/{objectName}",
      method: "PUT",
      bodyContent: uploadPartRequest.uploadPartBody,
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request, true);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UploadPartResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-client-request-id"),
            key: "opcClientRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-content-md5"),
            key: "opcContentMd5",
            dataType: "string"
          },
          {
            value: response.headers.get("ETag"),
            key: "eTag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }
}
