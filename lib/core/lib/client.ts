/**
 * Core Services API
 * API covering the [Networking](/iaas/Content/Network/Concepts/overview.htm),
[Compute](/iaas/Content/Compute/Concepts/computeoverview.htm), and
[Block Volume](/iaas/Content/Block/Concepts/overview.htm) services. Use this API
to manage resources such as virtual cloud networks (VCNs), compute instances, and
block storage volumes.

 * OpenAPI spec version: 20160918
 * 
 *
 * NOTE: This class is auto generated by OracleSDKGenerator.
 * Do not edit the class manually.
 *
 * Copyright (c) 2020, Oracle and/or its affiliates.  All rights reserved.
 * This software is dual-licensed to you under the Universal Permissive License (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl or Apache License 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose either license.
 */

import common = require("oci-common");
import * as requests from "./request";
import * as models from "./model";
import * as responses from "./response";
import { paginateRecords, paginateResponses } from "oci-common";
import { WorkRequestClient } from "oci-workrequests";
import { BlockstorageWaiter } from "./blockstorage-waiter";
import { ComputeWaiter } from "./compute-waiter";
import { ComputeManagementWaiter } from "./computemanagement-waiter";
import { VirtualNetworkWaiter } from "./virtualnetwork-waiter";
import { composeResponse, composeRequest } from "oci-common";

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum BlockstorageApiKeys {}

export class BlockstorageClient {
  protected static serviceEndpointTemplate = "https://iaas.{region}.{secondLevelDomain}";
  protected "_endpoint": string = "";
  protected "_defaultHeaders": any = {};
  protected "_waiters": BlockstorageWaiter;

  protected _httpClient: common.HttpClient;

  constructor(params: common.AuthParams) {
    const requestSigner = params.authenticationDetailsProvider
      ? new common.DefaultRequestSigner(params.authenticationDetailsProvider)
      : null;
    this._httpClient = params.httpClient || new common.FetchHttpClient(requestSigner);

    if (
      params.authenticationDetailsProvider &&
      common.isRegionProvider(params.authenticationDetailsProvider)
    ) {
      const provider: common.RegionProvider = params.authenticationDetailsProvider;
      if (provider.getRegion()) {
        this.region = provider.getRegion();
      }
    }
  }

  /**
   * Sets the endpoint to call (ex, https://www.example.com).
   * @param endpoint The endpoint of the service.
   */
  public set endpoint(endpoint: string) {
    this._endpoint = endpoint;
    this._endpoint = this._endpoint + "/20160918";
  }

  /**
   * Sets the region to call (ex, Region.US_PHOENIX_1).
   * Note, this will call {@link #endpoint(String) endpoint} after resolving the endpoint.
   * @param region The region of the service.
   */
  public set region(region: common.Region) {
    this.endpoint = common.EndpointBuilder.createEndpointFromRegion(
      BlockstorageClient.serviceEndpointTemplate,
      region
    );
  }

  /**
   * Sets the regionId to call (ex, 'us-phoenix-1').
   *
   * Note, this will first try to map the region ID to a known Region and call {@link #region(Region) region}.
   * If no known Region could be determined, it will create an endpoint assuming its in default Realm OC1
   * and then call {@link #endpoint(String) endpoint}.
   * @param regionId The public region ID.
   */
  public set regionId(regionId: string) {
    this.endpoint = common.EndpointBuilder.createEndpointFromRegionId(
      BlockstorageClient.serviceEndpointTemplate,
      regionId
    );
  }

  /**
   * Creates a new BlockstorageWaiter for resources for this service.
   *
   * @param workRequestClient The work request service client used to query for work request status
   * @param config The waiter configuration for termination and delay strategy
   * @return The service waiters.
   */
  public createWaiters(
    workRequestClient: WorkRequestClient,
    config?: common.WaiterConfiguration
  ): BlockstorageWaiter {
    this._waiters = new BlockstorageWaiter(this, workRequestClient, config);
    return this._waiters;
  }

  /**
   * Gets the waiters available for resources for this service.
   *
   * @return The service waiters.
   */
  public getWaiters(): BlockstorageWaiter {
    if (this._waiters) {
      return this._waiters;
    }
    throw Error("Waiters do not exist. Please create waiters.");
  }

  /**
   * Moves a boot volume backup into a different compartment within the same tenancy.
   * For information about moving resources between compartments,
   * see [Moving Resources to a Different Compartment](https://docs.cloud.oracle.com/Content/Identity/Tasks/managingcompartments.htm#moveRes).
   *
   * @param ChangeBootVolumeBackupCompartmentRequest
   * @return ChangeBootVolumeBackupCompartmentResponse
   * @throws OciError when an error occurs
   */
  public async changeBootVolumeBackupCompartment(
    changeBootVolumeBackupCompartmentRequest: requests.ChangeBootVolumeBackupCompartmentRequest
  ): Promise<responses.ChangeBootVolumeBackupCompartmentResponse> {
    const pathParams = {
      "{bootVolumeBackupId}": changeBootVolumeBackupCompartmentRequest.bootVolumeBackupId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": changeBootVolumeBackupCompartmentRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/bootVolumeBackups/{bootVolumeBackupId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeBootVolumeBackupCompartmentRequest.changeBootVolumeBackupCompartmentDetails,
        "ChangeBootVolumeBackupCompartmentDetails",
        models.ChangeBootVolumeBackupCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeBootVolumeBackupCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Moves a boot volume into a different compartment within the same tenancy.
   * For information about moving resources between compartments,
   * see [Moving Resources to a Different Compartment](https://docs.cloud.oracle.com/Content/Identity/Tasks/managingcompartments.htm#moveRes).
   *
   * @param ChangeBootVolumeCompartmentRequest
   * @return ChangeBootVolumeCompartmentResponse
   * @throws OciError when an error occurs
   */
  public async changeBootVolumeCompartment(
    changeBootVolumeCompartmentRequest: requests.ChangeBootVolumeCompartmentRequest
  ): Promise<responses.ChangeBootVolumeCompartmentResponse> {
    const pathParams = {
      "{bootVolumeId}": changeBootVolumeCompartmentRequest.bootVolumeId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": changeBootVolumeCompartmentRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/bootVolumes/{bootVolumeId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeBootVolumeCompartmentRequest.changeBootVolumeCompartmentDetails,
        "ChangeBootVolumeCompartmentDetails",
        models.ChangeBootVolumeCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeBootVolumeCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Moves a volume backup into a different compartment within the same tenancy.
   * For information about moving resources between compartments,
   * see [Moving Resources to a Different Compartment](https://docs.cloud.oracle.com/Content/Identity/Tasks/managingcompartments.htm#moveRes).
   *
   * @param ChangeVolumeBackupCompartmentRequest
   * @return ChangeVolumeBackupCompartmentResponse
   * @throws OciError when an error occurs
   */
  public async changeVolumeBackupCompartment(
    changeVolumeBackupCompartmentRequest: requests.ChangeVolumeBackupCompartmentRequest
  ): Promise<responses.ChangeVolumeBackupCompartmentResponse> {
    const pathParams = {
      "{volumeBackupId}": changeVolumeBackupCompartmentRequest.volumeBackupId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": changeVolumeBackupCompartmentRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/volumeBackups/{volumeBackupId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeVolumeBackupCompartmentRequest.changeVolumeBackupCompartmentDetails,
        "ChangeVolumeBackupCompartmentDetails",
        models.ChangeVolumeBackupCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeVolumeBackupCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Moves a volume into a different compartment within the same tenancy.
   * For information about moving resources between compartments,
   * see [Moving Resources to a Different Compartment](https://docs.cloud.oracle.com/Content/Identity/Tasks/managingcompartments.htm#moveRes).
   *
   * @param ChangeVolumeCompartmentRequest
   * @return ChangeVolumeCompartmentResponse
   * @throws OciError when an error occurs
   */
  public async changeVolumeCompartment(
    changeVolumeCompartmentRequest: requests.ChangeVolumeCompartmentRequest
  ): Promise<responses.ChangeVolumeCompartmentResponse> {
    const pathParams = {
      "{volumeId}": changeVolumeCompartmentRequest.volumeId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": changeVolumeCompartmentRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/volumes/{volumeId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeVolumeCompartmentRequest.changeVolumeCompartmentDetails,
        "ChangeVolumeCompartmentDetails",
        models.ChangeVolumeCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeVolumeCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Moves a volume group backup into a different compartment within the same tenancy.
   * For information about moving resources between compartments,
   * see [Moving Resources to a Different Compartment](https://docs.cloud.oracle.com/Content/Identity/Tasks/managingcompartments.htm#moveRes).
   *
   * @param ChangeVolumeGroupBackupCompartmentRequest
   * @return ChangeVolumeGroupBackupCompartmentResponse
   * @throws OciError when an error occurs
   */
  public async changeVolumeGroupBackupCompartment(
    changeVolumeGroupBackupCompartmentRequest: requests.ChangeVolumeGroupBackupCompartmentRequest
  ): Promise<responses.ChangeVolumeGroupBackupCompartmentResponse> {
    const pathParams = {
      "{volumeGroupBackupId}": changeVolumeGroupBackupCompartmentRequest.volumeGroupBackupId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": changeVolumeGroupBackupCompartmentRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/volumeGroupBackups/{volumeGroupBackupId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeVolumeGroupBackupCompartmentRequest.changeVolumeGroupBackupCompartmentDetails,
        "ChangeVolumeGroupBackupCompartmentDetails",
        models.ChangeVolumeGroupBackupCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeVolumeGroupBackupCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Moves a volume group into a different compartment within the same tenancy.
   * For information about moving resources between compartments,
   * see [Moving Resources to a Different Compartment](https://docs.cloud.oracle.com/Content/Identity/Tasks/managingcompartments.htm#moveRes).
   *
   * @param ChangeVolumeGroupCompartmentRequest
   * @return ChangeVolumeGroupCompartmentResponse
   * @throws OciError when an error occurs
   */
  public async changeVolumeGroupCompartment(
    changeVolumeGroupCompartmentRequest: requests.ChangeVolumeGroupCompartmentRequest
  ): Promise<responses.ChangeVolumeGroupCompartmentResponse> {
    const pathParams = {
      "{volumeGroupId}": changeVolumeGroupCompartmentRequest.volumeGroupId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": changeVolumeGroupCompartmentRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/volumeGroups/{volumeGroupId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeVolumeGroupCompartmentRequest.changeVolumeGroupCompartmentDetails,
        "ChangeVolumeGroupCompartmentDetails",
        models.ChangeVolumeGroupCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeVolumeGroupCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a boot volume backup copy in specified region. For general information about volume backups,
   * see [Overview of Boot Volume Backups](https://docs.cloud.oracle.com/Content/Block/Concepts/bootvolumebackups.htm)
   *
   * @param CopyBootVolumeBackupRequest
   * @return CopyBootVolumeBackupResponse
   * @throws OciError when an error occurs
   */
  public async copyBootVolumeBackup(
    copyBootVolumeBackupRequest: requests.CopyBootVolumeBackupRequest
  ): Promise<responses.CopyBootVolumeBackupResponse> {
    const pathParams = {
      "{bootVolumeBackupId}": copyBootVolumeBackupRequest.bootVolumeBackupId
    };

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": copyBootVolumeBackupRequest.opcRetryToken,
      "opc-request-id": copyBootVolumeBackupRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/bootVolumeBackups/{bootVolumeBackupId}/actions/copy",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        copyBootVolumeBackupRequest.copyBootVolumeBackupDetails,
        "CopyBootVolumeBackupDetails",
        models.CopyBootVolumeBackupDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CopyBootVolumeBackupResponse>{},
        body: await response.json(),
        bodyKey: "bootVolumeBackup",
        bodyModel: "model.BootVolumeBackup",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a volume backup copy in specified region. For general information about volume backups,
   * see [Overview of Block Volume Service Backups](https://docs.cloud.oracle.com/Content/Block/Concepts/blockvolumebackups.htm)
   *
   * @param CopyVolumeBackupRequest
   * @return CopyVolumeBackupResponse
   * @throws OciError when an error occurs
   */
  public async copyVolumeBackup(
    copyVolumeBackupRequest: requests.CopyVolumeBackupRequest
  ): Promise<responses.CopyVolumeBackupResponse> {
    const pathParams = {
      "{volumeBackupId}": copyVolumeBackupRequest.volumeBackupId
    };

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": copyVolumeBackupRequest.opcRetryToken,
      "opc-request-id": copyVolumeBackupRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/volumeBackups/{volumeBackupId}/actions/copy",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        copyVolumeBackupRequest.copyVolumeBackupDetails,
        "CopyVolumeBackupDetails",
        models.CopyVolumeBackupDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CopyVolumeBackupResponse>{},
        body: await response.json(),
        bodyKey: "volumeBackup",
        bodyModel: "model.VolumeBackup",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new boot volume in the specified compartment from an existing boot volume or a boot volume backup.
   * For general information about boot volumes, see [Boot Volumes](https://docs.cloud.oracle.com/Content/Block/Concepts/bootvolumes.htm).
   * You may optionally specify a *display name* for the volume, which is simply a friendly name or
   * description. It does not have to be unique, and you can change it. Avoid entering confidential information.
   *
   * @param CreateBootVolumeRequest
   * @return CreateBootVolumeResponse
   * @throws OciError when an error occurs
   */
  public async createBootVolume(
    createBootVolumeRequest: requests.CreateBootVolumeRequest
  ): Promise<responses.CreateBootVolumeResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createBootVolumeRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/bootVolumes",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createBootVolumeRequest.createBootVolumeDetails,
        "CreateBootVolumeDetails",
        models.CreateBootVolumeDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateBootVolumeResponse>{},
        body: await response.json(),
        bodyKey: "bootVolume",
        bodyModel: "model.BootVolume",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Creates a new boot volume backup of the specified boot volume. For general information about boot volume backups,
* see [Overview of Boot Volume Backups](https://docs.cloud.oracle.com/Content/Block/Concepts/bootvolumebackups.htm)
* <p>
When the request is received, the backup object is in a REQUEST_RECEIVED state.
* When the data is imaged, it goes into a CREATING state.
* After the backup is fully uploaded to the cloud, it goes into an AVAILABLE state.
* 
     * @param CreateBootVolumeBackupRequest
     * @return CreateBootVolumeBackupResponse
     * @throws OciError when an error occurs
     */
  public async createBootVolumeBackup(
    createBootVolumeBackupRequest: requests.CreateBootVolumeBackupRequest
  ): Promise<responses.CreateBootVolumeBackupResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createBootVolumeBackupRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/bootVolumeBackups",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createBootVolumeBackupRequest.createBootVolumeBackupDetails,
        "CreateBootVolumeBackupDetails",
        models.CreateBootVolumeBackupDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateBootVolumeBackupResponse>{},
        body: await response.json(),
        bodyKey: "bootVolumeBackup",
        bodyModel: "model.BootVolumeBackup",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Creates a new volume in the specified compartment. Volumes can be created in sizes ranging from
* 50 GB (51200 MB) to 32 TB (33554432 MB), in 1 GB (1024 MB) increments. By default, volumes are 1 TB (1048576 MB).
* For general information about block volumes, see
* [Overview of Block Volume Service](https://docs.cloud.oracle.com/Content/Block/Concepts/overview.htm).
* <p>
A volume and instance can be in separate compartments but must be in the same availability domain.
* For information about access control and compartments, see
* [Overview of the IAM Service](https://docs.cloud.oracle.com/Content/Identity/Concepts/overview.htm). For information about
* availability domains, see [Regions and Availability Domains](https://docs.cloud.oracle.com/Content/General/Concepts/regions.htm).
* To get a list of availability domains, use the `ListAvailabilityDomains` operation
* in the Identity and Access Management Service API.
* <p>
You may optionally specify a *display name* for the volume, which is simply a friendly name or
* description. It does not have to be unique, and you can change it. Avoid entering confidential information.
* 
     * @param CreateVolumeRequest
     * @return CreateVolumeResponse
     * @throws OciError when an error occurs
     */
  public async createVolume(
    createVolumeRequest: requests.CreateVolumeRequest
  ): Promise<responses.CreateVolumeResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createVolumeRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/volumes",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createVolumeRequest.createVolumeDetails,
        "CreateVolumeDetails",
        models.CreateVolumeDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateVolumeResponse>{},
        body: await response.json(),
        bodyKey: "volume",
        bodyModel: "model.Volume",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Creates a new backup of the specified volume. For general information about volume backups,
* see [Overview of Block Volume Service Backups](https://docs.cloud.oracle.com/Content/Block/Concepts/blockvolumebackups.htm)
* <p>
When the request is received, the backup object is in a REQUEST_RECEIVED state.
* When the data is imaged, it goes into a CREATING state.
* After the backup is fully uploaded to the cloud, it goes into an AVAILABLE state.
* 
     * @param CreateVolumeBackupRequest
     * @return CreateVolumeBackupResponse
     * @throws OciError when an error occurs
     */
  public async createVolumeBackup(
    createVolumeBackupRequest: requests.CreateVolumeBackupRequest
  ): Promise<responses.CreateVolumeBackupResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createVolumeBackupRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/volumeBackups",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createVolumeBackupRequest.createVolumeBackupDetails,
        "CreateVolumeBackupDetails",
        models.CreateVolumeBackupDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateVolumeBackupResponse>{},
        body: await response.json(),
        bodyKey: "volumeBackup",
        bodyModel: "model.VolumeBackup",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Creates a new user defined backup policy.
* <p>
For more information about Oracle defined backup policies and user defined backup policies,
* see [Policy-Based Backups](https://docs.cloud.oracle.com/iaas/Content/Block/Tasks/schedulingvolumebackups.htm).
* 
     * @param CreateVolumeBackupPolicyRequest
     * @return CreateVolumeBackupPolicyResponse
     * @throws OciError when an error occurs
     */
  public async createVolumeBackupPolicy(
    createVolumeBackupPolicyRequest: requests.CreateVolumeBackupPolicyRequest
  ): Promise<responses.CreateVolumeBackupPolicyResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createVolumeBackupPolicyRequest.opcRetryToken,
      "opc-request-id": createVolumeBackupPolicyRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/volumeBackupPolicies",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createVolumeBackupPolicyRequest.createVolumeBackupPolicyDetails,
        "CreateVolumeBackupPolicyDetails",
        models.CreateVolumeBackupPolicyDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateVolumeBackupPolicyResponse>{},
        body: await response.json(),
        bodyKey: "volumeBackupPolicy",
        bodyModel: "model.VolumeBackupPolicy",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Assigns a volume backup policy to the specified volume. Note that a given volume can
   * only have one backup policy assigned to it. If this operation is used for a volume that already
   * has a different backup policy assigned, the prior backup policy will be silently unassigned.
   *
   * @param CreateVolumeBackupPolicyAssignmentRequest
   * @return CreateVolumeBackupPolicyAssignmentResponse
   * @throws OciError when an error occurs
   */
  public async createVolumeBackupPolicyAssignment(
    createVolumeBackupPolicyAssignmentRequest: requests.CreateVolumeBackupPolicyAssignmentRequest
  ): Promise<responses.CreateVolumeBackupPolicyAssignmentResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/volumeBackupPolicyAssignments",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createVolumeBackupPolicyAssignmentRequest.createVolumeBackupPolicyAssignmentDetails,
        "CreateVolumeBackupPolicyAssignmentDetails",
        models.CreateVolumeBackupPolicyAssignmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateVolumeBackupPolicyAssignmentResponse>{},
        body: await response.json(),
        bodyKey: "volumeBackupPolicyAssignment",
        bodyModel: "model.VolumeBackupPolicyAssignment",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Creates a new volume group in the specified compartment.
* A volume group is a collection of volumes and may be created from a list of volumes, cloning an existing
* volume group, or by restoring a volume group backup. A volume group can contain up to 64 volumes.
* You may optionally specify a *display name* for the volume group, which is simply a friendly name or
* description. It does not have to be unique, and you can change it. Avoid entering confidential information.
* <p>
For more information, see [Volume Groups](https://docs.cloud.oracle.com/Content/Block/Concepts/volumegroups.htm).
* 
     * @param CreateVolumeGroupRequest
     * @return CreateVolumeGroupResponse
     * @throws OciError when an error occurs
     */
  public async createVolumeGroup(
    createVolumeGroupRequest: requests.CreateVolumeGroupRequest
  ): Promise<responses.CreateVolumeGroupResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createVolumeGroupRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/volumeGroups",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createVolumeGroupRequest.createVolumeGroupDetails,
        "CreateVolumeGroupDetails",
        models.CreateVolumeGroupDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateVolumeGroupResponse>{},
        body: await response.json(),
        bodyKey: "volumeGroup",
        bodyModel: "model.VolumeGroup",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new backup volume group of the specified volume group.
   * For more information, see [Volume Groups](https://docs.cloud.oracle.com/Content/Block/Concepts/volumegroups.htm).
   *
   * @param CreateVolumeGroupBackupRequest
   * @return CreateVolumeGroupBackupResponse
   * @throws OciError when an error occurs
   */
  public async createVolumeGroupBackup(
    createVolumeGroupBackupRequest: requests.CreateVolumeGroupBackupRequest
  ): Promise<responses.CreateVolumeGroupBackupResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createVolumeGroupBackupRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/volumeGroupBackups",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createVolumeGroupBackupRequest.createVolumeGroupBackupDetails,
        "CreateVolumeGroupBackupDetails",
        models.CreateVolumeGroupBackupDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateVolumeGroupBackupResponse>{},
        body: await response.json(),
        bodyKey: "volumeGroupBackup",
        bodyModel: "model.VolumeGroupBackup",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Deletes the specified boot volume. The volume cannot have an active connection to an instance.
   * To disconnect the boot volume from a connected instance, see
   * [Disconnecting From a Boot Volume](https://docs.cloud.oracle.com/Content/Block/Tasks/deletingbootvolume.htm).
   * **Warning:** All data on the boot volume will be permanently lost when the boot volume is deleted.
   *
   * @param DeleteBootVolumeRequest
   * @return DeleteBootVolumeResponse
   * @throws OciError when an error occurs
   */
  public async deleteBootVolume(
    deleteBootVolumeRequest: requests.DeleteBootVolumeRequest
  ): Promise<responses.DeleteBootVolumeResponse> {
    const pathParams = {
      "{bootVolumeId}": deleteBootVolumeRequest.bootVolumeId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteBootVolumeRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/bootVolumes/{bootVolumeId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteBootVolumeResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Deletes a boot volume backup.
   * @param DeleteBootVolumeBackupRequest
   * @return DeleteBootVolumeBackupResponse
   * @throws OciError when an error occurs
   */
  public async deleteBootVolumeBackup(
    deleteBootVolumeBackupRequest: requests.DeleteBootVolumeBackupRequest
  ): Promise<responses.DeleteBootVolumeBackupResponse> {
    const pathParams = {
      "{bootVolumeBackupId}": deleteBootVolumeBackupRequest.bootVolumeBackupId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteBootVolumeBackupRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/bootVolumeBackups/{bootVolumeBackupId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteBootVolumeBackupResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Removes the specified boot volume's assigned Key Management encryption key.
   *
   * @param DeleteBootVolumeKmsKeyRequest
   * @return DeleteBootVolumeKmsKeyResponse
   * @throws OciError when an error occurs
   */
  public async deleteBootVolumeKmsKey(
    deleteBootVolumeKmsKeyRequest: requests.DeleteBootVolumeKmsKeyRequest
  ): Promise<responses.DeleteBootVolumeKmsKeyResponse> {
    const pathParams = {
      "{bootVolumeId}": deleteBootVolumeKmsKeyRequest.bootVolumeId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteBootVolumeKmsKeyRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/bootVolumes/{bootVolumeId}/kmsKey",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteBootVolumeKmsKeyResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Deletes the specified volume. The volume cannot have an active connection to an instance.
   * To disconnect the volume from a connected instance, see
   * [Disconnecting From a Volume](https://docs.cloud.oracle.com/Content/Block/Tasks/disconnectingfromavolume.htm).
   * **Warning:** All data on the volume will be permanently lost when the volume is deleted.
   *
   * @param DeleteVolumeRequest
   * @return DeleteVolumeResponse
   * @throws OciError when an error occurs
   */
  public async deleteVolume(
    deleteVolumeRequest: requests.DeleteVolumeRequest
  ): Promise<responses.DeleteVolumeResponse> {
    const pathParams = {
      "{volumeId}": deleteVolumeRequest.volumeId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteVolumeRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/volumes/{volumeId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteVolumeResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Deletes a volume backup.
   * @param DeleteVolumeBackupRequest
   * @return DeleteVolumeBackupResponse
   * @throws OciError when an error occurs
   */
  public async deleteVolumeBackup(
    deleteVolumeBackupRequest: requests.DeleteVolumeBackupRequest
  ): Promise<responses.DeleteVolumeBackupResponse> {
    const pathParams = {
      "{volumeBackupId}": deleteVolumeBackupRequest.volumeBackupId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteVolumeBackupRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/volumeBackups/{volumeBackupId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteVolumeBackupResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Deletes a user defined backup policy.
*  For more information about user defined backup policies,
*  see [Policy-Based Backups](https://docs.cloud.oracle.com/iaas/Content/Block/Tasks/schedulingvolumebackups.htm#UserDefinedBackupPolicies).
* <p>
 Avoid entering confidential information.
* 
     * @param DeleteVolumeBackupPolicyRequest
     * @return DeleteVolumeBackupPolicyResponse
     * @throws OciError when an error occurs
     */
  public async deleteVolumeBackupPolicy(
    deleteVolumeBackupPolicyRequest: requests.DeleteVolumeBackupPolicyRequest
  ): Promise<responses.DeleteVolumeBackupPolicyResponse> {
    const pathParams = {
      "{policyId}": deleteVolumeBackupPolicyRequest.policyId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": deleteVolumeBackupPolicyRequest.opcRequestId,
      "if-match": deleteVolumeBackupPolicyRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/volumeBackupPolicies/{policyId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteVolumeBackupPolicyResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Deletes a volume backup policy assignment.
   * @param DeleteVolumeBackupPolicyAssignmentRequest
   * @return DeleteVolumeBackupPolicyAssignmentResponse
   * @throws OciError when an error occurs
   */
  public async deleteVolumeBackupPolicyAssignment(
    deleteVolumeBackupPolicyAssignmentRequest: requests.DeleteVolumeBackupPolicyAssignmentRequest
  ): Promise<responses.DeleteVolumeBackupPolicyAssignmentResponse> {
    const pathParams = {
      "{policyAssignmentId}": deleteVolumeBackupPolicyAssignmentRequest.policyAssignmentId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteVolumeBackupPolicyAssignmentRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/volumeBackupPolicyAssignments/{policyAssignmentId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteVolumeBackupPolicyAssignmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Deletes the specified volume group. Individual volumes are not deleted, only the volume group is deleted.
   * For more information, see [Volume Groups](https://docs.cloud.oracle.com/Content/Block/Concepts/volumegroups.htm).
   *
   * @param DeleteVolumeGroupRequest
   * @return DeleteVolumeGroupResponse
   * @throws OciError when an error occurs
   */
  public async deleteVolumeGroup(
    deleteVolumeGroupRequest: requests.DeleteVolumeGroupRequest
  ): Promise<responses.DeleteVolumeGroupResponse> {
    const pathParams = {
      "{volumeGroupId}": deleteVolumeGroupRequest.volumeGroupId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteVolumeGroupRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/volumeGroups/{volumeGroupId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteVolumeGroupResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Deletes a volume group backup. This operation deletes all the backups in the volume group. For more information, see [Volume Groups](https://docs.cloud.oracle.com/Content/Block/Concepts/volumegroups.htm).
   * @param DeleteVolumeGroupBackupRequest
   * @return DeleteVolumeGroupBackupResponse
   * @throws OciError when an error occurs
   */
  public async deleteVolumeGroupBackup(
    deleteVolumeGroupBackupRequest: requests.DeleteVolumeGroupBackupRequest
  ): Promise<responses.DeleteVolumeGroupBackupResponse> {
    const pathParams = {
      "{volumeGroupBackupId}": deleteVolumeGroupBackupRequest.volumeGroupBackupId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteVolumeGroupBackupRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/volumeGroupBackups/{volumeGroupBackupId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteVolumeGroupBackupResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Removes the specified volume's assigned Key Management encryption key.
   *
   * @param DeleteVolumeKmsKeyRequest
   * @return DeleteVolumeKmsKeyResponse
   * @throws OciError when an error occurs
   */
  public async deleteVolumeKmsKey(
    deleteVolumeKmsKeyRequest: requests.DeleteVolumeKmsKeyRequest
  ): Promise<responses.DeleteVolumeKmsKeyResponse> {
    const pathParams = {
      "{volumeId}": deleteVolumeKmsKeyRequest.volumeId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteVolumeKmsKeyRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/volumes/{volumeId}/kmsKey",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteVolumeKmsKeyResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets information for the specified boot volume.
   * @param GetBootVolumeRequest
   * @return GetBootVolumeResponse
   * @throws OciError when an error occurs
   */
  public async getBootVolume(
    getBootVolumeRequest: requests.GetBootVolumeRequest
  ): Promise<responses.GetBootVolumeResponse> {
    const pathParams = {
      "{bootVolumeId}": getBootVolumeRequest.bootVolumeId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/bootVolumes/{bootVolumeId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetBootVolumeResponse>{},
        body: await response.json(),
        bodyKey: "bootVolume",
        bodyModel: "model.BootVolume",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets information for the specified boot volume backup.
   * @param GetBootVolumeBackupRequest
   * @return GetBootVolumeBackupResponse
   * @throws OciError when an error occurs
   */
  public async getBootVolumeBackup(
    getBootVolumeBackupRequest: requests.GetBootVolumeBackupRequest
  ): Promise<responses.GetBootVolumeBackupResponse> {
    const pathParams = {
      "{bootVolumeBackupId}": getBootVolumeBackupRequest.bootVolumeBackupId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/bootVolumeBackups/{bootVolumeBackupId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetBootVolumeBackupResponse>{},
        body: await response.json(),
        bodyKey: "bootVolumeBackup",
        bodyModel: "model.BootVolumeBackup",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the Key Management encryption key assigned to the specified boot volume.
   *
   * @param GetBootVolumeKmsKeyRequest
   * @return GetBootVolumeKmsKeyResponse
   * @throws OciError when an error occurs
   */
  public async getBootVolumeKmsKey(
    getBootVolumeKmsKeyRequest: requests.GetBootVolumeKmsKeyRequest
  ): Promise<responses.GetBootVolumeKmsKeyResponse> {
    const pathParams = {
      "{bootVolumeId}": getBootVolumeKmsKeyRequest.bootVolumeId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": getBootVolumeKmsKeyRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/bootVolumes/{bootVolumeId}/kmsKey",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetBootVolumeKmsKeyResponse>{},
        body: await response.json(),
        bodyKey: "bootVolumeKmsKey",
        bodyModel: "model.BootVolumeKmsKey",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets information for the specified volume.
   * @param GetVolumeRequest
   * @return GetVolumeResponse
   * @throws OciError when an error occurs
   */
  public async getVolume(
    getVolumeRequest: requests.GetVolumeRequest
  ): Promise<responses.GetVolumeResponse> {
    const pathParams = {
      "{volumeId}": getVolumeRequest.volumeId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/volumes/{volumeId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetVolumeResponse>{},
        body: await response.json(),
        bodyKey: "volume",
        bodyModel: "model.Volume",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets information for the specified volume backup.
   * @param GetVolumeBackupRequest
   * @return GetVolumeBackupResponse
   * @throws OciError when an error occurs
   */
  public async getVolumeBackup(
    getVolumeBackupRequest: requests.GetVolumeBackupRequest
  ): Promise<responses.GetVolumeBackupResponse> {
    const pathParams = {
      "{volumeBackupId}": getVolumeBackupRequest.volumeBackupId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/volumeBackups/{volumeBackupId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetVolumeBackupResponse>{},
        body: await response.json(),
        bodyKey: "volumeBackup",
        bodyModel: "model.VolumeBackup",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets information for the specified volume backup policy.
   * @param GetVolumeBackupPolicyRequest
   * @return GetVolumeBackupPolicyResponse
   * @throws OciError when an error occurs
   */
  public async getVolumeBackupPolicy(
    getVolumeBackupPolicyRequest: requests.GetVolumeBackupPolicyRequest
  ): Promise<responses.GetVolumeBackupPolicyResponse> {
    const pathParams = {
      "{policyId}": getVolumeBackupPolicyRequest.policyId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/volumeBackupPolicies/{policyId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetVolumeBackupPolicyResponse>{},
        body: await response.json(),
        bodyKey: "volumeBackupPolicy",
        bodyModel: "model.VolumeBackupPolicy",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the volume backup policy assignment for the specified volume. The
   * `assetId` query parameter is required, and the returned list will contain at most
   * one item, since volume can only have one volume backup policy assigned at a time.
   *
   * @param GetVolumeBackupPolicyAssetAssignmentRequest
   * @return GetVolumeBackupPolicyAssetAssignmentResponse
   * @throws OciError when an error occurs
   */
  public async getVolumeBackupPolicyAssetAssignment(
    getVolumeBackupPolicyAssetAssignmentRequest: requests.GetVolumeBackupPolicyAssetAssignmentRequest
  ): Promise<responses.GetVolumeBackupPolicyAssetAssignmentResponse> {
    const pathParams = {};

    const queryParams = {
      "assetId": getVolumeBackupPolicyAssetAssignmentRequest.assetId,
      "limit": getVolumeBackupPolicyAssetAssignmentRequest.limit,
      "page": getVolumeBackupPolicyAssetAssignmentRequest.page
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/volumeBackupPolicyAssignments",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetVolumeBackupPolicyAssetAssignmentResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "VolumeBackupPolicyAssignment[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.VolumeBackupPolicyAssignment objects
   * contained in responses from the getVolumeBackupPolicyAssetAssignment operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public getAllVolumeBackupPolicyAssetAssignment(
    request: requests.GetVolumeBackupPolicyAssetAssignmentRequest
  ): AsyncIterableIterator<models.VolumeBackupPolicyAssignment> {
    return paginateRecords(request, req => this.getVolumeBackupPolicyAssetAssignment(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the getVolumeBackupPolicyAssetAssignment operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public getAllVolumeBackupPolicyAssetAssignmentResponses(
    request: requests.GetVolumeBackupPolicyAssetAssignmentRequest
  ): AsyncIterableIterator<responses.GetVolumeBackupPolicyAssetAssignmentResponse> {
    return paginateResponses(request, req => this.getVolumeBackupPolicyAssetAssignment(req));
  }

  /**
   * Gets information for the specified volume backup policy assignment.
   * @param GetVolumeBackupPolicyAssignmentRequest
   * @return GetVolumeBackupPolicyAssignmentResponse
   * @throws OciError when an error occurs
   */
  public async getVolumeBackupPolicyAssignment(
    getVolumeBackupPolicyAssignmentRequest: requests.GetVolumeBackupPolicyAssignmentRequest
  ): Promise<responses.GetVolumeBackupPolicyAssignmentResponse> {
    const pathParams = {
      "{policyAssignmentId}": getVolumeBackupPolicyAssignmentRequest.policyAssignmentId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/volumeBackupPolicyAssignments/{policyAssignmentId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetVolumeBackupPolicyAssignmentResponse>{},
        body: await response.json(),
        bodyKey: "volumeBackupPolicyAssignment",
        bodyModel: "model.VolumeBackupPolicyAssignment",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets information for the specified volume group. For more information, see [Volume Groups](https://docs.cloud.oracle.com/Content/Block/Concepts/volumegroups.htm).
   * @param GetVolumeGroupRequest
   * @return GetVolumeGroupResponse
   * @throws OciError when an error occurs
   */
  public async getVolumeGroup(
    getVolumeGroupRequest: requests.GetVolumeGroupRequest
  ): Promise<responses.GetVolumeGroupResponse> {
    const pathParams = {
      "{volumeGroupId}": getVolumeGroupRequest.volumeGroupId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/volumeGroups/{volumeGroupId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetVolumeGroupResponse>{},
        body: await response.json(),
        bodyKey: "volumeGroup",
        bodyModel: "model.VolumeGroup",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets information for the specified volume group backup. For more information, see [Volume Groups](https://docs.cloud.oracle.com/Content/Block/Concepts/volumegroups.htm).
   * @param GetVolumeGroupBackupRequest
   * @return GetVolumeGroupBackupResponse
   * @throws OciError when an error occurs
   */
  public async getVolumeGroupBackup(
    getVolumeGroupBackupRequest: requests.GetVolumeGroupBackupRequest
  ): Promise<responses.GetVolumeGroupBackupResponse> {
    const pathParams = {
      "{volumeGroupBackupId}": getVolumeGroupBackupRequest.volumeGroupBackupId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/volumeGroupBackups/{volumeGroupBackupId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetVolumeGroupBackupResponse>{},
        body: await response.json(),
        bodyKey: "volumeGroupBackup",
        bodyModel: "model.VolumeGroupBackup",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the Key Management encryption key assigned to the specified volume.
   *
   * @param GetVolumeKmsKeyRequest
   * @return GetVolumeKmsKeyResponse
   * @throws OciError when an error occurs
   */
  public async getVolumeKmsKey(
    getVolumeKmsKeyRequest: requests.GetVolumeKmsKeyRequest
  ): Promise<responses.GetVolumeKmsKeyResponse> {
    const pathParams = {
      "{volumeId}": getVolumeKmsKeyRequest.volumeId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": getVolumeKmsKeyRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/volumes/{volumeId}/kmsKey",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetVolumeKmsKeyResponse>{},
        body: await response.json(),
        bodyKey: "volumeKmsKey",
        bodyModel: "model.VolumeKmsKey",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Lists the boot volume backups in the specified compartment. You can filter the results by boot volume.
   *
   * @param ListBootVolumeBackupsRequest
   * @return ListBootVolumeBackupsResponse
   * @throws OciError when an error occurs
   */
  public async listBootVolumeBackups(
    listBootVolumeBackupsRequest: requests.ListBootVolumeBackupsRequest
  ): Promise<responses.ListBootVolumeBackupsResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listBootVolumeBackupsRequest.compartmentId,
      "bootVolumeId": listBootVolumeBackupsRequest.bootVolumeId,
      "limit": listBootVolumeBackupsRequest.limit,
      "page": listBootVolumeBackupsRequest.page,
      "displayName": listBootVolumeBackupsRequest.displayName,
      "sourceBootVolumeBackupId": listBootVolumeBackupsRequest.sourceBootVolumeBackupId,
      "sortBy": listBootVolumeBackupsRequest.sortBy,
      "sortOrder": listBootVolumeBackupsRequest.sortOrder,
      "lifecycleState": listBootVolumeBackupsRequest.lifecycleState
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/bootVolumeBackups",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListBootVolumeBackupsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "BootVolumeBackup[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.BootVolumeBackup objects
   * contained in responses from the listBootVolumeBackups operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllBootVolumeBackups(
    request: requests.ListBootVolumeBackupsRequest
  ): AsyncIterableIterator<models.BootVolumeBackup> {
    return paginateRecords(request, req => this.listBootVolumeBackups(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listBootVolumeBackups operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllBootVolumeBackupsResponses(
    request: requests.ListBootVolumeBackupsRequest
  ): AsyncIterableIterator<responses.ListBootVolumeBackupsResponse> {
    return paginateResponses(request, req => this.listBootVolumeBackups(req));
  }

  /**
   * Lists the boot volumes in the specified compartment and availability domain.
   *
   * @param ListBootVolumesRequest
   * @return ListBootVolumesResponse
   * @throws OciError when an error occurs
   */
  public async listBootVolumes(
    listBootVolumesRequest: requests.ListBootVolumesRequest
  ): Promise<responses.ListBootVolumesResponse> {
    const pathParams = {};

    const queryParams = {
      "availabilityDomain": listBootVolumesRequest.availabilityDomain,
      "compartmentId": listBootVolumesRequest.compartmentId,
      "limit": listBootVolumesRequest.limit,
      "page": listBootVolumesRequest.page,
      "volumeGroupId": listBootVolumesRequest.volumeGroupId
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/bootVolumes",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListBootVolumesResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "BootVolume[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.BootVolume objects
   * contained in responses from the listBootVolumes operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllBootVolumes(
    request: requests.ListBootVolumesRequest
  ): AsyncIterableIterator<models.BootVolume> {
    return paginateRecords(request, req => this.listBootVolumes(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listBootVolumes operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllBootVolumesResponses(
    request: requests.ListBootVolumesRequest
  ): AsyncIterableIterator<responses.ListBootVolumesResponse> {
    return paginateResponses(request, req => this.listBootVolumes(req));
  }

  /**
     * Lists all the volume backup policies available in the specified compartment.
* <p>
For more information about Oracle defined backup policies and user defined backup policies,
* see [Policy-Based Backups](https://docs.cloud.oracle.com/iaas/Content/Block/Tasks/schedulingvolumebackups.htm).
* 
     * @param ListVolumeBackupPoliciesRequest
     * @return ListVolumeBackupPoliciesResponse
     * @throws OciError when an error occurs
     */
  public async listVolumeBackupPolicies(
    listVolumeBackupPoliciesRequest: requests.ListVolumeBackupPoliciesRequest
  ): Promise<responses.ListVolumeBackupPoliciesResponse> {
    const pathParams = {};

    const queryParams = {
      "limit": listVolumeBackupPoliciesRequest.limit,
      "page": listVolumeBackupPoliciesRequest.page,
      "compartmentId": listVolumeBackupPoliciesRequest.compartmentId
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/volumeBackupPolicies",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListVolumeBackupPoliciesResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "VolumeBackupPolicy[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.VolumeBackupPolicy objects
   * contained in responses from the listVolumeBackupPolicies operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllVolumeBackupPolicies(
    request: requests.ListVolumeBackupPoliciesRequest
  ): AsyncIterableIterator<models.VolumeBackupPolicy> {
    return paginateRecords(request, req => this.listVolumeBackupPolicies(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listVolumeBackupPolicies operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllVolumeBackupPoliciesResponses(
    request: requests.ListVolumeBackupPoliciesRequest
  ): AsyncIterableIterator<responses.ListVolumeBackupPoliciesResponse> {
    return paginateResponses(request, req => this.listVolumeBackupPolicies(req));
  }

  /**
   * Lists the volume backups in the specified compartment. You can filter the results by volume.
   *
   * @param ListVolumeBackupsRequest
   * @return ListVolumeBackupsResponse
   * @throws OciError when an error occurs
   */
  public async listVolumeBackups(
    listVolumeBackupsRequest: requests.ListVolumeBackupsRequest
  ): Promise<responses.ListVolumeBackupsResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listVolumeBackupsRequest.compartmentId,
      "volumeId": listVolumeBackupsRequest.volumeId,
      "limit": listVolumeBackupsRequest.limit,
      "page": listVolumeBackupsRequest.page,
      "displayName": listVolumeBackupsRequest.displayName,
      "sourceVolumeBackupId": listVolumeBackupsRequest.sourceVolumeBackupId,
      "sortBy": listVolumeBackupsRequest.sortBy,
      "sortOrder": listVolumeBackupsRequest.sortOrder,
      "lifecycleState": listVolumeBackupsRequest.lifecycleState
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/volumeBackups",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListVolumeBackupsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "VolumeBackup[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.VolumeBackup objects
   * contained in responses from the listVolumeBackups operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllVolumeBackups(
    request: requests.ListVolumeBackupsRequest
  ): AsyncIterableIterator<models.VolumeBackup> {
    return paginateRecords(request, req => this.listVolumeBackups(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listVolumeBackups operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllVolumeBackupsResponses(
    request: requests.ListVolumeBackupsRequest
  ): AsyncIterableIterator<responses.ListVolumeBackupsResponse> {
    return paginateResponses(request, req => this.listVolumeBackups(req));
  }

  /**
   * Lists the volume group backups in the specified compartment. You can filter the results by volume group.
   * For more information, see [Volume Groups](https://docs.cloud.oracle.com/Content/Block/Concepts/volumegroups.htm).
   *
   * @param ListVolumeGroupBackupsRequest
   * @return ListVolumeGroupBackupsResponse
   * @throws OciError when an error occurs
   */
  public async listVolumeGroupBackups(
    listVolumeGroupBackupsRequest: requests.ListVolumeGroupBackupsRequest
  ): Promise<responses.ListVolumeGroupBackupsResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listVolumeGroupBackupsRequest.compartmentId,
      "volumeGroupId": listVolumeGroupBackupsRequest.volumeGroupId,
      "limit": listVolumeGroupBackupsRequest.limit,
      "page": listVolumeGroupBackupsRequest.page,
      "displayName": listVolumeGroupBackupsRequest.displayName,
      "sortBy": listVolumeGroupBackupsRequest.sortBy,
      "sortOrder": listVolumeGroupBackupsRequest.sortOrder
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/volumeGroupBackups",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListVolumeGroupBackupsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "VolumeGroupBackup[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.VolumeGroupBackup objects
   * contained in responses from the listVolumeGroupBackups operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllVolumeGroupBackups(
    request: requests.ListVolumeGroupBackupsRequest
  ): AsyncIterableIterator<models.VolumeGroupBackup> {
    return paginateRecords(request, req => this.listVolumeGroupBackups(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listVolumeGroupBackups operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllVolumeGroupBackupsResponses(
    request: requests.ListVolumeGroupBackupsRequest
  ): AsyncIterableIterator<responses.ListVolumeGroupBackupsResponse> {
    return paginateResponses(request, req => this.listVolumeGroupBackups(req));
  }

  /**
   * Lists the volume groups in the specified compartment and availability domain.
   * For more information, see [Volume Groups](https://docs.cloud.oracle.com/Content/Block/Concepts/volumegroups.htm).
   *
   * @param ListVolumeGroupsRequest
   * @return ListVolumeGroupsResponse
   * @throws OciError when an error occurs
   */
  public async listVolumeGroups(
    listVolumeGroupsRequest: requests.ListVolumeGroupsRequest
  ): Promise<responses.ListVolumeGroupsResponse> {
    const pathParams = {};

    const queryParams = {
      "availabilityDomain": listVolumeGroupsRequest.availabilityDomain,
      "compartmentId": listVolumeGroupsRequest.compartmentId,
      "limit": listVolumeGroupsRequest.limit,
      "page": listVolumeGroupsRequest.page,
      "displayName": listVolumeGroupsRequest.displayName,
      "sortBy": listVolumeGroupsRequest.sortBy,
      "sortOrder": listVolumeGroupsRequest.sortOrder,
      "lifecycleState": listVolumeGroupsRequest.lifecycleState
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/volumeGroups",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListVolumeGroupsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "VolumeGroup[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.VolumeGroup objects
   * contained in responses from the listVolumeGroups operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllVolumeGroups(
    request: requests.ListVolumeGroupsRequest
  ): AsyncIterableIterator<models.VolumeGroup> {
    return paginateRecords(request, req => this.listVolumeGroups(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listVolumeGroups operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllVolumeGroupsResponses(
    request: requests.ListVolumeGroupsRequest
  ): AsyncIterableIterator<responses.ListVolumeGroupsResponse> {
    return paginateResponses(request, req => this.listVolumeGroups(req));
  }

  /**
   * Lists the volumes in the specified compartment and availability domain.
   *
   * @param ListVolumesRequest
   * @return ListVolumesResponse
   * @throws OciError when an error occurs
   */
  public async listVolumes(
    listVolumesRequest: requests.ListVolumesRequest
  ): Promise<responses.ListVolumesResponse> {
    const pathParams = {};

    const queryParams = {
      "availabilityDomain": listVolumesRequest.availabilityDomain,
      "compartmentId": listVolumesRequest.compartmentId,
      "limit": listVolumesRequest.limit,
      "page": listVolumesRequest.page,
      "displayName": listVolumesRequest.displayName,
      "sortBy": listVolumesRequest.sortBy,
      "sortOrder": listVolumesRequest.sortOrder,
      "volumeGroupId": listVolumesRequest.volumeGroupId,
      "lifecycleState": listVolumesRequest.lifecycleState
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/volumes",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListVolumesResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "Volume[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.Volume objects
   * contained in responses from the listVolumes operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllVolumes(
    request: requests.ListVolumesRequest
  ): AsyncIterableIterator<models.Volume> {
    return paginateRecords(request, req => this.listVolumes(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listVolumes operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllVolumesResponses(
    request: requests.ListVolumesRequest
  ): AsyncIterableIterator<responses.ListVolumesResponse> {
    return paginateResponses(request, req => this.listVolumes(req));
  }

  /**
   * Updates the specified boot volume's display name, defined tags, and free-form tags.
   * @param UpdateBootVolumeRequest
   * @return UpdateBootVolumeResponse
   * @throws OciError when an error occurs
   */
  public async updateBootVolume(
    updateBootVolumeRequest: requests.UpdateBootVolumeRequest
  ): Promise<responses.UpdateBootVolumeResponse> {
    const pathParams = {
      "{bootVolumeId}": updateBootVolumeRequest.bootVolumeId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateBootVolumeRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/bootVolumes/{bootVolumeId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateBootVolumeRequest.updateBootVolumeDetails,
        "UpdateBootVolumeDetails",
        models.UpdateBootVolumeDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateBootVolumeResponse>{},
        body: await response.json(),
        bodyKey: "bootVolume",
        bodyModel: "model.BootVolume",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates the display name for the specified boot volume backup.
   * Avoid entering confidential information.
   *
   * @param UpdateBootVolumeBackupRequest
   * @return UpdateBootVolumeBackupResponse
   * @throws OciError when an error occurs
   */
  public async updateBootVolumeBackup(
    updateBootVolumeBackupRequest: requests.UpdateBootVolumeBackupRequest
  ): Promise<responses.UpdateBootVolumeBackupResponse> {
    const pathParams = {
      "{bootVolumeBackupId}": updateBootVolumeBackupRequest.bootVolumeBackupId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateBootVolumeBackupRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/bootVolumeBackups/{bootVolumeBackupId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateBootVolumeBackupRequest.updateBootVolumeBackupDetails,
        "UpdateBootVolumeBackupDetails",
        models.UpdateBootVolumeBackupDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateBootVolumeBackupResponse>{},
        body: await response.json(),
        bodyKey: "bootVolumeBackup",
        bodyModel: "model.BootVolumeBackup",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates the specified volume with a new Key Management master encryption key.
   *
   * @param UpdateBootVolumeKmsKeyRequest
   * @return UpdateBootVolumeKmsKeyResponse
   * @throws OciError when an error occurs
   */
  public async updateBootVolumeKmsKey(
    updateBootVolumeKmsKeyRequest: requests.UpdateBootVolumeKmsKeyRequest
  ): Promise<responses.UpdateBootVolumeKmsKeyResponse> {
    const pathParams = {
      "{bootVolumeId}": updateBootVolumeKmsKeyRequest.bootVolumeId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateBootVolumeKmsKeyRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/bootVolumes/{bootVolumeId}/kmsKey",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateBootVolumeKmsKeyRequest.updateBootVolumeKmsKeyDetails,
        "UpdateBootVolumeKmsKeyDetails",
        models.UpdateBootVolumeKmsKeyDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateBootVolumeKmsKeyResponse>{},
        body: await response.json(),
        bodyKey: "bootVolumeKmsKey",
        bodyModel: "model.BootVolumeKmsKey",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates the specified volume's display name.
   * Avoid entering confidential information.
   *
   * @param UpdateVolumeRequest
   * @return UpdateVolumeResponse
   * @throws OciError when an error occurs
   */
  public async updateVolume(
    updateVolumeRequest: requests.UpdateVolumeRequest
  ): Promise<responses.UpdateVolumeResponse> {
    const pathParams = {
      "{volumeId}": updateVolumeRequest.volumeId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateVolumeRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/volumes/{volumeId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateVolumeRequest.updateVolumeDetails,
        "UpdateVolumeDetails",
        models.UpdateVolumeDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateVolumeResponse>{},
        body: await response.json(),
        bodyKey: "volume",
        bodyModel: "model.Volume",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates the display name for the specified volume backup.
   * Avoid entering confidential information.
   *
   * @param UpdateVolumeBackupRequest
   * @return UpdateVolumeBackupResponse
   * @throws OciError when an error occurs
   */
  public async updateVolumeBackup(
    updateVolumeBackupRequest: requests.UpdateVolumeBackupRequest
  ): Promise<responses.UpdateVolumeBackupResponse> {
    const pathParams = {
      "{volumeBackupId}": updateVolumeBackupRequest.volumeBackupId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateVolumeBackupRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/volumeBackups/{volumeBackupId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateVolumeBackupRequest.updateVolumeBackupDetails,
        "UpdateVolumeBackupDetails",
        models.UpdateVolumeBackupDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateVolumeBackupResponse>{},
        body: await response.json(),
        bodyKey: "volumeBackup",
        bodyModel: "model.VolumeBackup",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Updates a user defined backup policy.
*  For more information about user defined backup policies,
*  see [Policy-Based Backups](https://docs.cloud.oracle.com/iaas/Content/Block/Tasks/schedulingvolumebackups.htm#UserDefinedBackupPolicies).
* <p>
 Avoid entering confidential information.
* 
     * @param UpdateVolumeBackupPolicyRequest
     * @return UpdateVolumeBackupPolicyResponse
     * @throws OciError when an error occurs
     */
  public async updateVolumeBackupPolicy(
    updateVolumeBackupPolicyRequest: requests.UpdateVolumeBackupPolicyRequest
  ): Promise<responses.UpdateVolumeBackupPolicyResponse> {
    const pathParams = {
      "{policyId}": updateVolumeBackupPolicyRequest.policyId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateVolumeBackupPolicyRequest.ifMatch,
      "opc-request-id": updateVolumeBackupPolicyRequest.opcRequestId,
      "opc-retry-token": updateVolumeBackupPolicyRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/volumeBackupPolicies/{policyId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateVolumeBackupPolicyRequest.updateVolumeBackupPolicyDetails,
        "UpdateVolumeBackupPolicyDetails",
        models.UpdateVolumeBackupPolicyDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateVolumeBackupPolicyResponse>{},
        body: await response.json(),
        bodyKey: "volumeBackupPolicy",
        bodyModel: "model.VolumeBackupPolicy",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Updates the set of volumes in a volume group along with the display name. Use this operation
* to add or remove volumes in a volume group. Specify the full list of volume IDs to include in the
* volume group. If the volume ID is not specified in the call, it will be removed from the volume group.
* Avoid entering confidential information.
* <p>
For more information, see [Volume Groups](https://docs.cloud.oracle.com/Content/Block/Concepts/volumegroups.htm).
* 
     * @param UpdateVolumeGroupRequest
     * @return UpdateVolumeGroupResponse
     * @throws OciError when an error occurs
     */
  public async updateVolumeGroup(
    updateVolumeGroupRequest: requests.UpdateVolumeGroupRequest
  ): Promise<responses.UpdateVolumeGroupResponse> {
    const pathParams = {
      "{volumeGroupId}": updateVolumeGroupRequest.volumeGroupId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateVolumeGroupRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/volumeGroups/{volumeGroupId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateVolumeGroupRequest.updateVolumeGroupDetails,
        "UpdateVolumeGroupDetails",
        models.UpdateVolumeGroupDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateVolumeGroupResponse>{},
        body: await response.json(),
        bodyKey: "volumeGroup",
        bodyModel: "model.VolumeGroup",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates the display name for the specified volume group backup. For more information, see [Volume Groups](https://docs.cloud.oracle.com/Content/Block/Concepts/volumegroups.htm).
   * @param UpdateVolumeGroupBackupRequest
   * @return UpdateVolumeGroupBackupResponse
   * @throws OciError when an error occurs
   */
  public async updateVolumeGroupBackup(
    updateVolumeGroupBackupRequest: requests.UpdateVolumeGroupBackupRequest
  ): Promise<responses.UpdateVolumeGroupBackupResponse> {
    const pathParams = {
      "{volumeGroupBackupId}": updateVolumeGroupBackupRequest.volumeGroupBackupId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateVolumeGroupBackupRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/volumeGroupBackups/{volumeGroupBackupId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateVolumeGroupBackupRequest.updateVolumeGroupBackupDetails,
        "UpdateVolumeGroupBackupDetails",
        models.UpdateVolumeGroupBackupDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateVolumeGroupBackupResponse>{},
        body: await response.json(),
        bodyKey: "volumeGroupBackup",
        bodyModel: "model.VolumeGroupBackup",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates the specified volume with a new Key Management master encryption key.
   *
   * @param UpdateVolumeKmsKeyRequest
   * @return UpdateVolumeKmsKeyResponse
   * @throws OciError when an error occurs
   */
  public async updateVolumeKmsKey(
    updateVolumeKmsKeyRequest: requests.UpdateVolumeKmsKeyRequest
  ): Promise<responses.UpdateVolumeKmsKeyResponse> {
    const pathParams = {
      "{volumeId}": updateVolumeKmsKeyRequest.volumeId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateVolumeKmsKeyRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/volumes/{volumeId}/kmsKey",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateVolumeKmsKeyRequest.updateVolumeKmsKeyDetails,
        "UpdateVolumeKmsKeyDetails",
        models.UpdateVolumeKmsKeyDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateVolumeKmsKeyResponse>{},
        body: await response.json(),
        bodyKey: "volumeKmsKey",
        bodyModel: "model.VolumeKmsKey",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }
}
export enum ComputeApiKeys {}

export class ComputeClient {
  protected static serviceEndpointTemplate = "https://iaas.{region}.{secondLevelDomain}";
  protected "_endpoint": string = "";
  protected "_defaultHeaders": any = {};
  protected "_waiters": ComputeWaiter;

  protected _httpClient: common.HttpClient;

  constructor(params: common.AuthParams) {
    const requestSigner = params.authenticationDetailsProvider
      ? new common.DefaultRequestSigner(params.authenticationDetailsProvider)
      : null;
    this._httpClient = params.httpClient || new common.FetchHttpClient(requestSigner);

    if (
      params.authenticationDetailsProvider &&
      common.isRegionProvider(params.authenticationDetailsProvider)
    ) {
      const provider: common.RegionProvider = params.authenticationDetailsProvider;
      if (provider.getRegion()) {
        this.region = provider.getRegion();
      }
    }
  }

  /**
   * Sets the endpoint to call (ex, https://www.example.com).
   * @param endpoint The endpoint of the service.
   */
  public set endpoint(endpoint: string) {
    this._endpoint = endpoint;
    this._endpoint = this._endpoint + "/20160918";
  }

  /**
   * Sets the region to call (ex, Region.US_PHOENIX_1).
   * Note, this will call {@link #endpoint(String) endpoint} after resolving the endpoint.
   * @param region The region of the service.
   */
  public set region(region: common.Region) {
    this.endpoint = common.EndpointBuilder.createEndpointFromRegion(
      ComputeClient.serviceEndpointTemplate,
      region
    );
  }

  /**
   * Sets the regionId to call (ex, 'us-phoenix-1').
   *
   * Note, this will first try to map the region ID to a known Region and call {@link #region(Region) region}.
   * If no known Region could be determined, it will create an endpoint assuming its in default Realm OC1
   * and then call {@link #endpoint(String) endpoint}.
   * @param regionId The public region ID.
   */
  public set regionId(regionId: string) {
    this.endpoint = common.EndpointBuilder.createEndpointFromRegionId(
      ComputeClient.serviceEndpointTemplate,
      regionId
    );
  }

  /**
   * Creates a new ComputeWaiter for resources for this service.
   *
   * @param workRequestClient The work request service client used to query for work request status
   * @param config The waiter configuration for termination and delay strategy
   * @return The service waiters.
   */
  public createWaiters(
    workRequestClient: WorkRequestClient,
    config?: common.WaiterConfiguration
  ): ComputeWaiter {
    this._waiters = new ComputeWaiter(this, workRequestClient, config);
    return this._waiters;
  }

  /**
   * Gets the waiters available for resources for this service.
   *
   * @return The service waiters.
   */
  public getWaiters(): ComputeWaiter {
    if (this._waiters) {
      return this._waiters;
    }
    throw Error("Waiters do not exist. Please create waiters.");
  }

  /**
   * Adds a shape to the compatible shapes list for the image.
   * @param AddImageShapeCompatibilityEntryRequest
   * @return AddImageShapeCompatibilityEntryResponse
   * @throws OciError when an error occurs
   */
  public async addImageShapeCompatibilityEntry(
    addImageShapeCompatibilityEntryRequest: requests.AddImageShapeCompatibilityEntryRequest
  ): Promise<responses.AddImageShapeCompatibilityEntryResponse> {
    const pathParams = {
      "{imageId}": addImageShapeCompatibilityEntryRequest.imageId,
      "{shapeName}": addImageShapeCompatibilityEntryRequest.shapeName
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/images/{imageId}/shapes/{shapeName}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        addImageShapeCompatibilityEntryRequest.addImageShapeCompatibilityEntryDetails,
        "AddImageShapeCompatibilityEntryDetails",
        models.AddImageShapeCompatibilityEntryDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.AddImageShapeCompatibilityEntryResponse>{},
        body: await response.json(),
        bodyKey: "imageShapeCompatibilityEntry",
        bodyModel: "model.ImageShapeCompatibilityEntry",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Attaches the specified boot volume to the specified instance.
   *
   * @param AttachBootVolumeRequest
   * @return AttachBootVolumeResponse
   * @throws OciError when an error occurs
   */
  public async attachBootVolume(
    attachBootVolumeRequest: requests.AttachBootVolumeRequest
  ): Promise<responses.AttachBootVolumeResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": attachBootVolumeRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/bootVolumeAttachments",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        attachBootVolumeRequest.attachBootVolumeDetails,
        "AttachBootVolumeDetails",
        models.AttachBootVolumeDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.AttachBootVolumeResponse>{},
        body: await response.json(),
        bodyKey: "bootVolumeAttachment",
        bodyModel: "model.BootVolumeAttachment",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a secondary VNIC and attaches it to the specified instance.
   * For more information about secondary VNICs, see
   * [Virtual Network Interface Cards (VNICs)](https://docs.cloud.oracle.com/Content/Network/Tasks/managingVNICs.htm).
   *
   * @param AttachVnicRequest
   * @return AttachVnicResponse
   * @throws OciError when an error occurs
   */
  public async attachVnic(
    attachVnicRequest: requests.AttachVnicRequest
  ): Promise<responses.AttachVnicResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": attachVnicRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/vnicAttachments",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        attachVnicRequest.attachVnicDetails,
        "AttachVnicDetails",
        models.AttachVnicDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.AttachVnicResponse>{},
        body: await response.json(),
        bodyKey: "vnicAttachment",
        bodyModel: "model.VnicAttachment",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Attaches the specified storage volume to the specified instance.
   *
   * @param AttachVolumeRequest
   * @return AttachVolumeResponse
   * @throws OciError when an error occurs
   */
  public async attachVolume(
    attachVolumeRequest: requests.AttachVolumeRequest
  ): Promise<responses.AttachVolumeResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": attachVolumeRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/volumeAttachments",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        attachVolumeRequest.attachVolumeDetails,
        "AttachVolumeDetails",
        models.AttachVolumeDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.AttachVolumeResponse>{},
        body: await response.json(),
        bodyKey: "volumeAttachment",
        bodyModel: "model.VolumeAttachment",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Captures the most recent serial console data (up to a megabyte) for the
* specified instance.
* <p>
The `CaptureConsoleHistory` operation works with the other console history operations
* as described below.
* <p>
1. Use `CaptureConsoleHistory` to request the capture of up to a megabyte of the
* most recent console history. This call returns a `ConsoleHistory`
* object. The object will have a state of REQUESTED.
* 2. Wait for the capture operation to succeed by polling `GetConsoleHistory` with
* the identifier of the console history metadata. The state of the
* `ConsoleHistory` object will go from REQUESTED to GETTING-HISTORY and
* then SUCCEEDED (or FAILED).
* 3. Use `GetConsoleHistoryContent` to get the actual console history data (not the
* metadata).
* 4. Optionally, use `DeleteConsoleHistory` to delete the console history metadata
* and the console history data.
* 
     * @param CaptureConsoleHistoryRequest
     * @return CaptureConsoleHistoryResponse
     * @throws OciError when an error occurs
     */
  public async captureConsoleHistory(
    captureConsoleHistoryRequest: requests.CaptureConsoleHistoryRequest
  ): Promise<responses.CaptureConsoleHistoryResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": captureConsoleHistoryRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/instanceConsoleHistories",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        captureConsoleHistoryRequest.captureConsoleHistoryDetails,
        "CaptureConsoleHistoryDetails",
        models.CaptureConsoleHistoryDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CaptureConsoleHistoryResponse>{},
        body: await response.json(),
        bodyKey: "consoleHistory",
        bodyModel: "model.ConsoleHistory",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Moves a dedicated virtual machine host from one compartment to another.
   * @param ChangeDedicatedVmHostCompartmentRequest
   * @return ChangeDedicatedVmHostCompartmentResponse
   * @throws OciError when an error occurs
   */
  public async changeDedicatedVmHostCompartment(
    changeDedicatedVmHostCompartmentRequest: requests.ChangeDedicatedVmHostCompartmentRequest
  ): Promise<responses.ChangeDedicatedVmHostCompartmentResponse> {
    const pathParams = {
      "{dedicatedVmHostId}": changeDedicatedVmHostCompartmentRequest.dedicatedVmHostId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": changeDedicatedVmHostCompartmentRequest.ifMatch,
      "opc-request-id": changeDedicatedVmHostCompartmentRequest.opcRequestId,
      "opc-retry-token": changeDedicatedVmHostCompartmentRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/dedicatedVmHosts/{dedicatedVmHostId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeDedicatedVmHostCompartmentRequest.changeDedicatedVmHostCompartmentDetails,
        "ChangeDedicatedVmHostCompartmentDetails",
        models.ChangeDedicatedVmHostCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeDedicatedVmHostCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Moves an image into a different compartment within the same tenancy. For information about moving
   * resources between compartments, see
   * [Moving Resources to a Different Compartment](https://docs.cloud.oracle.com/iaas/Content/Identity/Tasks/managingcompartments.htm#moveRes).
   *
   * @param ChangeImageCompartmentRequest
   * @return ChangeImageCompartmentResponse
   * @throws OciError when an error occurs
   */
  public async changeImageCompartment(
    changeImageCompartmentRequest: requests.ChangeImageCompartmentRequest
  ): Promise<responses.ChangeImageCompartmentResponse> {
    const pathParams = {
      "{imageId}": changeImageCompartmentRequest.imageId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": changeImageCompartmentRequest.ifMatch,
      "opc-request-id": changeImageCompartmentRequest.opcRequestId,
      "opc-retry-token": changeImageCompartmentRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/images/{imageId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeImageCompartmentRequest.changeImageCompartmentDetails,
        "ChangeImageCompartmentDetails",
        models.ChangeImageCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeImageCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Moves an instance into a different compartment within the same tenancy. For information about
* moving resources between compartments, see
* [Moving Resources to a Different Compartment](https://docs.cloud.oracle.com/iaas/Content/Identity/Tasks/managingcompartments.htm#moveRes).
* <p>
When you move an instance to a different compartment, associated resources such as boot volumes and VNICs
* are not moved.
* 
     * @param ChangeInstanceCompartmentRequest
     * @return ChangeInstanceCompartmentResponse
     * @throws OciError when an error occurs
     */
  public async changeInstanceCompartment(
    changeInstanceCompartmentRequest: requests.ChangeInstanceCompartmentRequest
  ): Promise<responses.ChangeInstanceCompartmentResponse> {
    const pathParams = {
      "{instanceId}": changeInstanceCompartmentRequest.instanceId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": changeInstanceCompartmentRequest.ifMatch,
      "opc-request-id": changeInstanceCompartmentRequest.opcRequestId,
      "opc-retry-token": changeInstanceCompartmentRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/instances/{instanceId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeInstanceCompartmentRequest.changeInstanceCompartmentDetails,
        "ChangeInstanceCompartmentDetails",
        models.ChangeInstanceCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeInstanceCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Create a subscription for listing resource version for a compartment. It will take some time to propagate to all regions.
   *
   * @param CreateAppCatalogSubscriptionRequest
   * @return CreateAppCatalogSubscriptionResponse
   * @throws OciError when an error occurs
   */
  public async createAppCatalogSubscription(
    createAppCatalogSubscriptionRequest: requests.CreateAppCatalogSubscriptionRequest
  ): Promise<responses.CreateAppCatalogSubscriptionResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createAppCatalogSubscriptionRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/appCatalogSubscriptions",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createAppCatalogSubscriptionRequest.createAppCatalogSubscriptionDetails,
        "CreateAppCatalogSubscriptionDetails",
        models.CreateAppCatalogSubscriptionDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateAppCatalogSubscriptionResponse>{},
        body: await response.json(),
        bodyKey: "appCatalogSubscription",
        bodyModel: "model.AppCatalogSubscription",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new dedicated virtual machine host in the specified compartment and the specified availability domain.
   * Dedicated virtual machine hosts enable you to run your Compute virtual machine (VM) instances on dedicated servers
   * that are a single tenant and not shared with other customers.
   * For more information, see [Dedicated Virtual Machine Hosts](https://docs.cloud.oracle.com/iaas/Content/Compute/Concepts/dedicatedvmhosts.htm).
   *
   * @param CreateDedicatedVmHostRequest
   * @return CreateDedicatedVmHostResponse
   * @throws OciError when an error occurs
   */
  public async createDedicatedVmHost(
    createDedicatedVmHostRequest: requests.CreateDedicatedVmHostRequest
  ): Promise<responses.CreateDedicatedVmHostResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-request-id": createDedicatedVmHostRequest.opcRequestId,
      "opc-retry-token": createDedicatedVmHostRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/dedicatedVmHosts",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createDedicatedVmHostRequest.createDedicatedVmHostDetails,
        "CreateDedicatedVmHostDetails",
        models.CreateDedicatedVmHostDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateDedicatedVmHostResponse>{},
        body: await response.json(),
        bodyKey: "dedicatedVmHost",
        bodyModel: "model.DedicatedVmHost",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Creates a boot disk image for the specified instance or imports an exported image from the Oracle Cloud Infrastructure Object Storage service.
* <p>
When creating a new image, you must provide the OCID of the instance you want to use as the basis for the image, and
* the OCID of the compartment containing that instance. For more information about images,
* see [Managing Custom Images](https://docs.cloud.oracle.com/Content/Compute/Tasks/managingcustomimages.htm).
* <p>
When importing an exported image from Object Storage, you specify the source information
* in {@link #imageSourceDetails(ImageSourceDetailsRequest) imageSourceDetails}.
* <p>
When importing an image based on the namespace, bucket name, and object name,
* use {@link #imageSourceViaObjectStorageTupleDetails(ImageSourceViaObjectStorageTupleDetailsRequest) imageSourceViaObjectStorageTupleDetails}.
* <p>
When importing an image based on the Object Storage URL, use
* {@link #imageSourceViaObjectStorageUriDetails(ImageSourceViaObjectStorageUriDetailsRequest) imageSourceViaObjectStorageUriDetails}.
* See [Object Storage URLs](https://docs.cloud.oracle.com/Content/Compute/Tasks/imageimportexport.htm#URLs) and [Using Pre-Authenticated Requests](https://docs.cloud.oracle.com/Content/Object/Tasks/usingpreauthenticatedrequests.htm)
* for constructing URLs for image import/export.
* <p>
For more information about importing exported images, see
* [Image Import/Export](https://docs.cloud.oracle.com/Content/Compute/Tasks/imageimportexport.htm).
* <p>
You may optionally specify a *display name* for the image, which is simply a friendly name or description.
* It does not have to be unique, and you can change it. See {@link #updateImage(UpdateImageRequest) updateImage}.
* Avoid entering confidential information.
* 
     * @param CreateImageRequest
     * @return CreateImageResponse
     * @throws OciError when an error occurs
     */
  public async createImage(
    createImageRequest: requests.CreateImageRequest
  ): Promise<responses.CreateImageResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createImageRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/images",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createImageRequest.createImageDetails,
        "CreateImageDetails",
        models.CreateImageDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateImageResponse>{},
        body: await response.json(),
        bodyKey: "image",
        bodyModel: "model.Image",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Creates a new console connection to the specified instance.
* After the console connection has been created and is available,
* you connect to the console using SSH.
* <p>
For more information about console access, see [Accessing the Console](https://docs.cloud.oracle.com/Content/Compute/References/serialconsole.htm).
* 
     * @param CreateInstanceConsoleConnectionRequest
     * @return CreateInstanceConsoleConnectionResponse
     * @throws OciError when an error occurs
     */
  public async createInstanceConsoleConnection(
    createInstanceConsoleConnectionRequest: requests.CreateInstanceConsoleConnectionRequest
  ): Promise<responses.CreateInstanceConsoleConnectionResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createInstanceConsoleConnectionRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/instanceConsoleConnections",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createInstanceConsoleConnectionRequest.createInstanceConsoleConnectionDetails,
        "CreateInstanceConsoleConnectionDetails",
        models.CreateInstanceConsoleConnectionDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateInstanceConsoleConnectionResponse>{},
        body: await response.json(),
        bodyKey: "instanceConsoleConnection",
        bodyModel: "model.InstanceConsoleConnection",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Delete a subscription for a listing resource version for a compartment.
   * @param DeleteAppCatalogSubscriptionRequest
   * @return DeleteAppCatalogSubscriptionResponse
   * @throws OciError when an error occurs
   */
  public async deleteAppCatalogSubscription(
    deleteAppCatalogSubscriptionRequest: requests.DeleteAppCatalogSubscriptionRequest
  ): Promise<responses.DeleteAppCatalogSubscriptionResponse> {
    const pathParams = {};

    const queryParams = {
      "listingId": deleteAppCatalogSubscriptionRequest.listingId,
      "compartmentId": deleteAppCatalogSubscriptionRequest.compartmentId,
      "resourceVersion": deleteAppCatalogSubscriptionRequest.resourceVersion
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/appCatalogSubscriptions",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteAppCatalogSubscriptionResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Deletes the specified console history metadata and the console history data.
   * @param DeleteConsoleHistoryRequest
   * @return DeleteConsoleHistoryResponse
   * @throws OciError when an error occurs
   */
  public async deleteConsoleHistory(
    deleteConsoleHistoryRequest: requests.DeleteConsoleHistoryRequest
  ): Promise<responses.DeleteConsoleHistoryResponse> {
    const pathParams = {
      "{instanceConsoleHistoryId}": deleteConsoleHistoryRequest.instanceConsoleHistoryId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteConsoleHistoryRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/instanceConsoleHistories/{instanceConsoleHistoryId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteConsoleHistoryResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Deletes the specified dedicated virtual machine host.
* <p>
If any VM instances are assigned to the dedicated virtual machine host,
* the delete operation will fail and the service will return a 409 response code.
* 
     * @param DeleteDedicatedVmHostRequest
     * @return DeleteDedicatedVmHostResponse
     * @throws OciError when an error occurs
     */
  public async deleteDedicatedVmHost(
    deleteDedicatedVmHostRequest: requests.DeleteDedicatedVmHostRequest
  ): Promise<responses.DeleteDedicatedVmHostResponse> {
    const pathParams = {
      "{dedicatedVmHostId}": deleteDedicatedVmHostRequest.dedicatedVmHostId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": deleteDedicatedVmHostRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/dedicatedVmHosts/{dedicatedVmHostId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteDedicatedVmHostResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Deletes an image.
   * @param DeleteImageRequest
   * @return DeleteImageResponse
   * @throws OciError when an error occurs
   */
  public async deleteImage(
    deleteImageRequest: requests.DeleteImageRequest
  ): Promise<responses.DeleteImageResponse> {
    const pathParams = {
      "{imageId}": deleteImageRequest.imageId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteImageRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/images/{imageId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteImageResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Deletes the specified instance console connection.
   * @param DeleteInstanceConsoleConnectionRequest
   * @return DeleteInstanceConsoleConnectionResponse
   * @throws OciError when an error occurs
   */
  public async deleteInstanceConsoleConnection(
    deleteInstanceConsoleConnectionRequest: requests.DeleteInstanceConsoleConnectionRequest
  ): Promise<responses.DeleteInstanceConsoleConnectionResponse> {
    const pathParams = {
      "{instanceConsoleConnectionId}":
        deleteInstanceConsoleConnectionRequest.instanceConsoleConnectionId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteInstanceConsoleConnectionRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/instanceConsoleConnections/{instanceConsoleConnectionId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteInstanceConsoleConnectionResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Detaches a boot volume from an instance. You must specify the OCID of the boot volume attachment.
* <p>
This is an asynchronous operation. The attachment's `lifecycleState` will change to DETACHING temporarily
* until the attachment is completely removed.
* 
     * @param DetachBootVolumeRequest
     * @return DetachBootVolumeResponse
     * @throws OciError when an error occurs
     */
  public async detachBootVolume(
    detachBootVolumeRequest: requests.DetachBootVolumeRequest
  ): Promise<responses.DetachBootVolumeResponse> {
    const pathParams = {
      "{bootVolumeAttachmentId}": detachBootVolumeRequest.bootVolumeAttachmentId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": detachBootVolumeRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/bootVolumeAttachments/{bootVolumeAttachmentId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DetachBootVolumeResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Detaches and deletes the specified secondary VNIC.
   * This operation cannot be used on the instance's primary VNIC.
   * When you terminate an instance, all attached VNICs (primary
   * and secondary) are automatically detached and deleted.
   * <p>
   **Important:** If the VNIC has a
   * {@link PrivateIp} that is the
   * [target of a route rule](https://docs.cloud.oracle.com/Content/Network/Tasks/managingroutetables.htm#privateip),
   * deleting the VNIC causes that route rule to blackhole and the traffic
   * will be dropped.
   *
   * @param DetachVnicRequest
   * @return DetachVnicResponse
   * @throws OciError when an error occurs
   */
  public async detachVnic(
    detachVnicRequest: requests.DetachVnicRequest
  ): Promise<responses.DetachVnicResponse> {
    const pathParams = {
      "{vnicAttachmentId}": detachVnicRequest.vnicAttachmentId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": detachVnicRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/vnicAttachments/{vnicAttachmentId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DetachVnicResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Detaches a storage volume from an instance. You must specify the OCID of the volume attachment.
* <p>
This is an asynchronous operation. The attachment's `lifecycleState` will change to DETACHING temporarily
* until the attachment is completely removed.
* 
     * @param DetachVolumeRequest
     * @return DetachVolumeResponse
     * @throws OciError when an error occurs
     */
  public async detachVolume(
    detachVolumeRequest: requests.DetachVolumeRequest
  ): Promise<responses.DetachVolumeResponse> {
    const pathParams = {
      "{volumeAttachmentId}": detachVolumeRequest.volumeAttachmentId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": detachVolumeRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/volumeAttachments/{volumeAttachmentId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DetachVolumeResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Exports the specified image to the Oracle Cloud Infrastructure Object Storage service. You can use the Object Storage URL,
* or the namespace, bucket name, and object name when specifying the location to export to.
* <p>
For more information about exporting images, see [Image Import/Export](https://docs.cloud.oracle.com/Content/Compute/Tasks/imageimportexport.htm).
* <p>
To perform an image export, you need write access to the Object Storage bucket for the image,
* see [Let Users Write Objects to Object Storage Buckets](https://docs.cloud.oracle.com/Content/Identity/Concepts/commonpolicies.htm#Let4).
* <p>
See [Object Storage URLs](https://docs.cloud.oracle.com/Content/Compute/Tasks/imageimportexport.htm#URLs) and [Using Pre-Authenticated Requests](https://docs.cloud.oracle.com/Content/Object/Tasks/usingpreauthenticatedrequests.htm)
* for constructing URLs for image import/export.
* 
     * @param ExportImageRequest
     * @return ExportImageResponse
     * @throws OciError when an error occurs
     */
  public async exportImage(
    exportImageRequest: requests.ExportImageRequest
  ): Promise<responses.ExportImageResponse> {
    const pathParams = {
      "{imageId}": exportImageRequest.imageId
    };

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": exportImageRequest.opcRetryToken,
      "if-match": exportImageRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/images/{imageId}/actions/export",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        exportImageRequest.exportImageDetails,
        "ExportImageDetails",
        models.ExportImageDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ExportImageResponse>{},
        body: await response.json(),
        bodyKey: "image",
        bodyModel: "model.Image",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the specified listing.
   * @param GetAppCatalogListingRequest
   * @return GetAppCatalogListingResponse
   * @throws OciError when an error occurs
   */
  public async getAppCatalogListing(
    getAppCatalogListingRequest: requests.GetAppCatalogListingRequest
  ): Promise<responses.GetAppCatalogListingResponse> {
    const pathParams = {
      "{listingId}": getAppCatalogListingRequest.listingId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/appCatalogListings/{listingId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetAppCatalogListingResponse>{},
        body: await response.json(),
        bodyKey: "appCatalogListing",
        bodyModel: "model.AppCatalogListing",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Retrieves the agreements for a particular resource version of a listing.
   * @param GetAppCatalogListingAgreementsRequest
   * @return GetAppCatalogListingAgreementsResponse
   * @throws OciError when an error occurs
   */
  public async getAppCatalogListingAgreements(
    getAppCatalogListingAgreementsRequest: requests.GetAppCatalogListingAgreementsRequest
  ): Promise<responses.GetAppCatalogListingAgreementsResponse> {
    const pathParams = {
      "{listingId}": getAppCatalogListingAgreementsRequest.listingId,
      "{resourceVersion}": getAppCatalogListingAgreementsRequest.resourceVersion
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/appCatalogListings/{listingId}/resourceVersions/{resourceVersion}/agreements",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetAppCatalogListingAgreementsResponse>{},
        body: await response.json(),
        bodyKey: "appCatalogListingResourceVersionAgreements",
        bodyModel: "model.AppCatalogListingResourceVersionAgreements",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the specified listing resource version.
   * @param GetAppCatalogListingResourceVersionRequest
   * @return GetAppCatalogListingResourceVersionResponse
   * @throws OciError when an error occurs
   */
  public async getAppCatalogListingResourceVersion(
    getAppCatalogListingResourceVersionRequest: requests.GetAppCatalogListingResourceVersionRequest
  ): Promise<responses.GetAppCatalogListingResourceVersionResponse> {
    const pathParams = {
      "{listingId}": getAppCatalogListingResourceVersionRequest.listingId,
      "{resourceVersion}": getAppCatalogListingResourceVersionRequest.resourceVersion
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/appCatalogListings/{listingId}/resourceVersions/{resourceVersion}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetAppCatalogListingResourceVersionResponse>{},
        body: await response.json(),
        bodyKey: "appCatalogListingResourceVersion",
        bodyModel: "model.AppCatalogListingResourceVersion",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets information about the specified boot volume attachment.
   * @param GetBootVolumeAttachmentRequest
   * @return GetBootVolumeAttachmentResponse
   * @throws OciError when an error occurs
   */
  public async getBootVolumeAttachment(
    getBootVolumeAttachmentRequest: requests.GetBootVolumeAttachmentRequest
  ): Promise<responses.GetBootVolumeAttachmentResponse> {
    const pathParams = {
      "{bootVolumeAttachmentId}": getBootVolumeAttachmentRequest.bootVolumeAttachmentId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/bootVolumeAttachments/{bootVolumeAttachmentId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetBootVolumeAttachmentResponse>{},
        body: await response.json(),
        bodyKey: "bootVolumeAttachment",
        bodyModel: "model.BootVolumeAttachment",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Shows the metadata for the specified console history.
   * See {@link #captureConsoleHistory(CaptureConsoleHistoryRequest) captureConsoleHistory}
   * for details about using the console history operations.
   *
   * @param GetConsoleHistoryRequest
   * @return GetConsoleHistoryResponse
   * @throws OciError when an error occurs
   */
  public async getConsoleHistory(
    getConsoleHistoryRequest: requests.GetConsoleHistoryRequest
  ): Promise<responses.GetConsoleHistoryResponse> {
    const pathParams = {
      "{instanceConsoleHistoryId}": getConsoleHistoryRequest.instanceConsoleHistoryId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/instanceConsoleHistories/{instanceConsoleHistoryId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetConsoleHistoryResponse>{},
        body: await response.json(),
        bodyKey: "consoleHistory",
        bodyModel: "model.ConsoleHistory",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the actual console history data (not the metadata).
   * See {@link #captureConsoleHistory(CaptureConsoleHistoryRequest) captureConsoleHistory}
   * for details about using the console history operations.
   *
   * @param GetConsoleHistoryContentRequest
   * @return GetConsoleHistoryContentResponse
   * @throws OciError when an error occurs
   */
  public async getConsoleHistoryContent(
    getConsoleHistoryContentRequest: requests.GetConsoleHistoryContentRequest
  ): Promise<responses.GetConsoleHistoryContentResponse> {
    const pathParams = {
      "{instanceConsoleHistoryId}": getConsoleHistoryContentRequest.instanceConsoleHistoryId
    };

    const queryParams = {
      "offset": getConsoleHistoryContentRequest.offset,
      "length": getConsoleHistoryContentRequest.length
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/instanceConsoleHistories/{instanceConsoleHistoryId}/data",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetConsoleHistoryContentResponse>{},
        body: await response.json(),
        bodyKey: "value",
        bodyModel: "string",
        responseHeaders: [
          {
            value: response.headers.get("opc-bytes-remaining"),
            key: "opcBytesRemaining",
            dataType: "number"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets information about the specified dedicated virtual machine host.
   * @param GetDedicatedVmHostRequest
   * @return GetDedicatedVmHostResponse
   * @throws OciError when an error occurs
   */
  public async getDedicatedVmHost(
    getDedicatedVmHostRequest: requests.GetDedicatedVmHostRequest
  ): Promise<responses.GetDedicatedVmHostResponse> {
    const pathParams = {
      "{dedicatedVmHostId}": getDedicatedVmHostRequest.dedicatedVmHostId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getDedicatedVmHostRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/dedicatedVmHosts/{dedicatedVmHostId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetDedicatedVmHostResponse>{},
        body: await response.json(),
        bodyKey: "dedicatedVmHost",
        bodyModel: "model.DedicatedVmHost",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the specified image.
   * @param GetImageRequest
   * @return GetImageResponse
   * @throws OciError when an error occurs
   */
  public async getImage(
    getImageRequest: requests.GetImageRequest
  ): Promise<responses.GetImageResponse> {
    const pathParams = {
      "{imageId}": getImageRequest.imageId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/images/{imageId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetImageResponse>{},
        body: await response.json(),
        bodyKey: "image",
        bodyModel: "model.Image",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Retrieves an image shape compatibility entry.
   * @param GetImageShapeCompatibilityEntryRequest
   * @return GetImageShapeCompatibilityEntryResponse
   * @throws OciError when an error occurs
   */
  public async getImageShapeCompatibilityEntry(
    getImageShapeCompatibilityEntryRequest: requests.GetImageShapeCompatibilityEntryRequest
  ): Promise<responses.GetImageShapeCompatibilityEntryResponse> {
    const pathParams = {
      "{imageId}": getImageShapeCompatibilityEntryRequest.imageId,
      "{shapeName}": getImageShapeCompatibilityEntryRequest.shapeName
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getImageShapeCompatibilityEntryRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/images/{imageId}/shapes/{shapeName}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetImageShapeCompatibilityEntryResponse>{},
        body: await response.json(),
        bodyKey: "imageShapeCompatibilityEntry",
        bodyModel: "model.ImageShapeCompatibilityEntry",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets information about the specified instance.
   * @param GetInstanceRequest
   * @return GetInstanceResponse
   * @throws OciError when an error occurs
   */
  public async getInstance(
    getInstanceRequest: requests.GetInstanceRequest
  ): Promise<responses.GetInstanceResponse> {
    const pathParams = {
      "{instanceId}": getInstanceRequest.instanceId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/instances/{instanceId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetInstanceResponse>{},
        body: await response.json(),
        bodyKey: "instance",
        bodyModel: "model.Instance",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the specified instance console connection's information.
   * @param GetInstanceConsoleConnectionRequest
   * @return GetInstanceConsoleConnectionResponse
   * @throws OciError when an error occurs
   */
  public async getInstanceConsoleConnection(
    getInstanceConsoleConnectionRequest: requests.GetInstanceConsoleConnectionRequest
  ): Promise<responses.GetInstanceConsoleConnectionResponse> {
    const pathParams = {
      "{instanceConsoleConnectionId}":
        getInstanceConsoleConnectionRequest.instanceConsoleConnectionId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/instanceConsoleConnections/{instanceConsoleConnectionId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetInstanceConsoleConnectionResponse>{},
        body: await response.json(),
        bodyKey: "instanceConsoleConnection",
        bodyModel: "model.InstanceConsoleConnection",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the information for the specified VNIC attachment.
   *
   * @param GetVnicAttachmentRequest
   * @return GetVnicAttachmentResponse
   * @throws OciError when an error occurs
   */
  public async getVnicAttachment(
    getVnicAttachmentRequest: requests.GetVnicAttachmentRequest
  ): Promise<responses.GetVnicAttachmentResponse> {
    const pathParams = {
      "{vnicAttachmentId}": getVnicAttachmentRequest.vnicAttachmentId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/vnicAttachments/{vnicAttachmentId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetVnicAttachmentResponse>{},
        body: await response.json(),
        bodyKey: "vnicAttachment",
        bodyModel: "model.VnicAttachment",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets information about the specified volume attachment.
   * @param GetVolumeAttachmentRequest
   * @return GetVolumeAttachmentResponse
   * @throws OciError when an error occurs
   */
  public async getVolumeAttachment(
    getVolumeAttachmentRequest: requests.GetVolumeAttachmentRequest
  ): Promise<responses.GetVolumeAttachmentResponse> {
    const pathParams = {
      "{volumeAttachmentId}": getVolumeAttachmentRequest.volumeAttachmentId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/volumeAttachments/{volumeAttachmentId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetVolumeAttachmentResponse>{},
        body: await response.json(),
        bodyKey: "volumeAttachment",
        bodyModel: "model.VolumeAttachment",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the generated credentials for the instance. Only works for instances that require a password to log in, such as Windows.
   * For certain operating systems, users will be forced to change the initial credentials.
   *
   * @param GetWindowsInstanceInitialCredentialsRequest
   * @return GetWindowsInstanceInitialCredentialsResponse
   * @throws OciError when an error occurs
   */
  public async getWindowsInstanceInitialCredentials(
    getWindowsInstanceInitialCredentialsRequest: requests.GetWindowsInstanceInitialCredentialsRequest
  ): Promise<responses.GetWindowsInstanceInitialCredentialsResponse> {
    const pathParams = {
      "{instanceId}": getWindowsInstanceInitialCredentialsRequest.instanceId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/instances/{instanceId}/initialCredentials",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetWindowsInstanceInitialCredentialsResponse>{},
        body: await response.json(),
        bodyKey: "instanceCredentials",
        bodyModel: "model.InstanceCredentials",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Performs one of the following power actions on the specified instance:
* <p>
- **START** - Powers on the instance.
* <p>
- **STOP** - Powers off the instance.
* <p>
- **RESET** - Powers off the instance and then powers it back on.
* <p>
- **SOFTSTOP** - Gracefully shuts down the instance by sending a shutdown command to the operating system.
* If the applications that run on the instance take a long time to shut down, they could be improperly stopped, resulting
* in data corruption. To avoid this, shut down the instance using the commands available in the OS before you softstop the
* instance.
* <p>
- **SOFTRESET** - Gracefully reboots the instance by sending a shutdown command to the operating system, and
* then powers the instance back on.
* <p>
For more information, see [Stopping and Starting an Instance](https://docs.cloud.oracle.com/Content/Compute/Tasks/restartinginstance.htm).
* 
     * @param InstanceActionRequest
     * @return InstanceActionResponse
     * @throws OciError when an error occurs
     */
  public async instanceAction(
    instanceActionRequest: requests.InstanceActionRequest
  ): Promise<responses.InstanceActionResponse> {
    const pathParams = {
      "{instanceId}": instanceActionRequest.instanceId
    };

    const queryParams = {
      "action": instanceActionRequest.action
    };

    let headerParams = {
      "opc-retry-token": instanceActionRequest.opcRetryToken,
      "if-match": instanceActionRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/instances/{instanceId}",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.InstanceActionResponse>{},
        body: await response.json(),
        bodyKey: "instance",
        bodyModel: "model.Instance",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Creates a new instance in the specified compartment and the specified availability domain.
* For general information about instances, see
* [Overview of the Compute Service](https://docs.cloud.oracle.com/Content/Compute/Concepts/computeoverview.htm).
* <p>
For information about access control and compartments, see
* [Overview of the IAM Service](https://docs.cloud.oracle.com/Content/Identity/Concepts/overview.htm).
* <p>
For information about availability domains, see
* [Regions and Availability Domains](https://docs.cloud.oracle.com/Content/General/Concepts/regions.htm).
* To get a list of availability domains, use the `ListAvailabilityDomains` operation
* in the Identity and Access Management Service API.
* <p>
All Oracle Cloud Infrastructure resources, including instances, get an Oracle-assigned,
* unique ID called an Oracle Cloud Identifier (OCID).
* When you create a resource, you can find its OCID in the response. You can
* also retrieve a resource's OCID by using a List API operation
* on that resource type, or by viewing the resource in the Console.
* <p>
To launch an instance using an image or a boot volume use the `sourceDetails` parameter in {@link LaunchInstanceDetails}.
* <p>
When you launch an instance, it is automatically attached to a virtual
* network interface card (VNIC), called the *primary VNIC*. The VNIC
* has a private IP address from the subnet's CIDR. You can either assign a
* private IP address of your choice or let Oracle automatically assign one.
* You can choose whether the instance has a public IP address. To retrieve the
* addresses, use the {@link #listVnicAttachments(ListVnicAttachmentsRequest) listVnicAttachments}
* operation to get the VNIC ID for the instance, and then call
* {@link #getVnic(GetVnicRequest) getVnic} with the VNIC ID.
* <p>
You can later add secondary VNICs to an instance. For more information, see
* [Virtual Network Interface Cards (VNICs)](https://docs.cloud.oracle.com/Content/Network/Tasks/managingVNICs.htm).
* 
     * @param LaunchInstanceRequest
     * @return LaunchInstanceResponse
     * @throws OciError when an error occurs
     */
  public async launchInstance(
    launchInstanceRequest: requests.LaunchInstanceRequest
  ): Promise<responses.LaunchInstanceResponse> {
    const pathParams = {};

    const queryParams = {
      "opc-pool-name": launchInstanceRequest.opcPoolName
    };

    let headerParams = {
      "opc-retry-token": launchInstanceRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/instances",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        launchInstanceRequest.launchInstanceDetails,
        "LaunchInstanceDetails",
        models.LaunchInstanceDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.LaunchInstanceResponse>{},
        body: await response.json(),
        bodyKey: "instance",
        bodyModel: "model.Instance",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets all resource versions for a particular listing.
   * @param ListAppCatalogListingResourceVersionsRequest
   * @return ListAppCatalogListingResourceVersionsResponse
   * @throws OciError when an error occurs
   */
  public async listAppCatalogListingResourceVersions(
    listAppCatalogListingResourceVersionsRequest: requests.ListAppCatalogListingResourceVersionsRequest
  ): Promise<responses.ListAppCatalogListingResourceVersionsResponse> {
    const pathParams = {
      "{listingId}": listAppCatalogListingResourceVersionsRequest.listingId
    };

    const queryParams = {
      "limit": listAppCatalogListingResourceVersionsRequest.limit,
      "page": listAppCatalogListingResourceVersionsRequest.page,
      "sortOrder": listAppCatalogListingResourceVersionsRequest.sortOrder
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/appCatalogListings/{listingId}/resourceVersions",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListAppCatalogListingResourceVersionsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "AppCatalogListingResourceVersionSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.AppCatalogListingResourceVersionSummary objects
   * contained in responses from the listAppCatalogListingResourceVersions operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllAppCatalogListingResourceVersions(
    request: requests.ListAppCatalogListingResourceVersionsRequest
  ): AsyncIterableIterator<models.AppCatalogListingResourceVersionSummary> {
    return paginateRecords(request, req => this.listAppCatalogListingResourceVersions(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listAppCatalogListingResourceVersions operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllAppCatalogListingResourceVersionsResponses(
    request: requests.ListAppCatalogListingResourceVersionsRequest
  ): AsyncIterableIterator<responses.ListAppCatalogListingResourceVersionsResponse> {
    return paginateResponses(request, req => this.listAppCatalogListingResourceVersions(req));
  }

  /**
   * Lists the published listings.
   * @param ListAppCatalogListingsRequest
   * @return ListAppCatalogListingsResponse
   * @throws OciError when an error occurs
   */
  public async listAppCatalogListings(
    listAppCatalogListingsRequest: requests.ListAppCatalogListingsRequest
  ): Promise<responses.ListAppCatalogListingsResponse> {
    const pathParams = {};

    const queryParams = {
      "limit": listAppCatalogListingsRequest.limit,
      "page": listAppCatalogListingsRequest.page,
      "sortOrder": listAppCatalogListingsRequest.sortOrder,
      "publisherName": listAppCatalogListingsRequest.publisherName,
      "publisherType": listAppCatalogListingsRequest.publisherType,
      "displayName": listAppCatalogListingsRequest.displayName
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/appCatalogListings",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListAppCatalogListingsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "AppCatalogListingSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.AppCatalogListingSummary objects
   * contained in responses from the listAppCatalogListings operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllAppCatalogListings(
    request: requests.ListAppCatalogListingsRequest
  ): AsyncIterableIterator<models.AppCatalogListingSummary> {
    return paginateRecords(request, req => this.listAppCatalogListings(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listAppCatalogListings operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllAppCatalogListingsResponses(
    request: requests.ListAppCatalogListingsRequest
  ): AsyncIterableIterator<responses.ListAppCatalogListingsResponse> {
    return paginateResponses(request, req => this.listAppCatalogListings(req));
  }

  /**
   * Lists subscriptions for a compartment.
   * @param ListAppCatalogSubscriptionsRequest
   * @return ListAppCatalogSubscriptionsResponse
   * @throws OciError when an error occurs
   */
  public async listAppCatalogSubscriptions(
    listAppCatalogSubscriptionsRequest: requests.ListAppCatalogSubscriptionsRequest
  ): Promise<responses.ListAppCatalogSubscriptionsResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listAppCatalogSubscriptionsRequest.compartmentId,
      "limit": listAppCatalogSubscriptionsRequest.limit,
      "page": listAppCatalogSubscriptionsRequest.page,
      "sortBy": listAppCatalogSubscriptionsRequest.sortBy,
      "sortOrder": listAppCatalogSubscriptionsRequest.sortOrder,
      "listingId": listAppCatalogSubscriptionsRequest.listingId
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/appCatalogSubscriptions",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListAppCatalogSubscriptionsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "AppCatalogSubscriptionSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.AppCatalogSubscriptionSummary objects
   * contained in responses from the listAppCatalogSubscriptions operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllAppCatalogSubscriptions(
    request: requests.ListAppCatalogSubscriptionsRequest
  ): AsyncIterableIterator<models.AppCatalogSubscriptionSummary> {
    return paginateRecords(request, req => this.listAppCatalogSubscriptions(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listAppCatalogSubscriptions operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllAppCatalogSubscriptionsResponses(
    request: requests.ListAppCatalogSubscriptionsRequest
  ): AsyncIterableIterator<responses.ListAppCatalogSubscriptionsResponse> {
    return paginateResponses(request, req => this.listAppCatalogSubscriptions(req));
  }

  /**
   * Lists the boot volume attachments in the specified compartment. You can filter the
   * list by specifying an instance OCID, boot volume OCID, or both.
   *
   * @param ListBootVolumeAttachmentsRequest
   * @return ListBootVolumeAttachmentsResponse
   * @throws OciError when an error occurs
   */
  public async listBootVolumeAttachments(
    listBootVolumeAttachmentsRequest: requests.ListBootVolumeAttachmentsRequest
  ): Promise<responses.ListBootVolumeAttachmentsResponse> {
    const pathParams = {};

    const queryParams = {
      "availabilityDomain": listBootVolumeAttachmentsRequest.availabilityDomain,
      "compartmentId": listBootVolumeAttachmentsRequest.compartmentId,
      "limit": listBootVolumeAttachmentsRequest.limit,
      "page": listBootVolumeAttachmentsRequest.page,
      "instanceId": listBootVolumeAttachmentsRequest.instanceId,
      "bootVolumeId": listBootVolumeAttachmentsRequest.bootVolumeId
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/bootVolumeAttachments",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListBootVolumeAttachmentsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "BootVolumeAttachment[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.BootVolumeAttachment objects
   * contained in responses from the listBootVolumeAttachments operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllBootVolumeAttachments(
    request: requests.ListBootVolumeAttachmentsRequest
  ): AsyncIterableIterator<models.BootVolumeAttachment> {
    return paginateRecords(request, req => this.listBootVolumeAttachments(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listBootVolumeAttachments operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllBootVolumeAttachmentsResponses(
    request: requests.ListBootVolumeAttachmentsRequest
  ): AsyncIterableIterator<responses.ListBootVolumeAttachmentsResponse> {
    return paginateResponses(request, req => this.listBootVolumeAttachments(req));
  }

  /**
   * Lists the console history metadata for the specified compartment or instance.
   *
   * @param ListConsoleHistoriesRequest
   * @return ListConsoleHistoriesResponse
   * @throws OciError when an error occurs
   */
  public async listConsoleHistories(
    listConsoleHistoriesRequest: requests.ListConsoleHistoriesRequest
  ): Promise<responses.ListConsoleHistoriesResponse> {
    const pathParams = {};

    const queryParams = {
      "availabilityDomain": listConsoleHistoriesRequest.availabilityDomain,
      "compartmentId": listConsoleHistoriesRequest.compartmentId,
      "limit": listConsoleHistoriesRequest.limit,
      "page": listConsoleHistoriesRequest.page,
      "instanceId": listConsoleHistoriesRequest.instanceId,
      "sortBy": listConsoleHistoriesRequest.sortBy,
      "sortOrder": listConsoleHistoriesRequest.sortOrder,
      "lifecycleState": listConsoleHistoriesRequest.lifecycleState
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/instanceConsoleHistories",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListConsoleHistoriesResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "ConsoleHistory[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.ConsoleHistory objects
   * contained in responses from the listConsoleHistories operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllConsoleHistories(
    request: requests.ListConsoleHistoriesRequest
  ): AsyncIterableIterator<models.ConsoleHistory> {
    return paginateRecords(request, req => this.listConsoleHistories(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listConsoleHistories operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllConsoleHistoriesResponses(
    request: requests.ListConsoleHistoriesRequest
  ): AsyncIterableIterator<responses.ListConsoleHistoriesResponse> {
    return paginateResponses(request, req => this.listConsoleHistories(req));
  }

  /**
   * Lists the shapes that can be used to launch a virtual machine instance on a dedicated virtual machine host within the specified compartment.
   * You can filter the list by compatibility with a specific dedicated virtual machine host shape.
   *
   * @param ListDedicatedVmHostInstanceShapesRequest
   * @return ListDedicatedVmHostInstanceShapesResponse
   * @throws OciError when an error occurs
   */
  public async listDedicatedVmHostInstanceShapes(
    listDedicatedVmHostInstanceShapesRequest: requests.ListDedicatedVmHostInstanceShapesRequest
  ): Promise<responses.ListDedicatedVmHostInstanceShapesResponse> {
    const pathParams = {};

    const queryParams = {
      "availabilityDomain": listDedicatedVmHostInstanceShapesRequest.availabilityDomain,
      "compartmentId": listDedicatedVmHostInstanceShapesRequest.compartmentId,
      "dedicatedVmHostShape": listDedicatedVmHostInstanceShapesRequest.dedicatedVmHostShape,
      "limit": listDedicatedVmHostInstanceShapesRequest.limit,
      "page": listDedicatedVmHostInstanceShapesRequest.page
    };

    let headerParams = {
      "opc-request-id": listDedicatedVmHostInstanceShapesRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/dedicatedVmHostInstanceShapes",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListDedicatedVmHostInstanceShapesResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "DedicatedVmHostInstanceShapeSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.DedicatedVmHostInstanceShapeSummary objects
   * contained in responses from the listDedicatedVmHostInstanceShapes operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllDedicatedVmHostInstanceShapes(
    request: requests.ListDedicatedVmHostInstanceShapesRequest
  ): AsyncIterableIterator<models.DedicatedVmHostInstanceShapeSummary> {
    return paginateRecords(request, req => this.listDedicatedVmHostInstanceShapes(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listDedicatedVmHostInstanceShapes operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllDedicatedVmHostInstanceShapesResponses(
    request: requests.ListDedicatedVmHostInstanceShapesRequest
  ): AsyncIterableIterator<responses.ListDedicatedVmHostInstanceShapesResponse> {
    return paginateResponses(request, req => this.listDedicatedVmHostInstanceShapes(req));
  }

  /**
   * Returns the list of instances on the dedicated virtual machine hosts that match the specified criteria.
   *
   * @param ListDedicatedVmHostInstancesRequest
   * @return ListDedicatedVmHostInstancesResponse
   * @throws OciError when an error occurs
   */
  public async listDedicatedVmHostInstances(
    listDedicatedVmHostInstancesRequest: requests.ListDedicatedVmHostInstancesRequest
  ): Promise<responses.ListDedicatedVmHostInstancesResponse> {
    const pathParams = {
      "{dedicatedVmHostId}": listDedicatedVmHostInstancesRequest.dedicatedVmHostId
    };

    const queryParams = {
      "availabilityDomain": listDedicatedVmHostInstancesRequest.availabilityDomain,
      "compartmentId": listDedicatedVmHostInstancesRequest.compartmentId,
      "limit": listDedicatedVmHostInstancesRequest.limit,
      "page": listDedicatedVmHostInstancesRequest.page,
      "sortBy": listDedicatedVmHostInstancesRequest.sortBy,
      "sortOrder": listDedicatedVmHostInstancesRequest.sortOrder
    };

    let headerParams = {
      "opc-request-id": listDedicatedVmHostInstancesRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/dedicatedVmHosts/{dedicatedVmHostId}/instances",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListDedicatedVmHostInstancesResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "DedicatedVmHostInstanceSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.DedicatedVmHostInstanceSummary objects
   * contained in responses from the listDedicatedVmHostInstances operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllDedicatedVmHostInstances(
    request: requests.ListDedicatedVmHostInstancesRequest
  ): AsyncIterableIterator<models.DedicatedVmHostInstanceSummary> {
    return paginateRecords(request, req => this.listDedicatedVmHostInstances(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listDedicatedVmHostInstances operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllDedicatedVmHostInstancesResponses(
    request: requests.ListDedicatedVmHostInstancesRequest
  ): AsyncIterableIterator<responses.ListDedicatedVmHostInstancesResponse> {
    return paginateResponses(request, req => this.listDedicatedVmHostInstances(req));
  }

  /**
   * Lists the shapes that can be used to launch a dedicated virtual machine host within the specified compartment.
   *
   * @param ListDedicatedVmHostShapesRequest
   * @return ListDedicatedVmHostShapesResponse
   * @throws OciError when an error occurs
   */
  public async listDedicatedVmHostShapes(
    listDedicatedVmHostShapesRequest: requests.ListDedicatedVmHostShapesRequest
  ): Promise<responses.ListDedicatedVmHostShapesResponse> {
    const pathParams = {};

    const queryParams = {
      "availabilityDomain": listDedicatedVmHostShapesRequest.availabilityDomain,
      "compartmentId": listDedicatedVmHostShapesRequest.compartmentId,
      "instanceShapeName": listDedicatedVmHostShapesRequest.instanceShapeName,
      "limit": listDedicatedVmHostShapesRequest.limit,
      "page": listDedicatedVmHostShapesRequest.page
    };

    let headerParams = {
      "opc-request-id": listDedicatedVmHostShapesRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/dedicatedVmHostShapes",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListDedicatedVmHostShapesResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "DedicatedVmHostShapeSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.DedicatedVmHostShapeSummary objects
   * contained in responses from the listDedicatedVmHostShapes operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllDedicatedVmHostShapes(
    request: requests.ListDedicatedVmHostShapesRequest
  ): AsyncIterableIterator<models.DedicatedVmHostShapeSummary> {
    return paginateRecords(request, req => this.listDedicatedVmHostShapes(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listDedicatedVmHostShapes operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllDedicatedVmHostShapesResponses(
    request: requests.ListDedicatedVmHostShapesRequest
  ): AsyncIterableIterator<responses.ListDedicatedVmHostShapesResponse> {
    return paginateResponses(request, req => this.listDedicatedVmHostShapes(req));
  }

  /**
     * Returns the list of dedicated virtual machine hosts that match the specified criteria in the specified compartment.
* <p>
You can limit the list by specifying a dedicated virtual machine host display name. The list will include all the identically-named
* dedicated virtual machine hosts in the compartment.
* 
     * @param ListDedicatedVmHostsRequest
     * @return ListDedicatedVmHostsResponse
     * @throws OciError when an error occurs
     */
  public async listDedicatedVmHosts(
    listDedicatedVmHostsRequest: requests.ListDedicatedVmHostsRequest
  ): Promise<responses.ListDedicatedVmHostsResponse> {
    const pathParams = {};

    const queryParams = {
      "availabilityDomain": listDedicatedVmHostsRequest.availabilityDomain,
      "compartmentId": listDedicatedVmHostsRequest.compartmentId,
      "lifecycleState": listDedicatedVmHostsRequest.lifecycleState,
      "displayName": listDedicatedVmHostsRequest.displayName,
      "instanceShapeName": listDedicatedVmHostsRequest.instanceShapeName,
      "limit": listDedicatedVmHostsRequest.limit,
      "page": listDedicatedVmHostsRequest.page,
      "sortBy": listDedicatedVmHostsRequest.sortBy,
      "sortOrder": listDedicatedVmHostsRequest.sortOrder
    };

    let headerParams = {
      "opc-request-id": listDedicatedVmHostsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/dedicatedVmHosts",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListDedicatedVmHostsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "DedicatedVmHostSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.DedicatedVmHostSummary objects
   * contained in responses from the listDedicatedVmHosts operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllDedicatedVmHosts(
    request: requests.ListDedicatedVmHostsRequest
  ): AsyncIterableIterator<models.DedicatedVmHostSummary> {
    return paginateRecords(request, req => this.listDedicatedVmHosts(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listDedicatedVmHosts operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllDedicatedVmHostsResponses(
    request: requests.ListDedicatedVmHostsRequest
  ): AsyncIterableIterator<responses.ListDedicatedVmHostsResponse> {
    return paginateResponses(request, req => this.listDedicatedVmHosts(req));
  }

  /**
   * Lists the shape compatibilities for the image.
   * @param ListImageShapeCompatibilityEntriesRequest
   * @return ListImageShapeCompatibilityEntriesResponse
   * @throws OciError when an error occurs
   */
  public async listImageShapeCompatibilityEntries(
    listImageShapeCompatibilityEntriesRequest: requests.ListImageShapeCompatibilityEntriesRequest
  ): Promise<responses.ListImageShapeCompatibilityEntriesResponse> {
    const pathParams = {
      "{imageId}": listImageShapeCompatibilityEntriesRequest.imageId
    };

    const queryParams = {
      "limit": listImageShapeCompatibilityEntriesRequest.limit,
      "page": listImageShapeCompatibilityEntriesRequest.page
    };

    let headerParams = {
      "opc-request-id": listImageShapeCompatibilityEntriesRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/images/{imageId}/shapes",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListImageShapeCompatibilityEntriesResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "ImageShapeCompatibilitySummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.ImageShapeCompatibilitySummary objects
   * contained in responses from the listImageShapeCompatibilityEntries operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllImageShapeCompatibilityEntries(
    request: requests.ListImageShapeCompatibilityEntriesRequest
  ): AsyncIterableIterator<models.ImageShapeCompatibilitySummary> {
    return paginateRecords(request, req => this.listImageShapeCompatibilityEntries(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listImageShapeCompatibilityEntries operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllImageShapeCompatibilityEntriesResponses(
    request: requests.ListImageShapeCompatibilityEntriesRequest
  ): AsyncIterableIterator<responses.ListImageShapeCompatibilityEntriesResponse> {
    return paginateResponses(request, req => this.listImageShapeCompatibilityEntries(req));
  }

  /**
     * Lists the available images in the specified compartment, including both
* [Oracle-provided images](https://docs.cloud.oracle.com/Content/Compute/References/images.htm) and
* [custom images](https://docs.cloud.oracle.com/Content/Compute/Tasks/managingcustomimages.htm) that have
* been created. The list of images returned is ordered to first show all
* Oracle-provided images, then all custom images.
* <p>
The order of images returned may change when new images are released.
* 
     * @param ListImagesRequest
     * @return ListImagesResponse
     * @throws OciError when an error occurs
     */
  public async listImages(
    listImagesRequest: requests.ListImagesRequest
  ): Promise<responses.ListImagesResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listImagesRequest.compartmentId,
      "displayName": listImagesRequest.displayName,
      "operatingSystem": listImagesRequest.operatingSystem,
      "operatingSystemVersion": listImagesRequest.operatingSystemVersion,
      "shape": listImagesRequest.shape,
      "limit": listImagesRequest.limit,
      "page": listImagesRequest.page,
      "sortBy": listImagesRequest.sortBy,
      "sortOrder": listImagesRequest.sortOrder,
      "lifecycleState": listImagesRequest.lifecycleState
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/images",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListImagesResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "Image[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.Image objects
   * contained in responses from the listImages operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllImages(request: requests.ListImagesRequest): AsyncIterableIterator<models.Image> {
    return paginateRecords(request, req => this.listImages(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listImages operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllImagesResponses(
    request: requests.ListImagesRequest
  ): AsyncIterableIterator<responses.ListImagesResponse> {
    return paginateResponses(request, req => this.listImages(req));
  }

  /**
     * Lists the console connections for the specified compartment or instance.
* <p>
For more information about console access, see [Accessing the Console](https://docs.cloud.oracle.com/Content/Compute/References/serialconsole.htm).
* 
     * @param ListInstanceConsoleConnectionsRequest
     * @return ListInstanceConsoleConnectionsResponse
     * @throws OciError when an error occurs
     */
  public async listInstanceConsoleConnections(
    listInstanceConsoleConnectionsRequest: requests.ListInstanceConsoleConnectionsRequest
  ): Promise<responses.ListInstanceConsoleConnectionsResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listInstanceConsoleConnectionsRequest.compartmentId,
      "instanceId": listInstanceConsoleConnectionsRequest.instanceId,
      "limit": listInstanceConsoleConnectionsRequest.limit,
      "page": listInstanceConsoleConnectionsRequest.page
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/instanceConsoleConnections",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListInstanceConsoleConnectionsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "InstanceConsoleConnection[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.InstanceConsoleConnection objects
   * contained in responses from the listInstanceConsoleConnections operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllInstanceConsoleConnections(
    request: requests.ListInstanceConsoleConnectionsRequest
  ): AsyncIterableIterator<models.InstanceConsoleConnection> {
    return paginateRecords(request, req => this.listInstanceConsoleConnections(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listInstanceConsoleConnections operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllInstanceConsoleConnectionsResponses(
    request: requests.ListInstanceConsoleConnectionsRequest
  ): AsyncIterableIterator<responses.ListInstanceConsoleConnectionsResponse> {
    return paginateResponses(request, req => this.listInstanceConsoleConnections(req));
  }

  /**
   * Gets a list of all the devices for given instance. You can optionally filter results by device availability.
   * @param ListInstanceDevicesRequest
   * @return ListInstanceDevicesResponse
   * @throws OciError when an error occurs
   */
  public async listInstanceDevices(
    listInstanceDevicesRequest: requests.ListInstanceDevicesRequest
  ): Promise<responses.ListInstanceDevicesResponse> {
    const pathParams = {
      "{instanceId}": listInstanceDevicesRequest.instanceId
    };

    const queryParams = {
      "isAvailable": listInstanceDevicesRequest.isAvailable,
      "name": listInstanceDevicesRequest.name,
      "limit": listInstanceDevicesRequest.limit,
      "page": listInstanceDevicesRequest.page,
      "sortBy": listInstanceDevicesRequest.sortBy,
      "sortOrder": listInstanceDevicesRequest.sortOrder
    };

    let headerParams = {
      "opc-request-id": listInstanceDevicesRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/instances/{instanceId}/devices",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListInstanceDevicesResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "Device[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.Device objects
   * contained in responses from the listInstanceDevices operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllInstanceDevices(
    request: requests.ListInstanceDevicesRequest
  ): AsyncIterableIterator<models.Device> {
    return paginateRecords(request, req => this.listInstanceDevices(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listInstanceDevices operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllInstanceDevicesResponses(
    request: requests.ListInstanceDevicesRequest
  ): AsyncIterableIterator<responses.ListInstanceDevicesResponse> {
    return paginateResponses(request, req => this.listInstanceDevices(req));
  }

  /**
   * Lists the instances in the specified compartment and the specified availability domain.
   * You can filter the results by specifying an instance name (the list will include all the identically-named
   * instances in the compartment).
   *
   * @param ListInstancesRequest
   * @return ListInstancesResponse
   * @throws OciError when an error occurs
   */
  public async listInstances(
    listInstancesRequest: requests.ListInstancesRequest
  ): Promise<responses.ListInstancesResponse> {
    const pathParams = {};

    const queryParams = {
      "availabilityDomain": listInstancesRequest.availabilityDomain,
      "compartmentId": listInstancesRequest.compartmentId,
      "displayName": listInstancesRequest.displayName,
      "limit": listInstancesRequest.limit,
      "page": listInstancesRequest.page,
      "sortBy": listInstancesRequest.sortBy,
      "sortOrder": listInstancesRequest.sortOrder,
      "lifecycleState": listInstancesRequest.lifecycleState
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/instances",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListInstancesResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "Instance[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.Instance objects
   * contained in responses from the listInstances operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllInstances(
    request: requests.ListInstancesRequest
  ): AsyncIterableIterator<models.Instance> {
    return paginateRecords(request, req => this.listInstances(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listInstances operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllInstancesResponses(
    request: requests.ListInstancesRequest
  ): AsyncIterableIterator<responses.ListInstancesResponse> {
    return paginateResponses(request, req => this.listInstances(req));
  }

  /**
   * Lists the shapes that can be used to launch an instance within the specified compartment. You can
   * filter the list by compatibility with a specific image.
   *
   * @param ListShapesRequest
   * @return ListShapesResponse
   * @throws OciError when an error occurs
   */
  public async listShapes(
    listShapesRequest: requests.ListShapesRequest
  ): Promise<responses.ListShapesResponse> {
    const pathParams = {};

    const queryParams = {
      "availabilityDomain": listShapesRequest.availabilityDomain,
      "compartmentId": listShapesRequest.compartmentId,
      "limit": listShapesRequest.limit,
      "page": listShapesRequest.page,
      "imageId": listShapesRequest.imageId
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/shapes",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListShapesResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "Shape[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.Shape objects
   * contained in responses from the listShapes operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllShapes(request: requests.ListShapesRequest): AsyncIterableIterator<models.Shape> {
    return paginateRecords(request, req => this.listShapes(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listShapes operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllShapesResponses(
    request: requests.ListShapesRequest
  ): AsyncIterableIterator<responses.ListShapesResponse> {
    return paginateResponses(request, req => this.listShapes(req));
  }

  /**
   * Lists the VNIC attachments in the specified compartment. A VNIC attachment
   * resides in the same compartment as the attached instance. The list can be
   * filtered by instance, VNIC, or availability domain.
   *
   * @param ListVnicAttachmentsRequest
   * @return ListVnicAttachmentsResponse
   * @throws OciError when an error occurs
   */
  public async listVnicAttachments(
    listVnicAttachmentsRequest: requests.ListVnicAttachmentsRequest
  ): Promise<responses.ListVnicAttachmentsResponse> {
    const pathParams = {};

    const queryParams = {
      "availabilityDomain": listVnicAttachmentsRequest.availabilityDomain,
      "compartmentId": listVnicAttachmentsRequest.compartmentId,
      "instanceId": listVnicAttachmentsRequest.instanceId,
      "limit": listVnicAttachmentsRequest.limit,
      "page": listVnicAttachmentsRequest.page,
      "vnicId": listVnicAttachmentsRequest.vnicId
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/vnicAttachments",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListVnicAttachmentsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "VnicAttachment[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.VnicAttachment objects
   * contained in responses from the listVnicAttachments operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllVnicAttachments(
    request: requests.ListVnicAttachmentsRequest
  ): AsyncIterableIterator<models.VnicAttachment> {
    return paginateRecords(request, req => this.listVnicAttachments(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listVnicAttachments operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllVnicAttachmentsResponses(
    request: requests.ListVnicAttachmentsRequest
  ): AsyncIterableIterator<responses.ListVnicAttachmentsResponse> {
    return paginateResponses(request, req => this.listVnicAttachments(req));
  }

  /**
     * Lists the volume attachments in the specified compartment. You can filter the
* list by specifying an instance OCID, volume OCID, or both.
* <p>
Currently, the only supported volume attachment type are {@link IScsiVolumeAttachment} and
* {@link ParavirtualizedVolumeAttachment}.
* 
     * @param ListVolumeAttachmentsRequest
     * @return ListVolumeAttachmentsResponse
     * @throws OciError when an error occurs
     */
  public async listVolumeAttachments(
    listVolumeAttachmentsRequest: requests.ListVolumeAttachmentsRequest
  ): Promise<responses.ListVolumeAttachmentsResponse> {
    const pathParams = {};

    const queryParams = {
      "availabilityDomain": listVolumeAttachmentsRequest.availabilityDomain,
      "compartmentId": listVolumeAttachmentsRequest.compartmentId,
      "limit": listVolumeAttachmentsRequest.limit,
      "page": listVolumeAttachmentsRequest.page,
      "instanceId": listVolumeAttachmentsRequest.instanceId,
      "volumeId": listVolumeAttachmentsRequest.volumeId
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/volumeAttachments",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListVolumeAttachmentsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "VolumeAttachment[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.VolumeAttachment objects
   * contained in responses from the listVolumeAttachments operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllVolumeAttachments(
    request: requests.ListVolumeAttachmentsRequest
  ): AsyncIterableIterator<models.VolumeAttachment> {
    return paginateRecords(request, req => this.listVolumeAttachments(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listVolumeAttachments operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllVolumeAttachmentsResponses(
    request: requests.ListVolumeAttachmentsRequest
  ): AsyncIterableIterator<responses.ListVolumeAttachmentsResponse> {
    return paginateResponses(request, req => this.listVolumeAttachments(req));
  }

  /**
   * Removes a shape from the compatible shapes list for the image.
   * @param RemoveImageShapeCompatibilityEntryRequest
   * @return RemoveImageShapeCompatibilityEntryResponse
   * @throws OciError when an error occurs
   */
  public async removeImageShapeCompatibilityEntry(
    removeImageShapeCompatibilityEntryRequest: requests.RemoveImageShapeCompatibilityEntryRequest
  ): Promise<responses.RemoveImageShapeCompatibilityEntryResponse> {
    const pathParams = {
      "{imageId}": removeImageShapeCompatibilityEntryRequest.imageId,
      "{shapeName}": removeImageShapeCompatibilityEntryRequest.shapeName
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/images/{imageId}/shapes/{shapeName}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.RemoveImageShapeCompatibilityEntryResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Terminates the specified instance. Any attached VNICs and volumes are automatically detached
* when the instance terminates.
* <p>
To preserve the boot volume associated with the instance, specify `true` for `PreserveBootVolumeQueryParam`.
* To delete the boot volume when the instance is deleted, specify `false` or do not specify a value for `PreserveBootVolumeQueryParam`.
* <p>
This is an asynchronous operation. The instance's `lifecycleState` will change to TERMINATING temporarily
* until the instance is completely removed.
* 
     * @param TerminateInstanceRequest
     * @return TerminateInstanceResponse
     * @throws OciError when an error occurs
     */
  public async terminateInstance(
    terminateInstanceRequest: requests.TerminateInstanceRequest
  ): Promise<responses.TerminateInstanceResponse> {
    const pathParams = {
      "{instanceId}": terminateInstanceRequest.instanceId
    };

    const queryParams = {
      "preserveBootVolume": terminateInstanceRequest.preserveBootVolume
    };

    let headerParams = {
      "if-match": terminateInstanceRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/instances/{instanceId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.TerminateInstanceResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates the specified console history metadata.
   * @param UpdateConsoleHistoryRequest
   * @return UpdateConsoleHistoryResponse
   * @throws OciError when an error occurs
   */
  public async updateConsoleHistory(
    updateConsoleHistoryRequest: requests.UpdateConsoleHistoryRequest
  ): Promise<responses.UpdateConsoleHistoryResponse> {
    const pathParams = {
      "{instanceConsoleHistoryId}": updateConsoleHistoryRequest.instanceConsoleHistoryId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateConsoleHistoryRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/instanceConsoleHistories/{instanceConsoleHistoryId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateConsoleHistoryRequest.updateConsoleHistoryDetails,
        "UpdateConsoleHistoryDetails",
        models.UpdateConsoleHistoryDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateConsoleHistoryResponse>{},
        body: await response.json(),
        bodyKey: "consoleHistory",
        bodyModel: "model.ConsoleHistory",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates the displayName, freeformTags, and definedTags attributes for the specified dedicated virtual machine host.
   * If an attribute value is not included, it will not be updated.
   *
   * @param UpdateDedicatedVmHostRequest
   * @return UpdateDedicatedVmHostResponse
   * @throws OciError when an error occurs
   */
  public async updateDedicatedVmHost(
    updateDedicatedVmHostRequest: requests.UpdateDedicatedVmHostRequest
  ): Promise<responses.UpdateDedicatedVmHostResponse> {
    const pathParams = {
      "{dedicatedVmHostId}": updateDedicatedVmHostRequest.dedicatedVmHostId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateDedicatedVmHostRequest.ifMatch,
      "opc-request-id": updateDedicatedVmHostRequest.opcRequestId,
      "opc-retry-token": updateDedicatedVmHostRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/dedicatedVmHosts/{dedicatedVmHostId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateDedicatedVmHostRequest.updateDedicatedVmHostDetails,
        "UpdateDedicatedVmHostDetails",
        models.UpdateDedicatedVmHostDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateDedicatedVmHostResponse>{},
        body: await response.json(),
        bodyKey: "dedicatedVmHost",
        bodyModel: "model.DedicatedVmHost",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates the display name of the image. Avoid entering confidential information.
   * @param UpdateImageRequest
   * @return UpdateImageResponse
   * @throws OciError when an error occurs
   */
  public async updateImage(
    updateImageRequest: requests.UpdateImageRequest
  ): Promise<responses.UpdateImageResponse> {
    const pathParams = {
      "{imageId}": updateImageRequest.imageId
    };

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": updateImageRequest.opcRetryToken,
      "if-match": updateImageRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/images/{imageId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateImageRequest.updateImageDetails,
        "UpdateImageDetails",
        models.UpdateImageDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateImageResponse>{},
        body: await response.json(),
        bodyKey: "image",
        bodyModel: "model.Image",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Updates certain fields on the specified instance. Fields that are not provided in the
* request will not be updated. Avoid entering confidential information.
* <p>
Changes to metadata fields will be reflected in the instance metadata service (this may take
* up to a minute).
* <p>
The OCID of the instance remains the same.
* 
     * @param UpdateInstanceRequest
     * @return UpdateInstanceResponse
     * @throws OciError when an error occurs
     */
  public async updateInstance(
    updateInstanceRequest: requests.UpdateInstanceRequest
  ): Promise<responses.UpdateInstanceResponse> {
    const pathParams = {
      "{instanceId}": updateInstanceRequest.instanceId
    };

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": updateInstanceRequest.opcRetryToken,
      "if-match": updateInstanceRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/instances/{instanceId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateInstanceRequest.updateInstanceDetails,
        "UpdateInstanceDetails",
        models.UpdateInstanceDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateInstanceResponse>{},
        body: await response.json(),
        bodyKey: "instance",
        bodyModel: "model.Instance",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }
}
export enum ComputeManagementApiKeys {}

export class ComputeManagementClient {
  protected static serviceEndpointTemplate = "https://iaas.{region}.{secondLevelDomain}";
  protected "_endpoint": string = "";
  protected "_defaultHeaders": any = {};
  protected "_waiters": ComputeManagementWaiter;

  protected _httpClient: common.HttpClient;

  constructor(params: common.AuthParams) {
    const requestSigner = params.authenticationDetailsProvider
      ? new common.DefaultRequestSigner(params.authenticationDetailsProvider)
      : null;
    this._httpClient = params.httpClient || new common.FetchHttpClient(requestSigner);

    if (
      params.authenticationDetailsProvider &&
      common.isRegionProvider(params.authenticationDetailsProvider)
    ) {
      const provider: common.RegionProvider = params.authenticationDetailsProvider;
      if (provider.getRegion()) {
        this.region = provider.getRegion();
      }
    }
  }

  /**
   * Sets the endpoint to call (ex, https://www.example.com).
   * @param endpoint The endpoint of the service.
   */
  public set endpoint(endpoint: string) {
    this._endpoint = endpoint;
    this._endpoint = this._endpoint + "/20160918";
  }

  /**
   * Sets the region to call (ex, Region.US_PHOENIX_1).
   * Note, this will call {@link #endpoint(String) endpoint} after resolving the endpoint.
   * @param region The region of the service.
   */
  public set region(region: common.Region) {
    this.endpoint = common.EndpointBuilder.createEndpointFromRegion(
      ComputeManagementClient.serviceEndpointTemplate,
      region
    );
  }

  /**
   * Sets the regionId to call (ex, 'us-phoenix-1').
   *
   * Note, this will first try to map the region ID to a known Region and call {@link #region(Region) region}.
   * If no known Region could be determined, it will create an endpoint assuming its in default Realm OC1
   * and then call {@link #endpoint(String) endpoint}.
   * @param regionId The public region ID.
   */
  public set regionId(regionId: string) {
    this.endpoint = common.EndpointBuilder.createEndpointFromRegionId(
      ComputeManagementClient.serviceEndpointTemplate,
      regionId
    );
  }

  /**
   * Creates a new ComputeManagementWaiter for resources for this service.
   *
   * @param workRequestClient The work request service client used to query for work request status
   * @param config The waiter configuration for termination and delay strategy
   * @return The service waiters.
   */
  public createWaiters(
    workRequestClient: WorkRequestClient,
    config?: common.WaiterConfiguration
  ): ComputeManagementWaiter {
    this._waiters = new ComputeManagementWaiter(this, workRequestClient, config);
    return this._waiters;
  }

  /**
   * Gets the waiters available for resources for this service.
   *
   * @return The service waiters.
   */
  public getWaiters(): ComputeManagementWaiter {
    if (this._waiters) {
      return this._waiters;
    }
    throw Error("Waiters do not exist. Please create waiters.");
  }

  /**
   * Attach a load balancer to the instance pool.
   *
   * @param AttachLoadBalancerRequest
   * @return AttachLoadBalancerResponse
   * @throws OciError when an error occurs
   */
  public async attachLoadBalancer(
    attachLoadBalancerRequest: requests.AttachLoadBalancerRequest
  ): Promise<responses.AttachLoadBalancerResponse> {
    const pathParams = {
      "{instancePoolId}": attachLoadBalancerRequest.instancePoolId
    };

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": attachLoadBalancerRequest.opcRetryToken,
      "if-match": attachLoadBalancerRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/instancePools/{instancePoolId}/actions/attachLoadBalancer",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        attachLoadBalancerRequest.attachLoadBalancerDetails,
        "AttachLoadBalancerDetails",
        models.AttachLoadBalancerDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.AttachLoadBalancerResponse>{},
        body: await response.json(),
        bodyKey: "instancePool",
        bodyModel: "model.InstancePool",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Moves a cluster network into a different compartment within the same tenancy. For
* information about moving resources between compartments, see
* [Moving Resources to a Different Compartment](https://docs.cloud.oracle.com/iaas/Content/Identity/Tasks/managingcompartments.htm#moveRes).
* <p>
When you move a cluster network to a different compartment, associated resources such as the instances
* in the cluster network, boot volumes, and VNICs are not moved.
* 
     * @param ChangeClusterNetworkCompartmentRequest
     * @return ChangeClusterNetworkCompartmentResponse
     * @throws OciError when an error occurs
     */
  public async changeClusterNetworkCompartment(
    changeClusterNetworkCompartmentRequest: requests.ChangeClusterNetworkCompartmentRequest
  ): Promise<responses.ChangeClusterNetworkCompartmentResponse> {
    const pathParams = {
      "{clusterNetworkId}": changeClusterNetworkCompartmentRequest.clusterNetworkId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": changeClusterNetworkCompartmentRequest.ifMatch,
      "opc-request-id": changeClusterNetworkCompartmentRequest.opcRequestId,
      "opc-retry-token": changeClusterNetworkCompartmentRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/clusterNetworks/{clusterNetworkId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeClusterNetworkCompartmentRequest.changeClusterNetworkCompartmentDetails,
        "ChangeClusterNetworkCompartmentDetails",
        models.ChangeClusterNetworkCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeClusterNetworkCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Moves an instance configuration into a different compartment within the same tenancy.
* For information about moving resources between compartments, see
* [Moving Resources to a Different Compartment](https://docs.cloud.oracle.com/iaas/Content/Identity/Tasks/managingcompartments.htm#moveRes).
* <p>
When you move an instance configuration to a different compartment, associated resources such as
* instance pools are not moved.
* <p>
**Important:** Most of the properties for an existing instance configuration, including the compartment,
* cannot be modified after you create the instance configuration. Although you can move an instance configuration
* to a different compartment, you will not be able to use the instance configuration to manage instance pools
* in the new compartment. If you want to update an instance configuration to point to a different compartment,
* you should instead create a new instance configuration in the target compartment using
* [CreateInstanceConfiguration](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/20160918/InstanceConfiguration/CreateInstanceConfiguration).
* 
     * @param ChangeInstanceConfigurationCompartmentRequest
     * @return ChangeInstanceConfigurationCompartmentResponse
     * @throws OciError when an error occurs
     */
  public async changeInstanceConfigurationCompartment(
    changeInstanceConfigurationCompartmentRequest: requests.ChangeInstanceConfigurationCompartmentRequest
  ): Promise<responses.ChangeInstanceConfigurationCompartmentResponse> {
    const pathParams = {
      "{instanceConfigurationId}":
        changeInstanceConfigurationCompartmentRequest.instanceConfigurationId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": changeInstanceConfigurationCompartmentRequest.ifMatch,
      "opc-request-id": changeInstanceConfigurationCompartmentRequest.opcRequestId,
      "opc-retry-token": changeInstanceConfigurationCompartmentRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/instanceConfigurations/{instanceConfigurationId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeInstanceConfigurationCompartmentRequest.changeInstanceConfigurationCompartmentDetails,
        "ChangeInstanceConfigurationCompartmentDetails",
        models.ChangeInstanceConfigurationCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeInstanceConfigurationCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Moves an instance pool into a different compartment within the same tenancy. For
* information about moving resources between compartments, see
* [Moving Resources to a Different Compartment](https://docs.cloud.oracle.com/iaas/Content/Identity/Tasks/managingcompartments.htm#moveRes).
* <p>
When you move an instance pool to a different compartment, associated resources such as the instances in
* the pool, boot volumes, VNICs, and autoscaling configurations are not moved.
* 
     * @param ChangeInstancePoolCompartmentRequest
     * @return ChangeInstancePoolCompartmentResponse
     * @throws OciError when an error occurs
     */
  public async changeInstancePoolCompartment(
    changeInstancePoolCompartmentRequest: requests.ChangeInstancePoolCompartmentRequest
  ): Promise<responses.ChangeInstancePoolCompartmentResponse> {
    const pathParams = {
      "{instancePoolId}": changeInstancePoolCompartmentRequest.instancePoolId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": changeInstancePoolCompartmentRequest.ifMatch,
      "opc-request-id": changeInstancePoolCompartmentRequest.opcRequestId,
      "opc-retry-token": changeInstancePoolCompartmentRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/instancePools/{instancePoolId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeInstancePoolCompartmentRequest.changeInstancePoolCompartmentDetails,
        "ChangeInstancePoolCompartmentDetails",
        models.ChangeInstancePoolCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeInstancePoolCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a cluster network. For more information about cluster networks, see
   * [Managing Cluster Networks](https://docs.cloud.oracle.com/iaas/Content/Compute/Tasks/managingclusternetworks.htm).
   *
   * @param CreateClusterNetworkRequest
   * @return CreateClusterNetworkResponse
   * @throws OciError when an error occurs
   */
  public async createClusterNetwork(
    createClusterNetworkRequest: requests.CreateClusterNetworkRequest
  ): Promise<responses.CreateClusterNetworkResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createClusterNetworkRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/clusterNetworks",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createClusterNetworkRequest.createClusterNetworkDetails,
        "CreateClusterNetworkDetails",
        models.CreateClusterNetworkDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateClusterNetworkResponse>{},
        body: await response.json(),
        bodyKey: "clusterNetwork",
        bodyModel: "model.ClusterNetwork",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates an instance configuration. An instance configuration is a template that defines the
   * settings to use when creating Compute instances.
   *
   * @param CreateInstanceConfigurationRequest
   * @return CreateInstanceConfigurationResponse
   * @throws OciError when an error occurs
   */
  public async createInstanceConfiguration(
    createInstanceConfigurationRequest: requests.CreateInstanceConfigurationRequest
  ): Promise<responses.CreateInstanceConfigurationResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createInstanceConfigurationRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/instanceConfigurations",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createInstanceConfigurationRequest.createInstanceConfiguration,
        "CreateInstanceConfigurationBase",
        models.CreateInstanceConfigurationBase.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateInstanceConfigurationResponse>{},
        body: await response.json(),
        bodyKey: "instanceConfiguration",
        bodyModel: "model.InstanceConfiguration",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Create an instance pool.
   * @param CreateInstancePoolRequest
   * @return CreateInstancePoolResponse
   * @throws OciError when an error occurs
   */
  public async createInstancePool(
    createInstancePoolRequest: requests.CreateInstancePoolRequest
  ): Promise<responses.CreateInstancePoolResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createInstancePoolRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/instancePools",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createInstancePoolRequest.createInstancePoolDetails,
        "CreateInstancePoolDetails",
        models.CreateInstancePoolDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateInstancePoolResponse>{},
        body: await response.json(),
        bodyKey: "instancePool",
        bodyModel: "model.InstancePool",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Deletes an instance configuration.
   * @param DeleteInstanceConfigurationRequest
   * @return DeleteInstanceConfigurationResponse
   * @throws OciError when an error occurs
   */
  public async deleteInstanceConfiguration(
    deleteInstanceConfigurationRequest: requests.DeleteInstanceConfigurationRequest
  ): Promise<responses.DeleteInstanceConfigurationResponse> {
    const pathParams = {
      "{instanceConfigurationId}": deleteInstanceConfigurationRequest.instanceConfigurationId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteInstanceConfigurationRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/instanceConfigurations/{instanceConfigurationId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteInstanceConfigurationResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Detach a load balancer from the instance pool.
   *
   * @param DetachLoadBalancerRequest
   * @return DetachLoadBalancerResponse
   * @throws OciError when an error occurs
   */
  public async detachLoadBalancer(
    detachLoadBalancerRequest: requests.DetachLoadBalancerRequest
  ): Promise<responses.DetachLoadBalancerResponse> {
    const pathParams = {
      "{instancePoolId}": detachLoadBalancerRequest.instancePoolId
    };

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": detachLoadBalancerRequest.opcRetryToken,
      "if-match": detachLoadBalancerRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/instancePools/{instancePoolId}/actions/detachLoadBalancer",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        detachLoadBalancerRequest.detachLoadBalancerDetails,
        "DetachLoadBalancerDetails",
        models.DetachLoadBalancerDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DetachLoadBalancerResponse>{},
        body: await response.json(),
        bodyKey: "instancePool",
        bodyModel: "model.InstancePool",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets information about the specified cluster network.
   * @param GetClusterNetworkRequest
   * @return GetClusterNetworkResponse
   * @throws OciError when an error occurs
   */
  public async getClusterNetwork(
    getClusterNetworkRequest: requests.GetClusterNetworkRequest
  ): Promise<responses.GetClusterNetworkResponse> {
    const pathParams = {
      "{clusterNetworkId}": getClusterNetworkRequest.clusterNetworkId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/clusterNetworks/{clusterNetworkId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetClusterNetworkResponse>{},
        body: await response.json(),
        bodyKey: "clusterNetwork",
        bodyModel: "model.ClusterNetwork",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the specified instance configuration
   * @param GetInstanceConfigurationRequest
   * @return GetInstanceConfigurationResponse
   * @throws OciError when an error occurs
   */
  public async getInstanceConfiguration(
    getInstanceConfigurationRequest: requests.GetInstanceConfigurationRequest
  ): Promise<responses.GetInstanceConfigurationResponse> {
    const pathParams = {
      "{instanceConfigurationId}": getInstanceConfigurationRequest.instanceConfigurationId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/instanceConfigurations/{instanceConfigurationId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetInstanceConfigurationResponse>{},
        body: await response.json(),
        bodyKey: "instanceConfiguration",
        bodyModel: "model.InstanceConfiguration",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the specified instance pool
   * @param GetInstancePoolRequest
   * @return GetInstancePoolResponse
   * @throws OciError when an error occurs
   */
  public async getInstancePool(
    getInstancePoolRequest: requests.GetInstancePoolRequest
  ): Promise<responses.GetInstancePoolResponse> {
    const pathParams = {
      "{instancePoolId}": getInstancePoolRequest.instancePoolId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/instancePools/{instancePoolId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetInstancePoolResponse>{},
        body: await response.json(),
        bodyKey: "instancePool",
        bodyModel: "model.InstancePool",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets information about a load balancer that is attached to the specified instance pool.
   *
   * @param GetInstancePoolLoadBalancerAttachmentRequest
   * @return GetInstancePoolLoadBalancerAttachmentResponse
   * @throws OciError when an error occurs
   */
  public async getInstancePoolLoadBalancerAttachment(
    getInstancePoolLoadBalancerAttachmentRequest: requests.GetInstancePoolLoadBalancerAttachmentRequest
  ): Promise<responses.GetInstancePoolLoadBalancerAttachmentResponse> {
    const pathParams = {
      "{instancePoolId}": getInstancePoolLoadBalancerAttachmentRequest.instancePoolId,
      "{instancePoolLoadBalancerAttachmentId}":
        getInstancePoolLoadBalancerAttachmentRequest.instancePoolLoadBalancerAttachmentId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path:
        "/instancePools/{instancePoolId}/loadBalancerAttachments/{instancePoolLoadBalancerAttachmentId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetInstancePoolLoadBalancerAttachmentResponse>{},
        body: await response.json(),
        bodyKey: "instancePoolLoadBalancerAttachment",
        bodyModel: "model.InstancePoolLoadBalancerAttachment",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Launches an instance from an instance configuration.
* <p>
If the instance configuration does not include all of the parameters that are
* required to launch an instance, such as the availability domain and subnet ID, you must
* provide these parameters when you launch an instance from the instance configuration.
* For more information, see the {@link InstanceConfiguration}
* resource.
* 
     * @param LaunchInstanceConfigurationRequest
     * @return LaunchInstanceConfigurationResponse
     * @throws OciError when an error occurs
     */
  public async launchInstanceConfiguration(
    launchInstanceConfigurationRequest: requests.LaunchInstanceConfigurationRequest
  ): Promise<responses.LaunchInstanceConfigurationResponse> {
    const pathParams = {
      "{instanceConfigurationId}": launchInstanceConfigurationRequest.instanceConfigurationId
    };

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": launchInstanceConfigurationRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/instanceConfigurations/{instanceConfigurationId}/actions/launch",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        launchInstanceConfigurationRequest.instanceConfiguration,
        "InstanceConfigurationInstanceDetails",
        models.InstanceConfigurationInstanceDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.LaunchInstanceConfigurationResponse>{},
        body: await response.json(),
        bodyKey: "instance",
        bodyModel: "model.Instance",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Lists the instances in the specified cluster network.
   * @param ListClusterNetworkInstancesRequest
   * @return ListClusterNetworkInstancesResponse
   * @throws OciError when an error occurs
   */
  public async listClusterNetworkInstances(
    listClusterNetworkInstancesRequest: requests.ListClusterNetworkInstancesRequest
  ): Promise<responses.ListClusterNetworkInstancesResponse> {
    const pathParams = {
      "{clusterNetworkId}": listClusterNetworkInstancesRequest.clusterNetworkId
    };

    const queryParams = {
      "compartmentId": listClusterNetworkInstancesRequest.compartmentId,
      "displayName": listClusterNetworkInstancesRequest.displayName,
      "limit": listClusterNetworkInstancesRequest.limit,
      "page": listClusterNetworkInstancesRequest.page,
      "sortBy": listClusterNetworkInstancesRequest.sortBy,
      "sortOrder": listClusterNetworkInstancesRequest.sortOrder
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/clusterNetworks/{clusterNetworkId}/instances",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListClusterNetworkInstancesResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "InstanceSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.InstanceSummary objects
   * contained in responses from the listClusterNetworkInstances operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllClusterNetworkInstances(
    request: requests.ListClusterNetworkInstancesRequest
  ): AsyncIterableIterator<models.InstanceSummary> {
    return paginateRecords(request, req => this.listClusterNetworkInstances(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listClusterNetworkInstances operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllClusterNetworkInstancesResponses(
    request: requests.ListClusterNetworkInstancesRequest
  ): AsyncIterableIterator<responses.ListClusterNetworkInstancesResponse> {
    return paginateResponses(request, req => this.listClusterNetworkInstances(req));
  }

  /**
   * Lists the cluster networks in the specified compartment.
   * @param ListClusterNetworksRequest
   * @return ListClusterNetworksResponse
   * @throws OciError when an error occurs
   */
  public async listClusterNetworks(
    listClusterNetworksRequest: requests.ListClusterNetworksRequest
  ): Promise<responses.ListClusterNetworksResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listClusterNetworksRequest.compartmentId,
      "displayName": listClusterNetworksRequest.displayName,
      "limit": listClusterNetworksRequest.limit,
      "page": listClusterNetworksRequest.page,
      "sortBy": listClusterNetworksRequest.sortBy,
      "sortOrder": listClusterNetworksRequest.sortOrder,
      "lifecycleState": listClusterNetworksRequest.lifecycleState
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/clusterNetworks",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListClusterNetworksResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "ClusterNetworkSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.ClusterNetworkSummary objects
   * contained in responses from the listClusterNetworks operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllClusterNetworks(
    request: requests.ListClusterNetworksRequest
  ): AsyncIterableIterator<models.ClusterNetworkSummary> {
    return paginateRecords(request, req => this.listClusterNetworks(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listClusterNetworks operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllClusterNetworksResponses(
    request: requests.ListClusterNetworksRequest
  ): AsyncIterableIterator<responses.ListClusterNetworksResponse> {
    return paginateResponses(request, req => this.listClusterNetworks(req));
  }

  /**
   * Lists the instance configurations in the specified compartment.
   *
   * @param ListInstanceConfigurationsRequest
   * @return ListInstanceConfigurationsResponse
   * @throws OciError when an error occurs
   */
  public async listInstanceConfigurations(
    listInstanceConfigurationsRequest: requests.ListInstanceConfigurationsRequest
  ): Promise<responses.ListInstanceConfigurationsResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listInstanceConfigurationsRequest.compartmentId,
      "limit": listInstanceConfigurationsRequest.limit,
      "page": listInstanceConfigurationsRequest.page,
      "sortBy": listInstanceConfigurationsRequest.sortBy,
      "sortOrder": listInstanceConfigurationsRequest.sortOrder
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/instanceConfigurations",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListInstanceConfigurationsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "InstanceConfigurationSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.InstanceConfigurationSummary objects
   * contained in responses from the listInstanceConfigurations operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllInstanceConfigurations(
    request: requests.ListInstanceConfigurationsRequest
  ): AsyncIterableIterator<models.InstanceConfigurationSummary> {
    return paginateRecords(request, req => this.listInstanceConfigurations(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listInstanceConfigurations operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllInstanceConfigurationsResponses(
    request: requests.ListInstanceConfigurationsRequest
  ): AsyncIterableIterator<responses.ListInstanceConfigurationsResponse> {
    return paginateResponses(request, req => this.listInstanceConfigurations(req));
  }

  /**
   * List the instances in the specified instance pool.
   * @param ListInstancePoolInstancesRequest
   * @return ListInstancePoolInstancesResponse
   * @throws OciError when an error occurs
   */
  public async listInstancePoolInstances(
    listInstancePoolInstancesRequest: requests.ListInstancePoolInstancesRequest
  ): Promise<responses.ListInstancePoolInstancesResponse> {
    const pathParams = {
      "{instancePoolId}": listInstancePoolInstancesRequest.instancePoolId
    };

    const queryParams = {
      "compartmentId": listInstancePoolInstancesRequest.compartmentId,
      "displayName": listInstancePoolInstancesRequest.displayName,
      "limit": listInstancePoolInstancesRequest.limit,
      "page": listInstancePoolInstancesRequest.page,
      "sortBy": listInstancePoolInstancesRequest.sortBy,
      "sortOrder": listInstancePoolInstancesRequest.sortOrder
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/instancePools/{instancePoolId}/instances",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListInstancePoolInstancesResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "InstanceSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.InstanceSummary objects
   * contained in responses from the listInstancePoolInstances operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllInstancePoolInstances(
    request: requests.ListInstancePoolInstancesRequest
  ): AsyncIterableIterator<models.InstanceSummary> {
    return paginateRecords(request, req => this.listInstancePoolInstances(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listInstancePoolInstances operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllInstancePoolInstancesResponses(
    request: requests.ListInstancePoolInstancesRequest
  ): AsyncIterableIterator<responses.ListInstancePoolInstancesResponse> {
    return paginateResponses(request, req => this.listInstancePoolInstances(req));
  }

  /**
   * Lists the instance pools in the specified compartment.
   * @param ListInstancePoolsRequest
   * @return ListInstancePoolsResponse
   * @throws OciError when an error occurs
   */
  public async listInstancePools(
    listInstancePoolsRequest: requests.ListInstancePoolsRequest
  ): Promise<responses.ListInstancePoolsResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listInstancePoolsRequest.compartmentId,
      "displayName": listInstancePoolsRequest.displayName,
      "limit": listInstancePoolsRequest.limit,
      "page": listInstancePoolsRequest.page,
      "sortBy": listInstancePoolsRequest.sortBy,
      "sortOrder": listInstancePoolsRequest.sortOrder,
      "lifecycleState": listInstancePoolsRequest.lifecycleState
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/instancePools",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListInstancePoolsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "InstancePoolSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.InstancePoolSummary objects
   * contained in responses from the listInstancePools operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllInstancePools(
    request: requests.ListInstancePoolsRequest
  ): AsyncIterableIterator<models.InstancePoolSummary> {
    return paginateRecords(request, req => this.listInstancePools(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listInstancePools operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllInstancePoolsResponses(
    request: requests.ListInstancePoolsRequest
  ): AsyncIterableIterator<responses.ListInstancePoolsResponse> {
    return paginateResponses(request, req => this.listInstancePools(req));
  }

  /**
   * Performs the reset (power off and power on) action on the specified instance pool,
   * which performs the action on all the instances in the pool.
   *
   * @param ResetInstancePoolRequest
   * @return ResetInstancePoolResponse
   * @throws OciError when an error occurs
   */
  public async resetInstancePool(
    resetInstancePoolRequest: requests.ResetInstancePoolRequest
  ): Promise<responses.ResetInstancePoolResponse> {
    const pathParams = {
      "{instancePoolId}": resetInstancePoolRequest.instancePoolId
    };

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": resetInstancePoolRequest.opcRetryToken,
      "if-match": resetInstancePoolRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/instancePools/{instancePoolId}/actions/reset",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ResetInstancePoolResponse>{},
        body: await response.json(),
        bodyKey: "instancePool",
        bodyModel: "model.InstancePool",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Performs the softreset (ACPI shutdown and power on) action on the specified instance pool,
   * which performs the action on all the instances in the pool.
   *
   * @param SoftresetInstancePoolRequest
   * @return SoftresetInstancePoolResponse
   * @throws OciError when an error occurs
   */
  public async softresetInstancePool(
    softresetInstancePoolRequest: requests.SoftresetInstancePoolRequest
  ): Promise<responses.SoftresetInstancePoolResponse> {
    const pathParams = {
      "{instancePoolId}": softresetInstancePoolRequest.instancePoolId
    };

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": softresetInstancePoolRequest.opcRetryToken,
      "if-match": softresetInstancePoolRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/instancePools/{instancePoolId}/actions/softreset",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.SoftresetInstancePoolResponse>{},
        body: await response.json(),
        bodyKey: "instancePool",
        bodyModel: "model.InstancePool",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Performs the start (power on) action on the specified instance pool,
   * which performs the action on all the instances in the pool.
   *
   * @param StartInstancePoolRequest
   * @return StartInstancePoolResponse
   * @throws OciError when an error occurs
   */
  public async startInstancePool(
    startInstancePoolRequest: requests.StartInstancePoolRequest
  ): Promise<responses.StartInstancePoolResponse> {
    const pathParams = {
      "{instancePoolId}": startInstancePoolRequest.instancePoolId
    };

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": startInstancePoolRequest.opcRetryToken,
      "if-match": startInstancePoolRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/instancePools/{instancePoolId}/actions/start",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.StartInstancePoolResponse>{},
        body: await response.json(),
        bodyKey: "instancePool",
        bodyModel: "model.InstancePool",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Performs the stop (power off) action on the specified instance pool,
   * which performs the action on all the instances in the pool.
   *
   * @param StopInstancePoolRequest
   * @return StopInstancePoolResponse
   * @throws OciError when an error occurs
   */
  public async stopInstancePool(
    stopInstancePoolRequest: requests.StopInstancePoolRequest
  ): Promise<responses.StopInstancePoolResponse> {
    const pathParams = {
      "{instancePoolId}": stopInstancePoolRequest.instancePoolId
    };

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": stopInstancePoolRequest.opcRetryToken,
      "if-match": stopInstancePoolRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/instancePools/{instancePoolId}/actions/stop",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.StopInstancePoolResponse>{},
        body: await response.json(),
        bodyKey: "instancePool",
        bodyModel: "model.InstancePool",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Terminates the specified cluster network.
* <p>
When you delete a cluster network, all of its resources are permanently deleted,
* including associated instances and instance pools.
* 
     * @param TerminateClusterNetworkRequest
     * @return TerminateClusterNetworkResponse
     * @throws OciError when an error occurs
     */
  public async terminateClusterNetwork(
    terminateClusterNetworkRequest: requests.TerminateClusterNetworkRequest
  ): Promise<responses.TerminateClusterNetworkResponse> {
    const pathParams = {
      "{clusterNetworkId}": terminateClusterNetworkRequest.clusterNetworkId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": terminateClusterNetworkRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/clusterNetworks/{clusterNetworkId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.TerminateClusterNetworkResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Terminate the specified instance pool.
   * @param TerminateInstancePoolRequest
   * @return TerminateInstancePoolResponse
   * @throws OciError when an error occurs
   */
  public async terminateInstancePool(
    terminateInstancePoolRequest: requests.TerminateInstancePoolRequest
  ): Promise<responses.TerminateInstancePoolResponse> {
    const pathParams = {
      "{instancePoolId}": terminateInstancePoolRequest.instancePoolId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": terminateInstancePoolRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/instancePools/{instancePoolId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.TerminateInstancePoolResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates the specified cluster network. The OCID of the cluster network remains the same.
   *
   * @param UpdateClusterNetworkRequest
   * @return UpdateClusterNetworkResponse
   * @throws OciError when an error occurs
   */
  public async updateClusterNetwork(
    updateClusterNetworkRequest: requests.UpdateClusterNetworkRequest
  ): Promise<responses.UpdateClusterNetworkResponse> {
    const pathParams = {
      "{clusterNetworkId}": updateClusterNetworkRequest.clusterNetworkId
    };

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": updateClusterNetworkRequest.opcRetryToken,
      "if-match": updateClusterNetworkRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/clusterNetworks/{clusterNetworkId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateClusterNetworkRequest.updateClusterNetworkDetails,
        "UpdateClusterNetworkDetails",
        models.UpdateClusterNetworkDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateClusterNetworkResponse>{},
        body: await response.json(),
        bodyKey: "clusterNetwork",
        bodyModel: "model.ClusterNetwork",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates the free-form tags, defined tags, and display name of an instance configuration.
   * @param UpdateInstanceConfigurationRequest
   * @return UpdateInstanceConfigurationResponse
   * @throws OciError when an error occurs
   */
  public async updateInstanceConfiguration(
    updateInstanceConfigurationRequest: requests.UpdateInstanceConfigurationRequest
  ): Promise<responses.UpdateInstanceConfigurationResponse> {
    const pathParams = {
      "{instanceConfigurationId}": updateInstanceConfigurationRequest.instanceConfigurationId
    };

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": updateInstanceConfigurationRequest.opcRetryToken,
      "if-match": updateInstanceConfigurationRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/instanceConfigurations/{instanceConfigurationId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateInstanceConfigurationRequest.updateInstanceConfigurationDetails,
        "UpdateInstanceConfigurationDetails",
        models.UpdateInstanceConfigurationDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateInstanceConfigurationResponse>{},
        body: await response.json(),
        bodyKey: "instanceConfiguration",
        bodyModel: "model.InstanceConfiguration",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Update the specified instance pool.
* <p>
The OCID of the instance pool remains the same.
* 
     * @param UpdateInstancePoolRequest
     * @return UpdateInstancePoolResponse
     * @throws OciError when an error occurs
     */
  public async updateInstancePool(
    updateInstancePoolRequest: requests.UpdateInstancePoolRequest
  ): Promise<responses.UpdateInstancePoolResponse> {
    const pathParams = {
      "{instancePoolId}": updateInstancePoolRequest.instancePoolId
    };

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": updateInstancePoolRequest.opcRetryToken,
      "if-match": updateInstancePoolRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/instancePools/{instancePoolId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateInstancePoolRequest.updateInstancePoolDetails,
        "UpdateInstancePoolDetails",
        models.UpdateInstancePoolDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateInstancePoolResponse>{},
        body: await response.json(),
        bodyKey: "instancePool",
        bodyModel: "model.InstancePool",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }
}
export enum VirtualNetworkApiKeys {}

export class VirtualNetworkClient {
  protected static serviceEndpointTemplate = "https://iaas.{region}.{secondLevelDomain}";
  protected "_endpoint": string = "";
  protected "_defaultHeaders": any = {};
  protected "_waiters": VirtualNetworkWaiter;

  protected _httpClient: common.HttpClient;

  constructor(params: common.AuthParams) {
    const requestSigner = params.authenticationDetailsProvider
      ? new common.DefaultRequestSigner(params.authenticationDetailsProvider)
      : null;
    this._httpClient = params.httpClient || new common.FetchHttpClient(requestSigner);

    if (
      params.authenticationDetailsProvider &&
      common.isRegionProvider(params.authenticationDetailsProvider)
    ) {
      const provider: common.RegionProvider = params.authenticationDetailsProvider;
      if (provider.getRegion()) {
        this.region = provider.getRegion();
      }
    }
  }

  /**
   * Sets the endpoint to call (ex, https://www.example.com).
   * @param endpoint The endpoint of the service.
   */
  public set endpoint(endpoint: string) {
    this._endpoint = endpoint;
    this._endpoint = this._endpoint + "/20160918";
  }

  /**
   * Sets the region to call (ex, Region.US_PHOENIX_1).
   * Note, this will call {@link #endpoint(String) endpoint} after resolving the endpoint.
   * @param region The region of the service.
   */
  public set region(region: common.Region) {
    this.endpoint = common.EndpointBuilder.createEndpointFromRegion(
      VirtualNetworkClient.serviceEndpointTemplate,
      region
    );
  }

  /**
   * Sets the regionId to call (ex, 'us-phoenix-1').
   *
   * Note, this will first try to map the region ID to a known Region and call {@link #region(Region) region}.
   * If no known Region could be determined, it will create an endpoint assuming its in default Realm OC1
   * and then call {@link #endpoint(String) endpoint}.
   * @param regionId The public region ID.
   */
  public set regionId(regionId: string) {
    this.endpoint = common.EndpointBuilder.createEndpointFromRegionId(
      VirtualNetworkClient.serviceEndpointTemplate,
      regionId
    );
  }

  /**
   * Creates a new VirtualNetworkWaiter for resources for this service.
   *
   * @param workRequestClient The work request service client used to query for work request status
   * @param config The waiter configuration for termination and delay strategy
   * @return The service waiters.
   */
  public createWaiters(
    workRequestClient: WorkRequestClient,
    config?: common.WaiterConfiguration
  ): VirtualNetworkWaiter {
    this._waiters = new VirtualNetworkWaiter(this, workRequestClient, config);
    return this._waiters;
  }

  /**
   * Gets the waiters available for resources for this service.
   *
   * @return The service waiters.
   */
  public getWaiters(): VirtualNetworkWaiter {
    if (this._waiters) {
      return this._waiters;
    }
    throw Error("Waiters do not exist. Please create waiters.");
  }

  /**
   * Accepts a local peering token generated by a peer in the same region.
   *
   * @param AcceptLocalPeeringTokenRequest
   * @return AcceptLocalPeeringTokenResponse
   * @throws OciError when an error occurs
   */
  public async acceptLocalPeeringToken(
    acceptLocalPeeringTokenRequest: requests.AcceptLocalPeeringTokenRequest
  ): Promise<responses.AcceptLocalPeeringTokenResponse> {
    const pathParams = {
      "{localPeeringConnectionId}": acceptLocalPeeringTokenRequest.localPeeringConnectionId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/localPeeringConnections/{localPeeringConnectionId}/actions/acceptPeeringToken",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        acceptLocalPeeringTokenRequest.acceptLocalPeeringTokenDetails,
        "AcceptLocalPeeringTokenDetails",
        models.AcceptLocalPeeringTokenDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.AcceptLocalPeeringTokenResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Adds one or more security rules to the specified network security group.
   *
   * @param AddNetworkSecurityGroupSecurityRulesRequest
   * @return AddNetworkSecurityGroupSecurityRulesResponse
   * @throws OciError when an error occurs
   */
  public async addNetworkSecurityGroupSecurityRules(
    addNetworkSecurityGroupSecurityRulesRequest: requests.AddNetworkSecurityGroupSecurityRulesRequest
  ): Promise<responses.AddNetworkSecurityGroupSecurityRulesResponse> {
    const pathParams = {
      "{networkSecurityGroupId}": addNetworkSecurityGroupSecurityRulesRequest.networkSecurityGroupId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/networkSecurityGroups/{networkSecurityGroupId}/actions/addSecurityRules",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        addNetworkSecurityGroupSecurityRulesRequest.addNetworkSecurityGroupSecurityRulesDetails,
        "AddNetworkSecurityGroupSecurityRulesDetails",
        models.AddNetworkSecurityGroupSecurityRulesDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.AddNetworkSecurityGroupSecurityRulesResponse>{},
        body: await response.json(),
        bodyKey: "addedNetworkSecurityGroupSecurityRules",
        bodyModel: "model.AddedNetworkSecurityGroupSecurityRules",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Adds the specified {@link Service} to the list of enabled
   * `Service` objects for the specified gateway. You must also set up a route rule with the
   * `cidrBlock` of the `Service` as the rule's destination and the service gateway as the rule's
   * target. See {@link RouteTable}.
   * <p>
   **Note:** The `AttachServiceId` operation is an easy way to add an individual `Service` to
   * the service gateway. Compare it with
   * {@link #updateServiceGateway(UpdateServiceGatewayRequest) updateServiceGateway}, which replaces
   * the entire existing list of enabled `Service` objects with the list that you provide in the
   * `Update` call.
   *
   * @param AttachServiceIdRequest
   * @return AttachServiceIdResponse
   * @throws OciError when an error occurs
   */
  public async attachServiceId(
    attachServiceIdRequest: requests.AttachServiceIdRequest
  ): Promise<responses.AttachServiceIdResponse> {
    const pathParams = {
      "{serviceGatewayId}": attachServiceIdRequest.serviceGatewayId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": attachServiceIdRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/serviceGateways/{serviceGatewayId}/actions/attachService",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        attachServiceIdRequest.attachServiceDetails,
        "ServiceIdRequestDetails",
        models.ServiceIdRequestDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.AttachServiceIdResponse>{},
        body: await response.json(),
        bodyKey: "serviceGateway",
        bodyModel: "model.ServiceGateway",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Adds one or more customer public IP prefixes to the specified public virtual circuit.
   * Use this operation (and not {@link #updateVirtualCircuit(UpdateVirtualCircuitRequest) updateVirtualCircuit})
   * to add prefixes to the virtual circuit. Oracle must verify the customer's ownership
   * of each prefix before traffic for that prefix will flow across the virtual circuit.
   *
   * @param BulkAddVirtualCircuitPublicPrefixesRequest
   * @return BulkAddVirtualCircuitPublicPrefixesResponse
   * @throws OciError when an error occurs
   */
  public async bulkAddVirtualCircuitPublicPrefixes(
    bulkAddVirtualCircuitPublicPrefixesRequest: requests.BulkAddVirtualCircuitPublicPrefixesRequest
  ): Promise<responses.BulkAddVirtualCircuitPublicPrefixesResponse> {
    const pathParams = {
      "{virtualCircuitId}": bulkAddVirtualCircuitPublicPrefixesRequest.virtualCircuitId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/virtualCircuits/{virtualCircuitId}/actions/bulkAddPublicPrefixes",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        bulkAddVirtualCircuitPublicPrefixesRequest.bulkAddVirtualCircuitPublicPrefixesDetails,
        "BulkAddVirtualCircuitPublicPrefixesDetails",
        models.BulkAddVirtualCircuitPublicPrefixesDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.BulkAddVirtualCircuitPublicPrefixesResponse>{},
        responseHeaders: []
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Removes one or more customer public IP prefixes from the specified public virtual circuit.
   * Use this operation (and not {@link #updateVirtualCircuit(UpdateVirtualCircuitRequest) updateVirtualCircuit})
   * to remove prefixes from the virtual circuit. When the virtual circuit's state switches
   * back to PROVISIONED, Oracle stops advertising the specified prefixes across the connection.
   *
   * @param BulkDeleteVirtualCircuitPublicPrefixesRequest
   * @return BulkDeleteVirtualCircuitPublicPrefixesResponse
   * @throws OciError when an error occurs
   */
  public async bulkDeleteVirtualCircuitPublicPrefixes(
    bulkDeleteVirtualCircuitPublicPrefixesRequest: requests.BulkDeleteVirtualCircuitPublicPrefixesRequest
  ): Promise<responses.BulkDeleteVirtualCircuitPublicPrefixesResponse> {
    const pathParams = {
      "{virtualCircuitId}": bulkDeleteVirtualCircuitPublicPrefixesRequest.virtualCircuitId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/virtualCircuits/{virtualCircuitId}/actions/bulkDeletePublicPrefixes",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        bulkDeleteVirtualCircuitPublicPrefixesRequest.bulkDeleteVirtualCircuitPublicPrefixesDetails,
        "BulkDeleteVirtualCircuitPublicPrefixesDetails",
        models.BulkDeleteVirtualCircuitPublicPrefixesDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.BulkDeleteVirtualCircuitPublicPrefixesResponse>{},
        responseHeaders: []
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Moves a CPE object into a different compartment within the same tenancy. For information
   * about moving resources between compartments, see
   * [Moving Resources to a Different Compartment](https://docs.cloud.oracle.com/iaas/Content/Identity/Tasks/managingcompartments.htm#moveRes).
   *
   * @param ChangeCpeCompartmentRequest
   * @return ChangeCpeCompartmentResponse
   * @throws OciError when an error occurs
   */
  public async changeCpeCompartment(
    changeCpeCompartmentRequest: requests.ChangeCpeCompartmentRequest
  ): Promise<responses.ChangeCpeCompartmentResponse> {
    const pathParams = {
      "{cpeId}": changeCpeCompartmentRequest.cpeId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": changeCpeCompartmentRequest.opcRequestId,
      "opc-retry-token": changeCpeCompartmentRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/cpes/{cpeId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeCpeCompartmentRequest.changeCpeCompartmentDetails,
        "ChangeCpeCompartmentDetails",
        models.ChangeCpeCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeCpeCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Moves a cross-connect into a different compartment within the same tenancy. For information
   * about moving resources between compartments, see
   * [Moving Resources to a Different Compartment](https://docs.cloud.oracle.com/iaas/Content/Identity/Tasks/managingcompartments.htm#moveRes).
   *
   * @param ChangeCrossConnectCompartmentRequest
   * @return ChangeCrossConnectCompartmentResponse
   * @throws OciError when an error occurs
   */
  public async changeCrossConnectCompartment(
    changeCrossConnectCompartmentRequest: requests.ChangeCrossConnectCompartmentRequest
  ): Promise<responses.ChangeCrossConnectCompartmentResponse> {
    const pathParams = {
      "{crossConnectId}": changeCrossConnectCompartmentRequest.crossConnectId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": changeCrossConnectCompartmentRequest.opcRequestId,
      "opc-retry-token": changeCrossConnectCompartmentRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/crossConnects/{crossConnectId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeCrossConnectCompartmentRequest.changeCrossConnectCompartmentDetails,
        "ChangeCrossConnectCompartmentDetails",
        models.ChangeCrossConnectCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeCrossConnectCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Moves a cross-connect group into a different compartment within the same tenancy. For information
   * about moving resources between compartments, see
   * [Moving Resources to a Different Compartment](https://docs.cloud.oracle.com/iaas/Content/Identity/Tasks/managingcompartments.htm#moveRes).
   *
   * @param ChangeCrossConnectGroupCompartmentRequest
   * @return ChangeCrossConnectGroupCompartmentResponse
   * @throws OciError when an error occurs
   */
  public async changeCrossConnectGroupCompartment(
    changeCrossConnectGroupCompartmentRequest: requests.ChangeCrossConnectGroupCompartmentRequest
  ): Promise<responses.ChangeCrossConnectGroupCompartmentResponse> {
    const pathParams = {
      "{crossConnectGroupId}": changeCrossConnectGroupCompartmentRequest.crossConnectGroupId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": changeCrossConnectGroupCompartmentRequest.opcRequestId,
      "opc-retry-token": changeCrossConnectGroupCompartmentRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/crossConnectGroups/{crossConnectGroupId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeCrossConnectGroupCompartmentRequest.changeCrossConnectGroupCompartmentDetails,
        "ChangeCrossConnectGroupCompartmentDetails",
        models.ChangeCrossConnectGroupCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeCrossConnectGroupCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Moves a set of DHCP options into a different compartment within the same tenancy. For information
   * about moving resources between compartments, see
   * [Moving Resources to a Different Compartment](https://docs.cloud.oracle.com/iaas/Content/Identity/Tasks/managingcompartments.htm#moveRes).
   *
   * @param ChangeDhcpOptionsCompartmentRequest
   * @return ChangeDhcpOptionsCompartmentResponse
   * @throws OciError when an error occurs
   */
  public async changeDhcpOptionsCompartment(
    changeDhcpOptionsCompartmentRequest: requests.ChangeDhcpOptionsCompartmentRequest
  ): Promise<responses.ChangeDhcpOptionsCompartmentResponse> {
    const pathParams = {
      "{dhcpId}": changeDhcpOptionsCompartmentRequest.dhcpId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": changeDhcpOptionsCompartmentRequest.opcRequestId,
      "opc-retry-token": changeDhcpOptionsCompartmentRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/dhcps/{dhcpId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeDhcpOptionsCompartmentRequest.changeDhcpOptionsCompartmentDetails,
        "ChangeDhcpOptionsCompartmentDetails",
        models.ChangeDhcpOptionsCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeDhcpOptionsCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Moves a DRG into a different compartment within the same tenancy. For information
   * about moving resources between compartments, see
   * [Moving Resources to a Different Compartment](https://docs.cloud.oracle.com/iaas/Content/Identity/Tasks/managingcompartments.htm#moveRes).
   *
   * @param ChangeDrgCompartmentRequest
   * @return ChangeDrgCompartmentResponse
   * @throws OciError when an error occurs
   */
  public async changeDrgCompartment(
    changeDrgCompartmentRequest: requests.ChangeDrgCompartmentRequest
  ): Promise<responses.ChangeDrgCompartmentResponse> {
    const pathParams = {
      "{drgId}": changeDrgCompartmentRequest.drgId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": changeDrgCompartmentRequest.opcRequestId,
      "opc-retry-token": changeDrgCompartmentRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/drgs/{drgId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeDrgCompartmentRequest.changeDrgCompartmentDetails,
        "ChangeDrgCompartmentDetails",
        models.ChangeDrgCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeDrgCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Moves an IPSec connection into a different compartment within the same tenancy. For information
   * about moving resources between compartments, see
   * [Moving Resources to a Different Compartment](https://docs.cloud.oracle.com/iaas/Content/Identity/Tasks/managingcompartments.htm#moveRes).
   *
   * @param ChangeIPSecConnectionCompartmentRequest
   * @return ChangeIPSecConnectionCompartmentResponse
   * @throws OciError when an error occurs
   */
  public async changeIPSecConnectionCompartment(
    changeIPSecConnectionCompartmentRequest: requests.ChangeIPSecConnectionCompartmentRequest
  ): Promise<responses.ChangeIPSecConnectionCompartmentResponse> {
    const pathParams = {
      "{ipscId}": changeIPSecConnectionCompartmentRequest.ipscId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": changeIPSecConnectionCompartmentRequest.opcRequestId,
      "opc-retry-token": changeIPSecConnectionCompartmentRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/ipsecConnections/{ipscId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeIPSecConnectionCompartmentRequest.changeIPSecConnectionCompartmentDetails,
        "ChangeIPSecConnectionCompartmentDetails",
        models.ChangeIPSecConnectionCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeIPSecConnectionCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Moves an internet gateway into a different compartment within the same tenancy. For information
   * about moving resources between compartments, see
   * [Moving Resources to a Different Compartment](https://docs.cloud.oracle.com/iaas/Content/Identity/Tasks/managingcompartments.htm#moveRes).
   *
   * @param ChangeInternetGatewayCompartmentRequest
   * @return ChangeInternetGatewayCompartmentResponse
   * @throws OciError when an error occurs
   */
  public async changeInternetGatewayCompartment(
    changeInternetGatewayCompartmentRequest: requests.ChangeInternetGatewayCompartmentRequest
  ): Promise<responses.ChangeInternetGatewayCompartmentResponse> {
    const pathParams = {
      "{igId}": changeInternetGatewayCompartmentRequest.igId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": changeInternetGatewayCompartmentRequest.opcRequestId,
      "opc-retry-token": changeInternetGatewayCompartmentRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/internetGateways/{igId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeInternetGatewayCompartmentRequest.changeInternetGatewayCompartmentDetails,
        "ChangeInternetGatewayCompartmentDetails",
        models.ChangeInternetGatewayCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeInternetGatewayCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Moves a local peering gateway into a different compartment within the same tenancy. For information
   * about moving resources between compartments, see
   * [Moving Resources to a Different Compartment](https://docs.cloud.oracle.com/iaas/Content/Identity/Tasks/managingcompartments.htm#moveRes).
   *
   * @param ChangeLocalPeeringGatewayCompartmentRequest
   * @return ChangeLocalPeeringGatewayCompartmentResponse
   * @throws OciError when an error occurs
   */
  public async changeLocalPeeringGatewayCompartment(
    changeLocalPeeringGatewayCompartmentRequest: requests.ChangeLocalPeeringGatewayCompartmentRequest
  ): Promise<responses.ChangeLocalPeeringGatewayCompartmentResponse> {
    const pathParams = {
      "{localPeeringGatewayId}": changeLocalPeeringGatewayCompartmentRequest.localPeeringGatewayId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": changeLocalPeeringGatewayCompartmentRequest.opcRequestId,
      "opc-retry-token": changeLocalPeeringGatewayCompartmentRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/localPeeringGateways/{localPeeringGatewayId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeLocalPeeringGatewayCompartmentRequest.changeLocalPeeringGatewayCompartmentDetails,
        "ChangeLocalPeeringGatewayCompartmentDetails",
        models.ChangeLocalPeeringGatewayCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeLocalPeeringGatewayCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Moves a NAT gateway into a different compartment within the same tenancy. For information
   * about moving resources between compartments, see
   * [Moving Resources to a Different Compartment](https://docs.cloud.oracle.com/iaas/Content/Identity/Tasks/managingcompartments.htm#moveRes).
   *
   * @param ChangeNatGatewayCompartmentRequest
   * @return ChangeNatGatewayCompartmentResponse
   * @throws OciError when an error occurs
   */
  public async changeNatGatewayCompartment(
    changeNatGatewayCompartmentRequest: requests.ChangeNatGatewayCompartmentRequest
  ): Promise<responses.ChangeNatGatewayCompartmentResponse> {
    const pathParams = {
      "{natGatewayId}": changeNatGatewayCompartmentRequest.natGatewayId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": changeNatGatewayCompartmentRequest.opcRequestId,
      "opc-retry-token": changeNatGatewayCompartmentRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/natGateways/{natGatewayId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeNatGatewayCompartmentRequest.changeNatGatewayCompartmentDetails,
        "ChangeNatGatewayCompartmentDetails",
        models.ChangeNatGatewayCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeNatGatewayCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Moves a network security group into a different compartment within the same tenancy. For
   * information about moving resources between compartments, see [Moving Resources to a Different Compartment](https://docs.cloud.oracle.com/iaas/Content/Identity/Tasks/managingcompartments.htm#moveRes).
   *
   * @param ChangeNetworkSecurityGroupCompartmentRequest
   * @return ChangeNetworkSecurityGroupCompartmentResponse
   * @throws OciError when an error occurs
   */
  public async changeNetworkSecurityGroupCompartment(
    changeNetworkSecurityGroupCompartmentRequest: requests.ChangeNetworkSecurityGroupCompartmentRequest
  ): Promise<responses.ChangeNetworkSecurityGroupCompartmentResponse> {
    const pathParams = {
      "{networkSecurityGroupId}":
        changeNetworkSecurityGroupCompartmentRequest.networkSecurityGroupId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": changeNetworkSecurityGroupCompartmentRequest.opcRequestId,
      "opc-retry-token": changeNetworkSecurityGroupCompartmentRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/networkSecurityGroups/{networkSecurityGroupId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeNetworkSecurityGroupCompartmentRequest.changeNetworkSecurityGroupCompartmentDetails,
        "ChangeNetworkSecurityGroupCompartmentDetails",
        models.ChangeNetworkSecurityGroupCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeNetworkSecurityGroupCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Moves a public IP into a different compartment within the same tenancy. For information
* about moving resources between compartments, see
* [Moving Resources to a Different Compartment](https://docs.cloud.oracle.com/iaas/Content/Identity/Tasks/managingcompartments.htm#moveRes).
* <p>
This operation applies only to reserved public IPs. Ephemeral public IPs always belong to the
* same compartment as their VNIC and move accordingly.
* 
     * @param ChangePublicIpCompartmentRequest
     * @return ChangePublicIpCompartmentResponse
     * @throws OciError when an error occurs
     */
  public async changePublicIpCompartment(
    changePublicIpCompartmentRequest: requests.ChangePublicIpCompartmentRequest
  ): Promise<responses.ChangePublicIpCompartmentResponse> {
    const pathParams = {
      "{publicIpId}": changePublicIpCompartmentRequest.publicIpId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": changePublicIpCompartmentRequest.opcRequestId,
      "opc-retry-token": changePublicIpCompartmentRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/publicIps/{publicIpId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changePublicIpCompartmentRequest.changePublicIpCompartmentDetails,
        "ChangePublicIpCompartmentDetails",
        models.ChangePublicIpCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangePublicIpCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Moves a remote peering connection (RPC) into a different compartment within the same tenancy. For information
   * about moving resources between compartments, see
   * [Moving Resources to a Different Compartment](https://docs.cloud.oracle.com/iaas/Content/Identity/Tasks/managingcompartments.htm#moveRes).
   *
   * @param ChangeRemotePeeringConnectionCompartmentRequest
   * @return ChangeRemotePeeringConnectionCompartmentResponse
   * @throws OciError when an error occurs
   */
  public async changeRemotePeeringConnectionCompartment(
    changeRemotePeeringConnectionCompartmentRequest: requests.ChangeRemotePeeringConnectionCompartmentRequest
  ): Promise<responses.ChangeRemotePeeringConnectionCompartmentResponse> {
    const pathParams = {
      "{remotePeeringConnectionId}":
        changeRemotePeeringConnectionCompartmentRequest.remotePeeringConnectionId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": changeRemotePeeringConnectionCompartmentRequest.opcRequestId,
      "opc-retry-token": changeRemotePeeringConnectionCompartmentRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/remotePeeringConnections/{remotePeeringConnectionId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeRemotePeeringConnectionCompartmentRequest.changeRemotePeeringConnectionCompartmentDetails,
        "ChangeRemotePeeringConnectionCompartmentDetails",
        models.ChangeRemotePeeringConnectionCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeRemotePeeringConnectionCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Moves a route table into a different compartment within the same tenancy. For information
   * about moving resources between compartments, see
   * [Moving Resources to a Different Compartment](https://docs.cloud.oracle.com/iaas/Content/Identity/Tasks/managingcompartments.htm#moveRes).
   *
   * @param ChangeRouteTableCompartmentRequest
   * @return ChangeRouteTableCompartmentResponse
   * @throws OciError when an error occurs
   */
  public async changeRouteTableCompartment(
    changeRouteTableCompartmentRequest: requests.ChangeRouteTableCompartmentRequest
  ): Promise<responses.ChangeRouteTableCompartmentResponse> {
    const pathParams = {
      "{rtId}": changeRouteTableCompartmentRequest.rtId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": changeRouteTableCompartmentRequest.opcRequestId,
      "opc-retry-token": changeRouteTableCompartmentRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/routeTables/{rtId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeRouteTableCompartmentRequest.changeRouteTableCompartmentDetails,
        "ChangeRouteTableCompartmentDetails",
        models.ChangeRouteTableCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeRouteTableCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Moves a security list into a different compartment within the same tenancy. For information
   * about moving resources between compartments, see
   * [Moving Resources to a Different Compartment](https://docs.cloud.oracle.com/iaas/Content/Identity/Tasks/managingcompartments.htm#moveRes).
   *
   * @param ChangeSecurityListCompartmentRequest
   * @return ChangeSecurityListCompartmentResponse
   * @throws OciError when an error occurs
   */
  public async changeSecurityListCompartment(
    changeSecurityListCompartmentRequest: requests.ChangeSecurityListCompartmentRequest
  ): Promise<responses.ChangeSecurityListCompartmentResponse> {
    const pathParams = {
      "{securityListId}": changeSecurityListCompartmentRequest.securityListId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": changeSecurityListCompartmentRequest.opcRequestId,
      "opc-retry-token": changeSecurityListCompartmentRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/securityLists/{securityListId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeSecurityListCompartmentRequest.changeSecurityListCompartmentDetails,
        "ChangeSecurityListCompartmentDetails",
        models.ChangeSecurityListCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeSecurityListCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Moves a service gateway into a different compartment within the same tenancy. For information
   * about moving resources between compartments, see
   * [Moving Resources to a Different Compartment](https://docs.cloud.oracle.com/iaas/Content/Identity/Tasks/managingcompartments.htm#moveRes).
   *
   * @param ChangeServiceGatewayCompartmentRequest
   * @return ChangeServiceGatewayCompartmentResponse
   * @throws OciError when an error occurs
   */
  public async changeServiceGatewayCompartment(
    changeServiceGatewayCompartmentRequest: requests.ChangeServiceGatewayCompartmentRequest
  ): Promise<responses.ChangeServiceGatewayCompartmentResponse> {
    const pathParams = {
      "{serviceGatewayId}": changeServiceGatewayCompartmentRequest.serviceGatewayId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": changeServiceGatewayCompartmentRequest.opcRequestId,
      "opc-retry-token": changeServiceGatewayCompartmentRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/serviceGateways/{serviceGatewayId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeServiceGatewayCompartmentRequest.changeServiceGatewayCompartmentDetails,
        "ChangeServiceGatewayCompartmentDetails",
        models.ChangeServiceGatewayCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeServiceGatewayCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Moves a subnet into a different compartment within the same tenancy. For information
   * about moving resources between compartments, see
   * [Moving Resources to a Different Compartment](https://docs.cloud.oracle.com/iaas/Content/Identity/Tasks/managingcompartments.htm#moveRes).
   *
   * @param ChangeSubnetCompartmentRequest
   * @return ChangeSubnetCompartmentResponse
   * @throws OciError when an error occurs
   */
  public async changeSubnetCompartment(
    changeSubnetCompartmentRequest: requests.ChangeSubnetCompartmentRequest
  ): Promise<responses.ChangeSubnetCompartmentResponse> {
    const pathParams = {
      "{subnetId}": changeSubnetCompartmentRequest.subnetId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": changeSubnetCompartmentRequest.opcRequestId,
      "opc-retry-token": changeSubnetCompartmentRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/subnets/{subnetId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeSubnetCompartmentRequest.changeSubnetCompartmentDetails,
        "ChangeSubnetCompartmentDetails",
        models.ChangeSubnetCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeSubnetCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Moves a VCN into a different compartment within the same tenancy. For information
   * about moving resources between compartments, see
   * [Moving Resources to a Different Compartment](https://docs.cloud.oracle.com/iaas/Content/Identity/Tasks/managingcompartments.htm#moveRes).
   *
   * @param ChangeVcnCompartmentRequest
   * @return ChangeVcnCompartmentResponse
   * @throws OciError when an error occurs
   */
  public async changeVcnCompartment(
    changeVcnCompartmentRequest: requests.ChangeVcnCompartmentRequest
  ): Promise<responses.ChangeVcnCompartmentResponse> {
    const pathParams = {
      "{vcnId}": changeVcnCompartmentRequest.vcnId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": changeVcnCompartmentRequest.opcRequestId,
      "opc-retry-token": changeVcnCompartmentRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/vcns/{vcnId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeVcnCompartmentRequest.changeVcnCompartmentDetails,
        "ChangeVcnCompartmentDetails",
        models.ChangeVcnCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeVcnCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Moves a virtual circuit into a different compartment within the same tenancy. For information
   * about moving resources between compartments, see
   * [Moving Resources to a Different Compartment](https://docs.cloud.oracle.com/iaas/Content/Identity/Tasks/managingcompartments.htm#moveRes).
   *
   * @param ChangeVirtualCircuitCompartmentRequest
   * @return ChangeVirtualCircuitCompartmentResponse
   * @throws OciError when an error occurs
   */
  public async changeVirtualCircuitCompartment(
    changeVirtualCircuitCompartmentRequest: requests.ChangeVirtualCircuitCompartmentRequest
  ): Promise<responses.ChangeVirtualCircuitCompartmentResponse> {
    const pathParams = {
      "{virtualCircuitId}": changeVirtualCircuitCompartmentRequest.virtualCircuitId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": changeVirtualCircuitCompartmentRequest.opcRequestId,
      "opc-retry-token": changeVirtualCircuitCompartmentRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/virtualCircuits/{virtualCircuitId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeVirtualCircuitCompartmentRequest.changeVirtualCircuitCompartmentDetails,
        "ChangeVirtualCircuitCompartmentDetails",
        models.ChangeVirtualCircuitCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeVirtualCircuitCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Connects this local peering connection to another local peering connection in the same region.
   *
   * @param ConnectLocalPeeringConnectionsRequest
   * @return ConnectLocalPeeringConnectionsResponse
   * @throws OciError when an error occurs
   */
  public async connectLocalPeeringConnections(
    connectLocalPeeringConnectionsRequest: requests.ConnectLocalPeeringConnectionsRequest
  ): Promise<responses.ConnectLocalPeeringConnectionsResponse> {
    const pathParams = {
      "{localPeeringConnectionId}": connectLocalPeeringConnectionsRequest.localPeeringConnectionId
    };

    const queryParams = {};

    let headerParams = {
      "x-cross-tenancy-request": connectLocalPeeringConnectionsRequest.xCrossTenancyRequest
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/localPeeringConnections/{localPeeringConnectionId}/actions/connect",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        connectLocalPeeringConnectionsRequest.connectLocalPeeringConnectionsDetails,
        "ConnectLocalPeeringConnectionsDetails",
        models.ConnectLocalPeeringConnectionsDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ConnectLocalPeeringConnectionsResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Connects this local peering gateway (LPG) to another one in the same region.
* <p>
This operation must be called by the VCN administrator who is designated as
* the *requestor* in the peering relationship. The *acceptor* must implement
* an Identity and Access Management (IAM) policy that gives the requestor permission
* to connect to LPGs in the acceptor's compartment. Without that permission, this
* operation will fail. For more information, see
* [VCN Peering](https://docs.cloud.oracle.com/Content/Network/Tasks/VCNpeering.htm).
* 
     * @param ConnectLocalPeeringGatewaysRequest
     * @return ConnectLocalPeeringGatewaysResponse
     * @throws OciError when an error occurs
     */
  public async connectLocalPeeringGateways(
    connectLocalPeeringGatewaysRequest: requests.ConnectLocalPeeringGatewaysRequest
  ): Promise<responses.ConnectLocalPeeringGatewaysResponse> {
    const pathParams = {
      "{localPeeringGatewayId}": connectLocalPeeringGatewaysRequest.localPeeringGatewayId
    };

    const queryParams = {};

    let headerParams = {
      "x-cross-tenancy-request": connectLocalPeeringGatewaysRequest.xCrossTenancyRequest
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/localPeeringGateways/{localPeeringGatewayId}/actions/connect",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        connectLocalPeeringGatewaysRequest.connectLocalPeeringGatewaysDetails,
        "ConnectLocalPeeringGatewaysDetails",
        models.ConnectLocalPeeringGatewaysDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ConnectLocalPeeringGatewaysResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Connects this RPC to another one in a different region.
* <p>
This operation must be called by the VCN administrator who is designated as
* the *requestor* in the peering relationship. The *acceptor* must implement
* an Identity and Access Management (IAM) policy that gives the requestor permission
* to connect to RPCs in the acceptor's compartment. Without that permission, this
* operation will fail. For more information, see
* [VCN Peering](https://docs.cloud.oracle.com/Content/Network/Tasks/VCNpeering.htm).
* 
     * @param ConnectRemotePeeringConnectionsRequest
     * @return ConnectRemotePeeringConnectionsResponse
     * @throws OciError when an error occurs
     */
  public async connectRemotePeeringConnections(
    connectRemotePeeringConnectionsRequest: requests.ConnectRemotePeeringConnectionsRequest
  ): Promise<responses.ConnectRemotePeeringConnectionsResponse> {
    const pathParams = {
      "{remotePeeringConnectionId}":
        connectRemotePeeringConnectionsRequest.remotePeeringConnectionId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/remotePeeringConnections/{remotePeeringConnectionId}/actions/connect",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        connectRemotePeeringConnectionsRequest.connectRemotePeeringConnectionsDetails,
        "ConnectRemotePeeringConnectionsDetails",
        models.ConnectRemotePeeringConnectionsDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ConnectRemotePeeringConnectionsResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Creates a new virtual customer-premises equipment (CPE) object in the specified compartment. For
* more information, see [IPSec VPNs](https://docs.cloud.oracle.com/Content/Network/Tasks/managingIPsec.htm).
* <p>
For the purposes of access control, you must provide the OCID of the compartment where you want
* the CPE to reside. Notice that the CPE doesn't have to be in the same compartment as the IPSec
* connection or other Networking Service components. If you're not sure which compartment to
* use, put the CPE in the same compartment as the DRG. For more information about
* compartments and access control, see [Overview of the IAM Service](https://docs.cloud.oracle.com/Content/Identity/Concepts/overview.htm).
* For information about OCIDs, see [Resource Identifiers](https://docs.cloud.oracle.com/Content/General/Concepts/identifiers.htm).
* <p>
You must provide the public IP address of your on-premises router. See
* [Configuring Your On-Premises Router for an IPSec VPN](https://docs.cloud.oracle.com/Content/Network/Tasks/configuringCPE.htm).
* <p>
You may optionally specify a *display name* for the CPE, otherwise a default is provided. It does not have to
* be unique, and you can change it. Avoid entering confidential information.
* 
     * @param CreateCpeRequest
     * @return CreateCpeResponse
     * @throws OciError when an error occurs
     */
  public async createCpe(
    createCpeRequest: requests.CreateCpeRequest
  ): Promise<responses.CreateCpeResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createCpeRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/cpes",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createCpeRequest.createCpeDetails,
        "CreateCpeDetails",
        models.CreateCpeDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateCpeResponse>{},
        body: await response.json(),
        bodyKey: "cpe",
        bodyModel: "model.Cpe",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Creates a new cross-connect. Oracle recommends you create each cross-connect in a
* {@link CrossConnectGroup} so you can use link aggregation
* with the connection.
* <p>
After creating the `CrossConnect` object, you need to go the FastConnect location
* and request to have the physical cable installed. For more information, see
* [FastConnect Overview](https://docs.cloud.oracle.com/Content/Network/Concepts/fastconnect.htm).
* <p>
For the purposes of access control, you must provide the OCID of the
* compartment where you want the cross-connect to reside. If you're
* not sure which compartment to use, put the cross-connect in the
* same compartment with your VCN. For more information about
* compartments and access control, see
* [Overview of the IAM Service](https://docs.cloud.oracle.com/Content/Identity/Concepts/overview.htm).
* For information about OCIDs, see
* [Resource Identifiers](https://docs.cloud.oracle.com/Content/General/Concepts/identifiers.htm).
* <p>
You may optionally specify a *display name* for the cross-connect.
* It does not have to be unique, and you can change it. Avoid entering confidential information.
* 
     * @param CreateCrossConnectRequest
     * @return CreateCrossConnectResponse
     * @throws OciError when an error occurs
     */
  public async createCrossConnect(
    createCrossConnectRequest: requests.CreateCrossConnectRequest
  ): Promise<responses.CreateCrossConnectResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createCrossConnectRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/crossConnects",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createCrossConnectRequest.createCrossConnectDetails,
        "CreateCrossConnectDetails",
        models.CreateCrossConnectDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateCrossConnectResponse>{},
        body: await response.json(),
        bodyKey: "crossConnect",
        bodyModel: "model.CrossConnect",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Creates a new cross-connect group to use with Oracle Cloud Infrastructure
* FastConnect. For more information, see
* [FastConnect Overview](https://docs.cloud.oracle.com/Content/Network/Concepts/fastconnect.htm).
* <p>
For the purposes of access control, you must provide the OCID of the
* compartment where you want the cross-connect group to reside. If you're
* not sure which compartment to use, put the cross-connect group in the
* same compartment with your VCN. For more information about
* compartments and access control, see
* [Overview of the IAM Service](https://docs.cloud.oracle.com/Content/Identity/Concepts/overview.htm).
* For information about OCIDs, see
* [Resource Identifiers](https://docs.cloud.oracle.com/Content/General/Concepts/identifiers.htm).
* <p>
You may optionally specify a *display name* for the cross-connect group.
* It does not have to be unique, and you can change it. Avoid entering confidential information.
* 
     * @param CreateCrossConnectGroupRequest
     * @return CreateCrossConnectGroupResponse
     * @throws OciError when an error occurs
     */
  public async createCrossConnectGroup(
    createCrossConnectGroupRequest: requests.CreateCrossConnectGroupRequest
  ): Promise<responses.CreateCrossConnectGroupResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createCrossConnectGroupRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/crossConnectGroups",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createCrossConnectGroupRequest.createCrossConnectGroupDetails,
        "CreateCrossConnectGroupDetails",
        models.CreateCrossConnectGroupDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateCrossConnectGroupResponse>{},
        body: await response.json(),
        bodyKey: "crossConnectGroup",
        bodyModel: "model.CrossConnectGroup",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Creates a new set of DHCP options for the specified VCN. For more information, see
* {@link DhcpOptions}.
* <p>
For the purposes of access control, you must provide the OCID of the compartment where you want the set of
* DHCP options to reside. Notice that the set of options doesn't have to be in the same compartment as the VCN,
* subnets, or other Networking Service components. If you're not sure which compartment to use, put the set
* of DHCP options in the same compartment as the VCN. For more information about compartments and access control, see
* [Overview of the IAM Service](https://docs.cloud.oracle.com/Content/Identity/Concepts/overview.htm). For information about OCIDs, see
* [Resource Identifiers](https://docs.cloud.oracle.com/Content/General/Concepts/identifiers.htm).
* <p>
You may optionally specify a *display name* for the set of DHCP options, otherwise a default is provided.
* It does not have to be unique, and you can change it. Avoid entering confidential information.
* 
     * @param CreateDhcpOptionsRequest
     * @return CreateDhcpOptionsResponse
     * @throws OciError when an error occurs
     */
  public async createDhcpOptions(
    createDhcpOptionsRequest: requests.CreateDhcpOptionsRequest
  ): Promise<responses.CreateDhcpOptionsResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createDhcpOptionsRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/dhcps",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createDhcpOptionsRequest.createDhcpDetails,
        "CreateDhcpDetails",
        models.CreateDhcpDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateDhcpOptionsResponse>{},
        body: await response.json(),
        bodyKey: "dhcpOptions",
        bodyModel: "model.DhcpOptions",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Creates a new dynamic routing gateway (DRG) in the specified compartment. For more information,
* see [Dynamic Routing Gateways (DRGs)](https://docs.cloud.oracle.com/Content/Network/Tasks/managingDRGs.htm).
* <p>
For the purposes of access control, you must provide the OCID of the compartment where you want
* the DRG to reside. Notice that the DRG doesn't have to be in the same compartment as the VCN,
* the DRG attachment, or other Networking Service components. If you're not sure which compartment
* to use, put the DRG in the same compartment as the VCN. For more information about compartments
* and access control, see [Overview of the IAM Service](https://docs.cloud.oracle.com/Content/Identity/Concepts/overview.htm).
* For information about OCIDs, see [Resource Identifiers](https://docs.cloud.oracle.com/Content/General/Concepts/identifiers.htm).
* <p>
You may optionally specify a *display name* for the DRG, otherwise a default is provided.
* It does not have to be unique, and you can change it. Avoid entering confidential information.
* 
     * @param CreateDrgRequest
     * @return CreateDrgResponse
     * @throws OciError when an error occurs
     */
  public async createDrg(
    createDrgRequest: requests.CreateDrgRequest
  ): Promise<responses.CreateDrgResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createDrgRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/drgs",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createDrgRequest.createDrgDetails,
        "CreateDrgDetails",
        models.CreateDrgDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateDrgResponse>{},
        body: await response.json(),
        bodyKey: "drg",
        bodyModel: "model.Drg",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Attaches the specified DRG to the specified VCN. A VCN can be attached to only one DRG at a time,
* and vice versa. The response includes a `DrgAttachment` object with its own OCID. For more
* information about DRGs, see
* [Dynamic Routing Gateways (DRGs)](https://docs.cloud.oracle.com/Content/Network/Tasks/managingDRGs.htm).
* <p>
You may optionally specify a *display name* for the attachment, otherwise a default is provided.
* It does not have to be unique, and you can change it. Avoid entering confidential information.
* <p>
For the purposes of access control, the DRG attachment is automatically placed into the same compartment
* as the VCN. For more information about compartments and access control, see
* [Overview of the IAM Service](https://docs.cloud.oracle.com/Content/Identity/Concepts/overview.htm).
* 
     * @param CreateDrgAttachmentRequest
     * @return CreateDrgAttachmentResponse
     * @throws OciError when an error occurs
     */
  public async createDrgAttachment(
    createDrgAttachmentRequest: requests.CreateDrgAttachmentRequest
  ): Promise<responses.CreateDrgAttachmentResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createDrgAttachmentRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/drgAttachments",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createDrgAttachmentRequest.createDrgAttachmentDetails,
        "CreateDrgAttachmentDetails",
        models.CreateDrgAttachmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateDrgAttachmentResponse>{},
        body: await response.json(),
        bodyKey: "drgAttachment",
        bodyModel: "model.DrgAttachment",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new flow log configuration in the specified compartment.
   *
   * @param CreateFlowLogConfigRequest
   * @return CreateFlowLogConfigResponse
   * @throws OciError when an error occurs
   */
  public async createFlowLogConfig(
    createFlowLogConfigRequest: requests.CreateFlowLogConfigRequest
  ): Promise<responses.CreateFlowLogConfigResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createFlowLogConfigRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/flowLogConfigs",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createFlowLogConfigRequest.createFlowLogConfigDetails,
        "CreateFlowLogConfigDetails",
        models.CreateFlowLogConfigDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateFlowLogConfigResponse>{},
        body: await response.json(),
        bodyKey: "flowLogConfig",
        bodyModel: "model.FlowLogConfig",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Attaches a flow log configuration to a resource such as a subnet. The result is a
   * {@link FlowLogConfigAttachment}. The process of
   * attaching enables flow logs for the resource. A resource can have only a single
   * flow log configuration attached to it.
   *
   * @param CreateFlowLogConfigAttachmentRequest
   * @return CreateFlowLogConfigAttachmentResponse
   * @throws OciError when an error occurs
   */
  public async createFlowLogConfigAttachment(
    createFlowLogConfigAttachmentRequest: requests.CreateFlowLogConfigAttachmentRequest
  ): Promise<responses.CreateFlowLogConfigAttachmentResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createFlowLogConfigAttachmentRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/flowLogConfigAttachments",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createFlowLogConfigAttachmentRequest.createFlowLogConfigAttachmentDetails,
        "CreateFlowLogConfigAttachmentDetails",
        models.CreateFlowLogConfigAttachmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateFlowLogConfigAttachmentResponse>{},
        body: await response.json(),
        bodyKey: "flowLogConfigAttachment",
        bodyModel: "model.FlowLogConfigAttachment",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Creates a new IPSec connection between the specified DRG and CPE. For more information, see
* [IPSec VPNs](https://docs.cloud.oracle.com/Content/Network/Tasks/managingIPsec.htm).
* <p>
If you configure at least one tunnel to use static routing, then in the request you must provide
* at least one valid static route (you're allowed a maximum of 10). For example: 10.0.0.0/16.
* If you configure both tunnels to use BGP dynamic routing, you can provide an empty list for
* the static routes. For more information, see the important note in
* {@link IPSecConnection}.
* <p>
For the purposes of access control, you must provide the OCID of the compartment where you want the
* IPSec connection to reside. Notice that the IPSec connection doesn't have to be in the same compartment
* as the DRG, CPE, or other Networking Service components. If you're not sure which compartment to
* use, put the IPSec connection in the same compartment as the DRG. For more information about
* compartments and access control, see
* [Overview of the IAM Service](https://docs.cloud.oracle.com/Content/Identity/Concepts/overview.htm).
* For information about OCIDs, see [Resource Identifiers](https://docs.cloud.oracle.com/Content/General/Concepts/identifiers.htm).
* <p>
You may optionally specify a *display name* for the IPSec connection, otherwise a default is provided.
* It does not have to be unique, and you can change it. Avoid entering confidential information.
* <p>
After creating the IPSec connection, you need to configure your on-premises router
* with tunnel-specific information. For tunnel status and the required configuration information, see:
* <p>
  * {@link IPSecConnectionTunnel}
*   * {@link IPSecConnectionTunnelSharedSecret}
* <p>
For each tunnel, you need the IP address of Oracle's VPN headend and the shared secret
* (that is, the pre-shared key). For more information, see
* [Configuring Your On-Premises Router for an IPSec VPN](https://docs.cloud.oracle.com/Content/Network/Tasks/configuringCPE.htm).
* 
     * @param CreateIPSecConnectionRequest
     * @return CreateIPSecConnectionResponse
     * @throws OciError when an error occurs
     */
  public async createIPSecConnection(
    createIPSecConnectionRequest: requests.CreateIPSecConnectionRequest
  ): Promise<responses.CreateIPSecConnectionResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createIPSecConnectionRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/ipsecConnections",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createIPSecConnectionRequest.createIPSecConnectionDetails,
        "CreateIPSecConnectionDetails",
        models.CreateIPSecConnectionDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateIPSecConnectionResponse>{},
        body: await response.json(),
        bodyKey: "iPSecConnection",
        bodyModel: "model.IPSecConnection",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Creates a new internet gateway for the specified VCN. For more information, see
* [Access to the Internet](https://docs.cloud.oracle.com/Content/Network/Tasks/managingIGs.htm).
* <p>
For the purposes of access control, you must provide the OCID of the compartment where you want the Internet
* Gateway to reside. Notice that the internet gateway doesn't have to be in the same compartment as the VCN or
* other Networking Service components. If you're not sure which compartment to use, put the Internet
* Gateway in the same compartment with the VCN. For more information about compartments and access control, see
* [Overview of the IAM Service](https://docs.cloud.oracle.com/Content/Identity/Concepts/overview.htm). For information about OCIDs, see
* [Resource Identifiers](https://docs.cloud.oracle.com/Content/General/Concepts/identifiers.htm).
* <p>
You may optionally specify a *display name* for the internet gateway, otherwise a default is provided. It
* does not have to be unique, and you can change it. Avoid entering confidential information.
* <p>
For traffic to flow between a subnet and an internet gateway, you must create a route rule accordingly in
* the subnet's route table (for example, 0.0.0.0/0 > internet gateway). See
* {@link #updateRouteTable(UpdateRouteTableRequest) updateRouteTable}.
* <p>
You must specify whether the internet gateway is enabled when you create it. If it's disabled, that means no
* traffic will flow to/from the internet even if there's a route rule that enables that traffic. You can later
* use {@link #updateInternetGateway(UpdateInternetGatewayRequest) updateInternetGateway} to easily disable/enable
* the gateway without changing the route rule.
* 
     * @param CreateInternetGatewayRequest
     * @return CreateInternetGatewayResponse
     * @throws OciError when an error occurs
     */
  public async createInternetGateway(
    createInternetGatewayRequest: requests.CreateInternetGatewayRequest
  ): Promise<responses.CreateInternetGatewayResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createInternetGatewayRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/internetGateways",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createInternetGatewayRequest.createInternetGatewayDetails,
        "CreateInternetGatewayDetails",
        models.CreateInternetGatewayDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateInternetGatewayResponse>{},
        body: await response.json(),
        bodyKey: "internetGateway",
        bodyModel: "model.InternetGateway",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates an IPv6 for the specified VNIC.
   *
   * @param CreateIpv6Request
   * @return CreateIpv6Response
   * @throws OciError when an error occurs
   */
  public async createIpv6(
    createIpv6Request: requests.CreateIpv6Request
  ): Promise<responses.CreateIpv6Response> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-request-id": createIpv6Request.opcRequestId,
      "opc-retry-token": createIpv6Request.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/ipv6",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createIpv6Request.createIpv6Details,
        "CreateIpv6Details",
        models.CreateIpv6Details.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateIpv6Response>{},
        body: await response.json(),
        bodyKey: "ipv6",
        bodyModel: "model.Ipv6",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new local peering connection for the specified VCN.
   *
   * @param CreateLocalPeeringConnectionRequest
   * @return CreateLocalPeeringConnectionResponse
   * @throws OciError when an error occurs
   */
  public async createLocalPeeringConnection(
    createLocalPeeringConnectionRequest: requests.CreateLocalPeeringConnectionRequest
  ): Promise<responses.CreateLocalPeeringConnectionResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createLocalPeeringConnectionRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/localPeeringConnections",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createLocalPeeringConnectionRequest.createLocalPeeringConnectionDetails,
        "CreateLocalPeeringConnectionDetails",
        models.CreateLocalPeeringConnectionDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateLocalPeeringConnectionResponse>{},
        body: await response.json(),
        bodyKey: "localPeeringConnection",
        bodyModel: "model.LocalPeeringConnection",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new local peering gateway (LPG) for the specified VCN.
   *
   * @param CreateLocalPeeringGatewayRequest
   * @return CreateLocalPeeringGatewayResponse
   * @throws OciError when an error occurs
   */
  public async createLocalPeeringGateway(
    createLocalPeeringGatewayRequest: requests.CreateLocalPeeringGatewayRequest
  ): Promise<responses.CreateLocalPeeringGatewayResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createLocalPeeringGatewayRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/localPeeringGateways",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createLocalPeeringGatewayRequest.createLocalPeeringGatewayDetails,
        "CreateLocalPeeringGatewayDetails",
        models.CreateLocalPeeringGatewayDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateLocalPeeringGatewayResponse>{},
        body: await response.json(),
        bodyKey: "localPeeringGateway",
        bodyModel: "model.LocalPeeringGateway",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new NAT gateway for the specified VCN. You must also set up a route rule with the
   * NAT gateway as the rule's target. See {@link RouteTable}.
   *
   * @param CreateNatGatewayRequest
   * @return CreateNatGatewayResponse
   * @throws OciError when an error occurs
   */
  public async createNatGateway(
    createNatGatewayRequest: requests.CreateNatGatewayRequest
  ): Promise<responses.CreateNatGatewayResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createNatGatewayRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/natGateways",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createNatGatewayRequest.createNatGatewayDetails,
        "CreateNatGatewayDetails",
        models.CreateNatGatewayDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateNatGatewayResponse>{},
        body: await response.json(),
        bodyKey: "natGateway",
        bodyModel: "model.NatGateway",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new network security group for the specified VCN.
   *
   * @param CreateNetworkSecurityGroupRequest
   * @return CreateNetworkSecurityGroupResponse
   * @throws OciError when an error occurs
   */
  public async createNetworkSecurityGroup(
    createNetworkSecurityGroupRequest: requests.CreateNetworkSecurityGroupRequest
  ): Promise<responses.CreateNetworkSecurityGroupResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createNetworkSecurityGroupRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/networkSecurityGroups",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createNetworkSecurityGroupRequest.createNetworkSecurityGroupDetails,
        "CreateNetworkSecurityGroupDetails",
        models.CreateNetworkSecurityGroupDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateNetworkSecurityGroupResponse>{},
        body: await response.json(),
        bodyKey: "networkSecurityGroup",
        bodyModel: "model.NetworkSecurityGroup",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a secondary private IP for the specified VNIC.
   * For more information about secondary private IPs, see
   * [IP Addresses](https://docs.cloud.oracle.com/Content/Network/Tasks/managingIPaddresses.htm).
   *
   * @param CreatePrivateIpRequest
   * @return CreatePrivateIpResponse
   * @throws OciError when an error occurs
   */
  public async createPrivateIp(
    createPrivateIpRequest: requests.CreatePrivateIpRequest
  ): Promise<responses.CreatePrivateIpResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createPrivateIpRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/privateIps",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createPrivateIpRequest.createPrivateIpDetails,
        "CreatePrivateIpDetails",
        models.CreatePrivateIpDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreatePrivateIpResponse>{},
        body: await response.json(),
        bodyKey: "privateIp",
        bodyModel: "model.PrivateIp",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Creates a public IP. Use the `lifetime` property to specify whether it's an ephemeral or
* reserved public IP. For information about limits on how many you can create, see
* [Public IP Addresses](https://docs.cloud.oracle.com/Content/Network/Tasks/managingpublicIPs.htm).
* <p>
* **For an ephemeral public IP assigned to a private IP:** You must also specify a `privateIpId`
* with the OCID of the primary private IP you want to assign the public IP to. The public IP is
* created in the same availability domain as the private IP. An ephemeral public IP must always be
* assigned to a private IP, and only to the *primary* private IP on a VNIC, not a secondary
* private IP. Exception: If you create a {@link NatGateway}, Oracle
* automatically assigns the NAT gateway a regional ephemeral public IP that you cannot remove.
* <p>
* **For a reserved public IP:** You may also optionally assign the public IP to a private
* IP by specifying `privateIpId`. Or you can later assign the public IP with
* {@link #updatePublicIp(UpdatePublicIpRequest) updatePublicIp}.
* <p>
**Note:** When assigning a public IP to a private IP, the private IP must not already have
* a public IP with `lifecycleState` = ASSIGNING or ASSIGNED. If it does, an error is returned.
* <p>
Also, for reserved public IPs, the optional assignment part of this operation is
* asynchronous. Poll the public IP's `lifecycleState` to determine if the assignment
* succeeded.
* 
     * @param CreatePublicIpRequest
     * @return CreatePublicIpResponse
     * @throws OciError when an error occurs
     */
  public async createPublicIp(
    createPublicIpRequest: requests.CreatePublicIpRequest
  ): Promise<responses.CreatePublicIpResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createPublicIpRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/publicIps",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createPublicIpRequest.createPublicIpDetails,
        "CreatePublicIpDetails",
        models.CreatePublicIpDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreatePublicIpResponse>{},
        body: await response.json(),
        bodyKey: "publicIp",
        bodyModel: "model.PublicIp",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new remote peering connection (RPC) for the specified DRG.
   *
   * @param CreateRemotePeeringConnectionRequest
   * @return CreateRemotePeeringConnectionResponse
   * @throws OciError when an error occurs
   */
  public async createRemotePeeringConnection(
    createRemotePeeringConnectionRequest: requests.CreateRemotePeeringConnectionRequest
  ): Promise<responses.CreateRemotePeeringConnectionResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createRemotePeeringConnectionRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/remotePeeringConnections",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createRemotePeeringConnectionRequest.createRemotePeeringConnectionDetails,
        "CreateRemotePeeringConnectionDetails",
        models.CreateRemotePeeringConnectionDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateRemotePeeringConnectionResponse>{},
        body: await response.json(),
        bodyKey: "remotePeeringConnection",
        bodyModel: "model.RemotePeeringConnection",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Creates a new route table for the specified VCN. In the request you must also include at least one route
* rule for the new route table. For information on the number of rules you can have in a route table, see
* [Service Limits](https://docs.cloud.oracle.com/Content/General/Concepts/servicelimits.htm). For general information about route
* tables in your VCN and the types of targets you can use in route rules,
* see [Route Tables](https://docs.cloud.oracle.com/Content/Network/Tasks/managingroutetables.htm).
* <p>
For the purposes of access control, you must provide the OCID of the compartment where you want the route
* table to reside. Notice that the route table doesn't have to be in the same compartment as the VCN, subnets,
* or other Networking Service components. If you're not sure which compartment to use, put the route
* table in the same compartment as the VCN. For more information about compartments and access control, see
* [Overview of the IAM Service](https://docs.cloud.oracle.com/Content/Identity/Concepts/overview.htm). For information about OCIDs, see
* [Resource Identifiers](https://docs.cloud.oracle.com/Content/General/Concepts/identifiers.htm).
* <p>
You may optionally specify a *display name* for the route table, otherwise a default is provided.
* It does not have to be unique, and you can change it. Avoid entering confidential information.
* 
     * @param CreateRouteTableRequest
     * @return CreateRouteTableResponse
     * @throws OciError when an error occurs
     */
  public async createRouteTable(
    createRouteTableRequest: requests.CreateRouteTableRequest
  ): Promise<responses.CreateRouteTableResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createRouteTableRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/routeTables",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createRouteTableRequest.createRouteTableDetails,
        "CreateRouteTableDetails",
        models.CreateRouteTableDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateRouteTableResponse>{},
        body: await response.json(),
        bodyKey: "routeTable",
        bodyModel: "model.RouteTable",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Creates a new security list for the specified VCN. For more information
* about security lists, see [Security Lists](https://docs.cloud.oracle.com/Content/Network/Concepts/securitylists.htm).
* For information on the number of rules you can have in a security list, see
* [Service Limits](https://docs.cloud.oracle.com/Content/General/Concepts/servicelimits.htm).
* <p>
For the purposes of access control, you must provide the OCID of the compartment where you want the security
* list to reside. Notice that the security list doesn't have to be in the same compartment as the VCN, subnets,
* or other Networking Service components. If you're not sure which compartment to use, put the security
* list in the same compartment as the VCN. For more information about compartments and access control, see
* [Overview of the IAM Service](https://docs.cloud.oracle.com/Content/Identity/Concepts/overview.htm). For information about OCIDs, see
* [Resource Identifiers](https://docs.cloud.oracle.com/Content/General/Concepts/identifiers.htm).
* <p>
You may optionally specify a *display name* for the security list, otherwise a default is provided.
* It does not have to be unique, and you can change it. Avoid entering confidential information.
* 
     * @param CreateSecurityListRequest
     * @return CreateSecurityListResponse
     * @throws OciError when an error occurs
     */
  public async createSecurityList(
    createSecurityListRequest: requests.CreateSecurityListRequest
  ): Promise<responses.CreateSecurityListResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createSecurityListRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/securityLists",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createSecurityListRequest.createSecurityListDetails,
        "CreateSecurityListDetails",
        models.CreateSecurityListDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateSecurityListResponse>{},
        body: await response.json(),
        bodyKey: "securityList",
        bodyModel: "model.SecurityList",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Creates a new service gateway in the specified compartment.
* <p>
For the purposes of access control, you must provide the OCID of the compartment where you want
* the service gateway to reside. For more information about compartments and access control, see
* [Overview of the IAM Service](https://docs.cloud.oracle.com/Content/Identity/Concepts/overview.htm).
* For information about OCIDs, see [Resource Identifiers](https://docs.cloud.oracle.com/Content/General/Concepts/identifiers.htm).
* <p>
You may optionally specify a *display name* for the service gateway, otherwise a default is provided.
* It does not have to be unique, and you can change it. Avoid entering confidential information.
* 
     * @param CreateServiceGatewayRequest
     * @return CreateServiceGatewayResponse
     * @throws OciError when an error occurs
     */
  public async createServiceGateway(
    createServiceGatewayRequest: requests.CreateServiceGatewayRequest
  ): Promise<responses.CreateServiceGatewayResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createServiceGatewayRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/serviceGateways",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createServiceGatewayRequest.createServiceGatewayDetails,
        "CreateServiceGatewayDetails",
        models.CreateServiceGatewayDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateServiceGatewayResponse>{},
        body: await response.json(),
        bodyKey: "serviceGateway",
        bodyModel: "model.ServiceGateway",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Creates a new subnet in the specified VCN. You can't change the size of the subnet after creation,
* so it's important to think about the size of subnets you need before creating them.
* For more information, see [VCNs and Subnets](https://docs.cloud.oracle.com/Content/Network/Tasks/managingVCNs.htm).
* For information on the number of subnets you can have in a VCN, see
* [Service Limits](https://docs.cloud.oracle.com/Content/General/Concepts/servicelimits.htm).
* <p>
For the purposes of access control, you must provide the OCID of the compartment where you want the subnet
* to reside. Notice that the subnet doesn't have to be in the same compartment as the VCN, route tables, or
* other Networking Service components. If you're not sure which compartment to use, put the subnet in
* the same compartment as the VCN. For more information about compartments and access control, see
* [Overview of the IAM Service](https://docs.cloud.oracle.com/Content/Identity/Concepts/overview.htm). For information about OCIDs,
* see [Resource Identifiers](https://docs.cloud.oracle.com/Content/General/Concepts/identifiers.htm).
* <p>
You may optionally associate a route table with the subnet. If you don't, the subnet will use the
* VCN's default route table. For more information about route tables, see
* [Route Tables](https://docs.cloud.oracle.com/Content/Network/Tasks/managingroutetables.htm).
* <p>
You may optionally associate a security list with the subnet. If you don't, the subnet will use the
* VCN's default security list. For more information about security lists, see
* [Security Lists](https://docs.cloud.oracle.com/Content/Network/Concepts/securitylists.htm).
* <p>
You may optionally associate a set of DHCP options with the subnet. If you don't, the subnet will use the
* VCN's default set. For more information about DHCP options, see
* [DHCP Options](https://docs.cloud.oracle.com/Content/Network/Tasks/managingDHCP.htm).
* <p>
You may optionally specify a *display name* for the subnet, otherwise a default is provided.
* It does not have to be unique, and you can change it. Avoid entering confidential information.
* <p>
You can also add a DNS label for the subnet, which is required if you want the Internet and
* VCN Resolver to resolve hostnames for instances in the subnet. For more information, see
* [DNS in Your Virtual Cloud Network](https://docs.cloud.oracle.com/Content/Network/Concepts/dns.htm).
* 
     * @param CreateSubnetRequest
     * @return CreateSubnetResponse
     * @throws OciError when an error occurs
     */
  public async createSubnet(
    createSubnetRequest: requests.CreateSubnetRequest
  ): Promise<responses.CreateSubnetResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createSubnetRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/subnets",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createSubnetRequest.createSubnetDetails,
        "CreateSubnetDetails",
        models.CreateSubnetDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateSubnetResponse>{},
        body: await response.json(),
        bodyKey: "subnet",
        bodyModel: "model.Subnet",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Creates a new virtual cloud network (VCN). For more information, see
* [VCNs and Subnets](https://docs.cloud.oracle.com/Content/Network/Tasks/managingVCNs.htm).
* <p>
For the VCN you must specify a single, contiguous IPv4 CIDR block. Oracle recommends using one of the
* private IP address ranges specified in [RFC 1918](https://tools.ietf.org/html/rfc1918) (10.0.0.0/8,
* 172.16/12, and 192.168/16). Example: 172.16.0.0/16. The CIDR block can range from /16 to /30, and it
* must not overlap with your on-premises network. You can't change the size of the VCN after creation.
* <p>
For the purposes of access control, you must provide the OCID of the compartment where you want the VCN to
* reside. Consult an Oracle Cloud Infrastructure administrator in your organization if you're not sure which
* compartment to use. Notice that the VCN doesn't have to be in the same compartment as the subnets or other
* Networking Service components. For more information about compartments and access control, see
* [Overview of the IAM Service](https://docs.cloud.oracle.com/Content/Identity/Concepts/overview.htm). For information about OCIDs, see
* [Resource Identifiers](https://docs.cloud.oracle.com/Content/General/Concepts/identifiers.htm).
* <p>
You may optionally specify a *display name* for the VCN, otherwise a default is provided. It does not have to
* be unique, and you can change it. Avoid entering confidential information.
* <p>
You can also add a DNS label for the VCN, which is required if you want the instances to use the
* Interent and VCN Resolver option for DNS in the VCN. For more information, see
* [DNS in Your Virtual Cloud Network](https://docs.cloud.oracle.com/Content/Network/Concepts/dns.htm).
* <p>
The VCN automatically comes with a default route table, default security list, and default set of DHCP options.
* The OCID for each is returned in the response. You can't delete these default objects, but you can change their
* contents (that is, change the route rules, security list rules, and so on).
* <p>
The VCN and subnets you create are not accessible until you attach an internet gateway or set up an IPSec VPN
* or FastConnect. For more information, see
* [Overview of the Networking Service](https://docs.cloud.oracle.com/Content/Network/Concepts/overview.htm).
* 
     * @param CreateVcnRequest
     * @return CreateVcnResponse
     * @throws OciError when an error occurs
     */
  public async createVcn(
    createVcnRequest: requests.CreateVcnRequest
  ): Promise<responses.CreateVcnResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createVcnRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/vcns",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createVcnRequest.createVcnDetails,
        "CreateVcnDetails",
        models.CreateVcnDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateVcnResponse>{},
        body: await response.json(),
        bodyKey: "vcn",
        bodyModel: "model.Vcn",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Creates a new virtual circuit to use with Oracle Cloud
* Infrastructure FastConnect. For more information, see
* [FastConnect Overview](https://docs.cloud.oracle.com/Content/Network/Concepts/fastconnect.htm).
* <p>
For the purposes of access control, you must provide the OCID of the
* compartment where you want the virtual circuit to reside. If you're
* not sure which compartment to use, put the virtual circuit in the
* same compartment with the DRG it's using. For more information about
* compartments and access control, see
* [Overview of the IAM Service](https://docs.cloud.oracle.com/Content/Identity/Concepts/overview.htm).
* For information about OCIDs, see
* [Resource Identifiers](https://docs.cloud.oracle.com/Content/General/Concepts/identifiers.htm).
* <p>
You may optionally specify a *display name* for the virtual circuit.
* It does not have to be unique, and you can change it. Avoid entering confidential information.
* <p>
**Important:** When creating a virtual circuit, you specify a DRG for
* the traffic to flow through. Make sure you attach the DRG to your
* VCN and confirm the VCN's routing sends traffic to the DRG. Otherwise
* traffic will not flow. For more information, see
* [Route Tables](https://docs.cloud.oracle.com/Content/Network/Tasks/managingroutetables.htm).
* 
     * @param CreateVirtualCircuitRequest
     * @return CreateVirtualCircuitResponse
     * @throws OciError when an error occurs
     */
  public async createVirtualCircuit(
    createVirtualCircuitRequest: requests.CreateVirtualCircuitRequest
  ): Promise<responses.CreateVirtualCircuitResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createVirtualCircuitRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/virtualCircuits",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createVirtualCircuitRequest.createVirtualCircuitDetails,
        "CreateVirtualCircuitDetails",
        models.CreateVirtualCircuitDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateVirtualCircuitResponse>{},
        body: await response.json(),
        bodyKey: "virtualCircuit",
        bodyModel: "model.VirtualCircuit",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Deletes the specified CPE object. The CPE must not be connected to a DRG. This is an asynchronous
   * operation. The CPE's `lifecycleState` will change to TERMINATING temporarily until the CPE is completely
   * removed.
   *
   * @param DeleteCpeRequest
   * @return DeleteCpeResponse
   * @throws OciError when an error occurs
   */
  public async deleteCpe(
    deleteCpeRequest: requests.DeleteCpeRequest
  ): Promise<responses.DeleteCpeResponse> {
    const pathParams = {
      "{cpeId}": deleteCpeRequest.cpeId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteCpeRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/cpes/{cpeId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteCpeResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Deletes the specified cross-connect. It must not be mapped to a
   * {@link VirtualCircuit}.
   *
   * @param DeleteCrossConnectRequest
   * @return DeleteCrossConnectResponse
   * @throws OciError when an error occurs
   */
  public async deleteCrossConnect(
    deleteCrossConnectRequest: requests.DeleteCrossConnectRequest
  ): Promise<responses.DeleteCrossConnectResponse> {
    const pathParams = {
      "{crossConnectId}": deleteCrossConnectRequest.crossConnectId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteCrossConnectRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/crossConnects/{crossConnectId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteCrossConnectResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Deletes the specified cross-connect group. It must not contain any
   * cross-connects, and it cannot be mapped to a
   * {@link VirtualCircuit}.
   *
   * @param DeleteCrossConnectGroupRequest
   * @return DeleteCrossConnectGroupResponse
   * @throws OciError when an error occurs
   */
  public async deleteCrossConnectGroup(
    deleteCrossConnectGroupRequest: requests.DeleteCrossConnectGroupRequest
  ): Promise<responses.DeleteCrossConnectGroupResponse> {
    const pathParams = {
      "{crossConnectGroupId}": deleteCrossConnectGroupRequest.crossConnectGroupId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteCrossConnectGroupRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/crossConnectGroups/{crossConnectGroupId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteCrossConnectGroupResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Deletes the specified set of DHCP options, but only if it's not associated with a subnet. You can't delete a
* VCN's default set of DHCP options.
* <p>
This is an asynchronous operation. The state of the set of options will switch to TERMINATING temporarily
* until the set is completely removed.
* 
     * @param DeleteDhcpOptionsRequest
     * @return DeleteDhcpOptionsResponse
     * @throws OciError when an error occurs
     */
  public async deleteDhcpOptions(
    deleteDhcpOptionsRequest: requests.DeleteDhcpOptionsRequest
  ): Promise<responses.DeleteDhcpOptionsResponse> {
    const pathParams = {
      "{dhcpId}": deleteDhcpOptionsRequest.dhcpId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteDhcpOptionsRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/dhcps/{dhcpId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteDhcpOptionsResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Deletes the specified DRG. The DRG must not be attached to a VCN or be connected to your on-premise
   * network. Also, there must not be a route table that lists the DRG as a target. This is an asynchronous
   * operation. The DRG's `lifecycleState` will change to TERMINATING temporarily until the DRG is completely
   * removed.
   *
   * @param DeleteDrgRequest
   * @return DeleteDrgResponse
   * @throws OciError when an error occurs
   */
  public async deleteDrg(
    deleteDrgRequest: requests.DeleteDrgRequest
  ): Promise<responses.DeleteDrgResponse> {
    const pathParams = {
      "{drgId}": deleteDrgRequest.drgId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteDrgRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/drgs/{drgId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteDrgResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Detaches a DRG from a VCN by deleting the corresponding `DrgAttachment`. This is an asynchronous
   * operation. The attachment's `lifecycleState` will change to DETACHING temporarily until the attachment
   * is completely removed.
   *
   * @param DeleteDrgAttachmentRequest
   * @return DeleteDrgAttachmentResponse
   * @throws OciError when an error occurs
   */
  public async deleteDrgAttachment(
    deleteDrgAttachmentRequest: requests.DeleteDrgAttachmentRequest
  ): Promise<responses.DeleteDrgAttachmentResponse> {
    const pathParams = {
      "{drgAttachmentId}": deleteDrgAttachmentRequest.drgAttachmentId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteDrgAttachmentRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/drgAttachments/{drgAttachmentId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteDrgAttachmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Deletes the specified flow log configuration. It must not be attached to a resource.
   *
   * @param DeleteFlowLogConfigRequest
   * @return DeleteFlowLogConfigResponse
   * @throws OciError when an error occurs
   */
  public async deleteFlowLogConfig(
    deleteFlowLogConfigRequest: requests.DeleteFlowLogConfigRequest
  ): Promise<responses.DeleteFlowLogConfigResponse> {
    const pathParams = {
      "{flowLogConfigId}": deleteFlowLogConfigRequest.flowLogConfigId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteFlowLogConfigRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/flowLogConfigs/{flowLogConfigId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteFlowLogConfigResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Deletes the specified flow log configuration attachment. This effectively disables flow logs
   * for the attached resource.
   *
   * @param DeleteFlowLogConfigAttachmentRequest
   * @return DeleteFlowLogConfigAttachmentResponse
   * @throws OciError when an error occurs
   */
  public async deleteFlowLogConfigAttachment(
    deleteFlowLogConfigAttachmentRequest: requests.DeleteFlowLogConfigAttachmentRequest
  ): Promise<responses.DeleteFlowLogConfigAttachmentResponse> {
    const pathParams = {
      "{flowLogConfigAttachmentId}": deleteFlowLogConfigAttachmentRequest.flowLogConfigAttachmentId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteFlowLogConfigAttachmentRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/flowLogConfigAttachments/{flowLogConfigAttachmentId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteFlowLogConfigAttachmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Deletes the specified IPSec connection. If your goal is to disable the IPSec VPN between your VCN and
* on-premises network, it's easiest to simply detach the DRG but keep all the IPSec VPN components intact.
* If you were to delete all the components and then later need to create an IPSec VPN again, you would
* need to configure your on-premises router again with the new information returned from
* {@link #createIPSecConnection(CreateIPSecConnectionRequest) createIPSecConnection}.
* <p>
This is an asynchronous operation. The connection's `lifecycleState` will change to TERMINATING temporarily
* until the connection is completely removed.
* 
     * @param DeleteIPSecConnectionRequest
     * @return DeleteIPSecConnectionResponse
     * @throws OciError when an error occurs
     */
  public async deleteIPSecConnection(
    deleteIPSecConnectionRequest: requests.DeleteIPSecConnectionRequest
  ): Promise<responses.DeleteIPSecConnectionResponse> {
    const pathParams = {
      "{ipscId}": deleteIPSecConnectionRequest.ipscId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteIPSecConnectionRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/ipsecConnections/{ipscId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteIPSecConnectionResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Deletes the specified internet gateway. The internet gateway does not have to be disabled, but
* there must not be a route table that lists it as a target.
* <p>
This is an asynchronous operation. The gateway's `lifecycleState` will change to TERMINATING temporarily
* until the gateway is completely removed.
* 
     * @param DeleteInternetGatewayRequest
     * @return DeleteInternetGatewayResponse
     * @throws OciError when an error occurs
     */
  public async deleteInternetGateway(
    deleteInternetGatewayRequest: requests.DeleteInternetGatewayRequest
  ): Promise<responses.DeleteInternetGatewayResponse> {
    const pathParams = {
      "{igId}": deleteInternetGatewayRequest.igId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteInternetGatewayRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/internetGateways/{igId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteInternetGatewayResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Unassigns and deletes the specified IPv6. You must specify the object's OCID.
   * The IPv6 address is returned to the subnet's pool of available addresses.
   *
   * @param DeleteIpv6Request
   * @return DeleteIpv6Response
   * @throws OciError when an error occurs
   */
  public async deleteIpv6(
    deleteIpv6Request: requests.DeleteIpv6Request
  ): Promise<responses.DeleteIpv6Response> {
    const pathParams = {
      "{ipv6Id}": deleteIpv6Request.ipv6Id
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteIpv6Request.ifMatch,
      "opc-request-id": deleteIpv6Request.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/ipv6/{ipv6Id}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteIpv6Response>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Deletes the specified local peering connection.
* <p>
This is an asynchronous operation; the local peering connection's `lifecycleState` will change to TERMINATING temporarily
* until the local peering connection is completely removed.
* 
     * @param DeleteLocalPeeringConnectionRequest
     * @return DeleteLocalPeeringConnectionResponse
     * @throws OciError when an error occurs
     */
  public async deleteLocalPeeringConnection(
    deleteLocalPeeringConnectionRequest: requests.DeleteLocalPeeringConnectionRequest
  ): Promise<responses.DeleteLocalPeeringConnectionResponse> {
    const pathParams = {
      "{localPeeringConnectionId}": deleteLocalPeeringConnectionRequest.localPeeringConnectionId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteLocalPeeringConnectionRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/localPeeringConnections/{localPeeringConnectionId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteLocalPeeringConnectionResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Deletes the specified local peering gateway (LPG).
* <p>
This is an asynchronous operation; the local peering gateway's `lifecycleState` changes to TERMINATING temporarily
* until the local peering gateway is completely removed.
* 
     * @param DeleteLocalPeeringGatewayRequest
     * @return DeleteLocalPeeringGatewayResponse
     * @throws OciError when an error occurs
     */
  public async deleteLocalPeeringGateway(
    deleteLocalPeeringGatewayRequest: requests.DeleteLocalPeeringGatewayRequest
  ): Promise<responses.DeleteLocalPeeringGatewayResponse> {
    const pathParams = {
      "{localPeeringGatewayId}": deleteLocalPeeringGatewayRequest.localPeeringGatewayId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteLocalPeeringGatewayRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/localPeeringGateways/{localPeeringGatewayId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteLocalPeeringGatewayResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Deletes the specified NAT gateway. The NAT gateway does not have to be disabled, but there
* must not be a route rule that lists the NAT gateway as a target.
* <p>
This is an asynchronous operation. The NAT gateway's `lifecycleState` will change to
* TERMINATING temporarily until the NAT gateway is completely removed.
* 
     * @param DeleteNatGatewayRequest
     * @return DeleteNatGatewayResponse
     * @throws OciError when an error occurs
     */
  public async deleteNatGateway(
    deleteNatGatewayRequest: requests.DeleteNatGatewayRequest
  ): Promise<responses.DeleteNatGatewayResponse> {
    const pathParams = {
      "{natGatewayId}": deleteNatGatewayRequest.natGatewayId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteNatGatewayRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/natGateways/{natGatewayId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteNatGatewayResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Deletes the specified network security group. The group must not contain any VNICs.
* <p>
To get a list of the VNICs in a network security group, use
* {@link #listNetworkSecurityGroupVnics(ListNetworkSecurityGroupVnicsRequest) listNetworkSecurityGroupVnics}.
* Each returned {@link NetworkSecurityGroupVnic} object
* contains both the OCID of the VNIC and the OCID of the VNIC's parent resource (for example,
* the Compute instance that the VNIC is attached to).
* 
     * @param DeleteNetworkSecurityGroupRequest
     * @return DeleteNetworkSecurityGroupResponse
     * @throws OciError when an error occurs
     */
  public async deleteNetworkSecurityGroup(
    deleteNetworkSecurityGroupRequest: requests.DeleteNetworkSecurityGroupRequest
  ): Promise<responses.DeleteNetworkSecurityGroupResponse> {
    const pathParams = {
      "{networkSecurityGroupId}": deleteNetworkSecurityGroupRequest.networkSecurityGroupId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteNetworkSecurityGroupRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/networkSecurityGroups/{networkSecurityGroupId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteNetworkSecurityGroupResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Unassigns and deletes the specified private IP. You must
* specify the object's OCID. The private IP address is returned to
* the subnet's pool of available addresses.
* <p>
This operation cannot be used with primary private IPs, which are
* automatically unassigned and deleted when the VNIC is terminated.
* <p>
**Important:** If a secondary private IP is the
* [target of a route rule](https://docs.cloud.oracle.com/Content/Network/Tasks/managingroutetables.htm#privateip),
* unassigning it from the VNIC causes that route rule to blackhole and the traffic
* will be dropped.
* 
     * @param DeletePrivateIpRequest
     * @return DeletePrivateIpResponse
     * @throws OciError when an error occurs
     */
  public async deletePrivateIp(
    deletePrivateIpRequest: requests.DeletePrivateIpRequest
  ): Promise<responses.DeletePrivateIpResponse> {
    const pathParams = {
      "{privateIpId}": deletePrivateIpRequest.privateIpId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deletePrivateIpRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/privateIps/{privateIpId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeletePrivateIpResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Unassigns and deletes the specified public IP (either ephemeral or reserved).
* You must specify the object's OCID. The public IP address is returned to the
* Oracle Cloud Infrastructure public IP pool.
* <p>
**Note:** You cannot update, unassign, or delete the public IP that Oracle automatically
* assigned to an entity for you (such as a load balancer or NAT gateway). The public IP is
* automatically deleted if the assigned entity is terminated.
* <p>
For an assigned reserved public IP, the initial unassignment portion of this operation
* is asynchronous. Poll the public IP's `lifecycleState` to determine
* if the operation succeeded.
* <p>
If you want to simply unassign a reserved public IP and return it to your pool
* of reserved public IPs, instead use
* {@link #updatePublicIp(UpdatePublicIpRequest) updatePublicIp}.
* 
     * @param DeletePublicIpRequest
     * @return DeletePublicIpResponse
     * @throws OciError when an error occurs
     */
  public async deletePublicIp(
    deletePublicIpRequest: requests.DeletePublicIpRequest
  ): Promise<responses.DeletePublicIpResponse> {
    const pathParams = {
      "{publicIpId}": deletePublicIpRequest.publicIpId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deletePublicIpRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/publicIps/{publicIpId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeletePublicIpResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Deletes the remote peering connection (RPC).
* <p>
This is an asynchronous operation; the RPC's `lifecycleState` changes to TERMINATING temporarily
* until the RPC is completely removed.
* 
     * @param DeleteRemotePeeringConnectionRequest
     * @return DeleteRemotePeeringConnectionResponse
     * @throws OciError when an error occurs
     */
  public async deleteRemotePeeringConnection(
    deleteRemotePeeringConnectionRequest: requests.DeleteRemotePeeringConnectionRequest
  ): Promise<responses.DeleteRemotePeeringConnectionResponse> {
    const pathParams = {
      "{remotePeeringConnectionId}": deleteRemotePeeringConnectionRequest.remotePeeringConnectionId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteRemotePeeringConnectionRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/remotePeeringConnections/{remotePeeringConnectionId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteRemotePeeringConnectionResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Deletes the specified route table, but only if it's not associated with a subnet. You can't delete a
* VCN's default route table.
* <p>
This is an asynchronous operation. The route table's `lifecycleState` will change to TERMINATING temporarily
* until the route table is completely removed.
* 
     * @param DeleteRouteTableRequest
     * @return DeleteRouteTableResponse
     * @throws OciError when an error occurs
     */
  public async deleteRouteTable(
    deleteRouteTableRequest: requests.DeleteRouteTableRequest
  ): Promise<responses.DeleteRouteTableResponse> {
    const pathParams = {
      "{rtId}": deleteRouteTableRequest.rtId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteRouteTableRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/routeTables/{rtId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteRouteTableResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Deletes the specified security list, but only if it's not associated with a subnet. You can't delete
* a VCN's default security list.
* <p>
This is an asynchronous operation. The security list's `lifecycleState` will change to TERMINATING temporarily
* until the security list is completely removed.
* 
     * @param DeleteSecurityListRequest
     * @return DeleteSecurityListResponse
     * @throws OciError when an error occurs
     */
  public async deleteSecurityList(
    deleteSecurityListRequest: requests.DeleteSecurityListRequest
  ): Promise<responses.DeleteSecurityListResponse> {
    const pathParams = {
      "{securityListId}": deleteSecurityListRequest.securityListId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteSecurityListRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/securityLists/{securityListId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteSecurityListResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Deletes the specified service gateway. There must not be a route table that lists the service
   * gateway as a target.
   *
   * @param DeleteServiceGatewayRequest
   * @return DeleteServiceGatewayResponse
   * @throws OciError when an error occurs
   */
  public async deleteServiceGateway(
    deleteServiceGatewayRequest: requests.DeleteServiceGatewayRequest
  ): Promise<responses.DeleteServiceGatewayResponse> {
    const pathParams = {
      "{serviceGatewayId}": deleteServiceGatewayRequest.serviceGatewayId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteServiceGatewayRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/serviceGateways/{serviceGatewayId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteServiceGatewayResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Deletes the specified subnet, but only if there are no instances in the subnet. This is an asynchronous
   * operation. The subnet's `lifecycleState` will change to TERMINATING temporarily. If there are any
   * instances in the subnet, the state will instead change back to AVAILABLE.
   *
   * @param DeleteSubnetRequest
   * @return DeleteSubnetResponse
   * @throws OciError when an error occurs
   */
  public async deleteSubnet(
    deleteSubnetRequest: requests.DeleteSubnetRequest
  ): Promise<responses.DeleteSubnetResponse> {
    const pathParams = {
      "{subnetId}": deleteSubnetRequest.subnetId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteSubnetRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/subnets/{subnetId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteSubnetResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Deletes the specified VCN. The VCN must be empty and have no attached gateways. This is an asynchronous
   * operation. The VCN's `lifecycleState` will change to TERMINATING temporarily until the VCN is completely
   * removed.
   *
   * @param DeleteVcnRequest
   * @return DeleteVcnResponse
   * @throws OciError when an error occurs
   */
  public async deleteVcn(
    deleteVcnRequest: requests.DeleteVcnRequest
  ): Promise<responses.DeleteVcnResponse> {
    const pathParams = {
      "{vcnId}": deleteVcnRequest.vcnId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteVcnRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/vcns/{vcnId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteVcnResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Deletes the specified virtual circuit.
   * <p>
   **Important:** If you're using FastConnect via a provider,
   * make sure to also terminate the connection with
   * the provider, or else the provider may continue to bill you.
   *
   * @param DeleteVirtualCircuitRequest
   * @return DeleteVirtualCircuitResponse
   * @throws OciError when an error occurs
   */
  public async deleteVirtualCircuit(
    deleteVirtualCircuitRequest: requests.DeleteVirtualCircuitRequest
  ): Promise<responses.DeleteVirtualCircuitResponse> {
    const pathParams = {
      "{virtualCircuitId}": deleteVirtualCircuitRequest.virtualCircuitId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteVirtualCircuitRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/virtualCircuits/{virtualCircuitId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteVirtualCircuitResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Removes the specified {@link Service} from the list of enabled
   * `Service` objects for the specified gateway. You do not need to remove any route
   * rules that specify this `Service` object's `cidrBlock` as the destination CIDR. However, consider
   * removing the rules if your intent is to permanently disable use of the `Service` through this
   * service gateway.
   * <p>
   **Note:** The `DetachServiceId` operation is an easy way to remove an individual `Service` from
   * the service gateway. Compare it with
   * {@link #updateServiceGateway(UpdateServiceGatewayRequest) updateServiceGateway}, which replaces
   * the entire existing list of enabled `Service` objects with the list that you provide in the
   * `Update` call. `UpdateServiceGateway` also lets you block all traffic through the service
   * gateway without having to remove each of the individual `Service` objects.
   *
   * @param DetachServiceIdRequest
   * @return DetachServiceIdResponse
   * @throws OciError when an error occurs
   */
  public async detachServiceId(
    detachServiceIdRequest: requests.DetachServiceIdRequest
  ): Promise<responses.DetachServiceIdResponse> {
    const pathParams = {
      "{serviceGatewayId}": detachServiceIdRequest.serviceGatewayId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": detachServiceIdRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/serviceGateways/{serviceGatewayId}/actions/detachService",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        detachServiceIdRequest.detachServiceDetails,
        "ServiceIdRequestDetails",
        models.ServiceIdRequestDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DetachServiceIdResponse>{},
        body: await response.json(),
        bodyKey: "serviceGateway",
        bodyModel: "model.ServiceGateway",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Generates a token from this local peering connection. You can share this token with a
   * peer who can then accept the token. The peer will likewise generate a token that you can
   * accept. Once both sides accept one another's token, a peering is established. Note that
   * peering tokens are not entities and are not persisted by the API.
   *
   * @param GenerateLocalPeeringTokenRequest
   * @return GenerateLocalPeeringTokenResponse
   * @throws OciError when an error occurs
   */
  public async generateLocalPeeringToken(
    generateLocalPeeringTokenRequest: requests.GenerateLocalPeeringTokenRequest
  ): Promise<responses.GenerateLocalPeeringTokenResponse> {
    const pathParams = {
      "{localPeeringConnectionId}": generateLocalPeeringTokenRequest.localPeeringConnectionId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/localPeeringConnections/{localPeeringConnectionId}/actions/generatePeeringToken",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GenerateLocalPeeringTokenResponse>{},
        body: await response.json(),
        bodyKey: "localPeeringTokenDetails",
        bodyModel: "model.LocalPeeringTokenDetails",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the specified CPE's information.
   * @param GetCpeRequest
   * @return GetCpeResponse
   * @throws OciError when an error occurs
   */
  public async getCpe(getCpeRequest: requests.GetCpeRequest): Promise<responses.GetCpeResponse> {
    const pathParams = {
      "{cpeId}": getCpeRequest.cpeId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/cpes/{cpeId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetCpeResponse>{},
        body: await response.json(),
        bodyKey: "cpe",
        bodyModel: "model.Cpe",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Renders a set of CPE configuration content that can help a network engineer configure the actual
* CPE device (for example, a hardware router) represented by the specified {@link Cpe}
* object.
* <p>
The rendered content is specific to the type of CPE device (for example, Cisco ASA). Therefore the
* {@link Cpe} must have the CPE's device type specified by the `cpeDeviceShapeId`
* attribute. The content optionally includes answers that the customer provides (see
* {@link #updateTunnelCpeDeviceConfig(UpdateTunnelCpeDeviceConfigRequest) updateTunnelCpeDeviceConfig}),
* merged with a template of other information specific to the CPE device type.
* <p>
The operation returns configuration information for *all* of the
* {@link IPSecConnection} objects that use the specified CPE.
* Here are similar operations:
* <p>
  * {@link #getIpsecCpeDeviceConfigContent(GetIpsecCpeDeviceConfigContentRequest) getIpsecCpeDeviceConfigContent}
*   returns CPE configuration content for all tunnels in a single IPSec connection.
*   * {@link #getTunnelCpeDeviceConfigContent(GetTunnelCpeDeviceConfigContentRequest) getTunnelCpeDeviceConfigContent}
*   returns CPE configuration content for a specific tunnel within an IPSec connection.
* 
     * @param GetCpeDeviceConfigContentRequest
     * @return GetCpeDeviceConfigContentResponse
     * @throws OciError when an error occurs
     */
  public async getCpeDeviceConfigContent(
    getCpeDeviceConfigContentRequest: requests.GetCpeDeviceConfigContentRequest
  ): Promise<responses.GetCpeDeviceConfigContentResponse> {
    const pathParams = {
      "{cpeId}": getCpeDeviceConfigContentRequest.cpeId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getCpeDeviceConfigContentRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/cpes/{cpeId}/cpeConfigContent",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetCpeDeviceConfigContentResponse>{},

        body: response.body!,
        bodyKey: "value",
        bodyModel: "string",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the detailed information about the specified CPE device type. This might include a set of questions
   * that are specific to the particular CPE device type. The customer must supply answers to those questions
   * (see {@link #updateTunnelCpeDeviceConfig(UpdateTunnelCpeDeviceConfigRequest) updateTunnelCpeDeviceConfig}).
   * The service merges the answers with a template of other information for the CPE device type. The following
   * operations return the merged content:
   * <p>
   * {@link #getCpeDeviceConfigContent(GetCpeDeviceConfigContentRequest) getCpeDeviceConfigContent}
   *   * {@link #getIpsecCpeDeviceConfigContent(GetIpsecCpeDeviceConfigContentRequest) getIpsecCpeDeviceConfigContent}
   *   * {@link #getTunnelCpeDeviceConfigContent(GetTunnelCpeDeviceConfigContentRequest) getTunnelCpeDeviceConfigContent}
   *
   * @param GetCpeDeviceShapeRequest
   * @return GetCpeDeviceShapeResponse
   * @throws OciError when an error occurs
   */
  public async getCpeDeviceShape(
    getCpeDeviceShapeRequest: requests.GetCpeDeviceShapeRequest
  ): Promise<responses.GetCpeDeviceShapeResponse> {
    const pathParams = {
      "{cpeDeviceShapeId}": getCpeDeviceShapeRequest.cpeDeviceShapeId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getCpeDeviceShapeRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/cpeDeviceShapes/{cpeDeviceShapeId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetCpeDeviceShapeResponse>{},
        body: await response.json(),
        bodyKey: "cpeDeviceShapeDetail",
        bodyModel: "model.CpeDeviceShapeDetail",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the specified cross-connect's information.
   * @param GetCrossConnectRequest
   * @return GetCrossConnectResponse
   * @throws OciError when an error occurs
   */
  public async getCrossConnect(
    getCrossConnectRequest: requests.GetCrossConnectRequest
  ): Promise<responses.GetCrossConnectResponse> {
    const pathParams = {
      "{crossConnectId}": getCrossConnectRequest.crossConnectId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/crossConnects/{crossConnectId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetCrossConnectResponse>{},
        body: await response.json(),
        bodyKey: "crossConnect",
        bodyModel: "model.CrossConnect",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the specified cross-connect group's information.
   * @param GetCrossConnectGroupRequest
   * @return GetCrossConnectGroupResponse
   * @throws OciError when an error occurs
   */
  public async getCrossConnectGroup(
    getCrossConnectGroupRequest: requests.GetCrossConnectGroupRequest
  ): Promise<responses.GetCrossConnectGroupResponse> {
    const pathParams = {
      "{crossConnectGroupId}": getCrossConnectGroupRequest.crossConnectGroupId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/crossConnectGroups/{crossConnectGroupId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetCrossConnectGroupResponse>{},
        body: await response.json(),
        bodyKey: "crossConnectGroup",
        bodyModel: "model.CrossConnectGroup",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the Letter of Authority for the specified cross-connect.
   * @param GetCrossConnectLetterOfAuthorityRequest
   * @return GetCrossConnectLetterOfAuthorityResponse
   * @throws OciError when an error occurs
   */
  public async getCrossConnectLetterOfAuthority(
    getCrossConnectLetterOfAuthorityRequest: requests.GetCrossConnectLetterOfAuthorityRequest
  ): Promise<responses.GetCrossConnectLetterOfAuthorityResponse> {
    const pathParams = {
      "{crossConnectId}": getCrossConnectLetterOfAuthorityRequest.crossConnectId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/crossConnects/{crossConnectId}/letterOfAuthority",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetCrossConnectLetterOfAuthorityResponse>{},
        body: await response.json(),
        bodyKey: "letterOfAuthority",
        bodyModel: "model.LetterOfAuthority",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the status of the specified cross-connect.
   *
   * @param GetCrossConnectStatusRequest
   * @return GetCrossConnectStatusResponse
   * @throws OciError when an error occurs
   */
  public async getCrossConnectStatus(
    getCrossConnectStatusRequest: requests.GetCrossConnectStatusRequest
  ): Promise<responses.GetCrossConnectStatusResponse> {
    const pathParams = {
      "{crossConnectId}": getCrossConnectStatusRequest.crossConnectId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/crossConnects/{crossConnectId}/status",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetCrossConnectStatusResponse>{},
        body: await response.json(),
        bodyKey: "crossConnectStatus",
        bodyModel: "model.CrossConnectStatus",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the specified set of DHCP options.
   * @param GetDhcpOptionsRequest
   * @return GetDhcpOptionsResponse
   * @throws OciError when an error occurs
   */
  public async getDhcpOptions(
    getDhcpOptionsRequest: requests.GetDhcpOptionsRequest
  ): Promise<responses.GetDhcpOptionsResponse> {
    const pathParams = {
      "{dhcpId}": getDhcpOptionsRequest.dhcpId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/dhcps/{dhcpId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetDhcpOptionsResponse>{},
        body: await response.json(),
        bodyKey: "dhcpOptions",
        bodyModel: "model.DhcpOptions",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the specified DRG's information.
   * @param GetDrgRequest
   * @return GetDrgResponse
   * @throws OciError when an error occurs
   */
  public async getDrg(getDrgRequest: requests.GetDrgRequest): Promise<responses.GetDrgResponse> {
    const pathParams = {
      "{drgId}": getDrgRequest.drgId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/drgs/{drgId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetDrgResponse>{},
        body: await response.json(),
        bodyKey: "drg",
        bodyModel: "model.Drg",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the information for the specified `DrgAttachment`.
   * @param GetDrgAttachmentRequest
   * @return GetDrgAttachmentResponse
   * @throws OciError when an error occurs
   */
  public async getDrgAttachment(
    getDrgAttachmentRequest: requests.GetDrgAttachmentRequest
  ): Promise<responses.GetDrgAttachmentResponse> {
    const pathParams = {
      "{drgAttachmentId}": getDrgAttachmentRequest.drgAttachmentId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/drgAttachments/{drgAttachmentId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetDrgAttachmentResponse>{},
        body: await response.json(),
        bodyKey: "drgAttachment",
        bodyModel: "model.DrgAttachment",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the redundancy status for the specified DRG. For more information, see
   * [Redundancy Remedies](https://docs.cloud.oracle.com/Content/Network/Troubleshoot/drgredundancy.htm).
   *
   * @param GetDrgRedundancyStatusRequest
   * @return GetDrgRedundancyStatusResponse
   * @throws OciError when an error occurs
   */
  public async getDrgRedundancyStatus(
    getDrgRedundancyStatusRequest: requests.GetDrgRedundancyStatusRequest
  ): Promise<responses.GetDrgRedundancyStatusResponse> {
    const pathParams = {
      "{drgId}": getDrgRedundancyStatusRequest.drgId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getDrgRedundancyStatusRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/drgs/{drgId}/redundancyStatus",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetDrgRedundancyStatusResponse>{},
        body: await response.json(),
        bodyKey: "drgRedundancyStatus",
        bodyModel: "model.DrgRedundancyStatus",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the specified provider service.
   * For more information, see [FastConnect Overview](https://docs.cloud.oracle.com/Content/Network/Concepts/fastconnect.htm).
   *
   * @param GetFastConnectProviderServiceRequest
   * @return GetFastConnectProviderServiceResponse
   * @throws OciError when an error occurs
   */
  public async getFastConnectProviderService(
    getFastConnectProviderServiceRequest: requests.GetFastConnectProviderServiceRequest
  ): Promise<responses.GetFastConnectProviderServiceResponse> {
    const pathParams = {
      "{providerServiceId}": getFastConnectProviderServiceRequest.providerServiceId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/fastConnectProviderServices/{providerServiceId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetFastConnectProviderServiceResponse>{},
        body: await response.json(),
        bodyKey: "fastConnectProviderService",
        bodyModel: "model.FastConnectProviderService",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the specified provider service key's information. Use this operation to validate a
   * provider service key. An invalid key returns a 404 error.
   *
   * @param GetFastConnectProviderServiceKeyRequest
   * @return GetFastConnectProviderServiceKeyResponse
   * @throws OciError when an error occurs
   */
  public async getFastConnectProviderServiceKey(
    getFastConnectProviderServiceKeyRequest: requests.GetFastConnectProviderServiceKeyRequest
  ): Promise<responses.GetFastConnectProviderServiceKeyResponse> {
    const pathParams = {
      "{providerServiceId}": getFastConnectProviderServiceKeyRequest.providerServiceId,
      "{providerServiceKeyName}": getFastConnectProviderServiceKeyRequest.providerServiceKeyName
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path:
        "/fastConnectProviderServices/{providerServiceId}/providerServiceKeys/{providerServiceKeyName}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetFastConnectProviderServiceKeyResponse>{},
        body: await response.json(),
        bodyKey: "fastConnectProviderServiceKey",
        bodyModel: "model.FastConnectProviderServiceKey",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the specified flow log configuration.
   *
   * @param GetFlowLogConfigRequest
   * @return GetFlowLogConfigResponse
   * @throws OciError when an error occurs
   */
  public async getFlowLogConfig(
    getFlowLogConfigRequest: requests.GetFlowLogConfigRequest
  ): Promise<responses.GetFlowLogConfigResponse> {
    const pathParams = {
      "{flowLogConfigId}": getFlowLogConfigRequest.flowLogConfigId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/flowLogConfigs/{flowLogConfigId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetFlowLogConfigResponse>{},
        body: await response.json(),
        bodyKey: "flowLogConfig",
        bodyModel: "model.FlowLogConfig",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the specified flow log configuration attachment.
   *
   * @param GetFlowLogConfigAttachmentRequest
   * @return GetFlowLogConfigAttachmentResponse
   * @throws OciError when an error occurs
   */
  public async getFlowLogConfigAttachment(
    getFlowLogConfigAttachmentRequest: requests.GetFlowLogConfigAttachmentRequest
  ): Promise<responses.GetFlowLogConfigAttachmentResponse> {
    const pathParams = {
      "{flowLogConfigAttachmentId}": getFlowLogConfigAttachmentRequest.flowLogConfigAttachmentId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/flowLogConfigAttachments/{flowLogConfigAttachmentId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetFlowLogConfigAttachmentResponse>{},
        body: await response.json(),
        bodyKey: "flowLogConfigAttachment",
        bodyModel: "model.FlowLogConfigAttachment",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the specified IPSec connection's basic information, including the static routes for the
   * on-premises router. If you want the status of the connection (whether it's up or down), use
   * {@link #getIPSecConnectionTunnel(GetIPSecConnectionTunnelRequest) getIPSecConnectionTunnel}.
   *
   * @param GetIPSecConnectionRequest
   * @return GetIPSecConnectionResponse
   * @throws OciError when an error occurs
   */
  public async getIPSecConnection(
    getIPSecConnectionRequest: requests.GetIPSecConnectionRequest
  ): Promise<responses.GetIPSecConnectionResponse> {
    const pathParams = {
      "{ipscId}": getIPSecConnectionRequest.ipscId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/ipsecConnections/{ipscId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetIPSecConnectionResponse>{},
        body: await response.json(),
        bodyKey: "iPSecConnection",
        bodyModel: "model.IPSecConnection",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Deprecated. To get tunnel information, instead use:
   * <p>
   * {@link #getIPSecConnectionTunnel(GetIPSecConnectionTunnelRequest) getIPSecConnectionTunnel}
   * * {@link #getIPSecConnectionTunnelSharedSecret(GetIPSecConnectionTunnelSharedSecretRequest) getIPSecConnectionTunnelSharedSecret}
   *
   * @param GetIPSecConnectionDeviceConfigRequest
   * @return GetIPSecConnectionDeviceConfigResponse
   * @throws OciError when an error occurs
   */
  public async getIPSecConnectionDeviceConfig(
    getIPSecConnectionDeviceConfigRequest: requests.GetIPSecConnectionDeviceConfigRequest
  ): Promise<responses.GetIPSecConnectionDeviceConfigResponse> {
    const pathParams = {
      "{ipscId}": getIPSecConnectionDeviceConfigRequest.ipscId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/ipsecConnections/{ipscId}/deviceConfig",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetIPSecConnectionDeviceConfigResponse>{},
        body: await response.json(),
        bodyKey: "iPSecConnectionDeviceConfig",
        bodyModel: "model.IPSecConnectionDeviceConfig",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Deprecated. To get the tunnel status, instead use
   * {@link #getIPSecConnectionTunnel(GetIPSecConnectionTunnelRequest) getIPSecConnectionTunnel}.
   *
   * @param GetIPSecConnectionDeviceStatusRequest
   * @return GetIPSecConnectionDeviceStatusResponse
   * @throws OciError when an error occurs
   */
  public async getIPSecConnectionDeviceStatus(
    getIPSecConnectionDeviceStatusRequest: requests.GetIPSecConnectionDeviceStatusRequest
  ): Promise<responses.GetIPSecConnectionDeviceStatusResponse> {
    const pathParams = {
      "{ipscId}": getIPSecConnectionDeviceStatusRequest.ipscId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/ipsecConnections/{ipscId}/deviceStatus",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetIPSecConnectionDeviceStatusResponse>{},
        body: await response.json(),
        bodyKey: "iPSecConnectionDeviceStatus",
        bodyModel: "model.IPSecConnectionDeviceStatus",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the specified tunnel's information. The resulting object does not include the tunnel's
   * shared secret (pre-shared key). To retrieve that, use
   * {@link #getIPSecConnectionTunnelSharedSecret(GetIPSecConnectionTunnelSharedSecretRequest) getIPSecConnectionTunnelSharedSecret}.
   *
   * @param GetIPSecConnectionTunnelRequest
   * @return GetIPSecConnectionTunnelResponse
   * @throws OciError when an error occurs
   */
  public async getIPSecConnectionTunnel(
    getIPSecConnectionTunnelRequest: requests.GetIPSecConnectionTunnelRequest
  ): Promise<responses.GetIPSecConnectionTunnelResponse> {
    const pathParams = {
      "{ipscId}": getIPSecConnectionTunnelRequest.ipscId,
      "{tunnelId}": getIPSecConnectionTunnelRequest.tunnelId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/ipsecConnections/{ipscId}/tunnels/{tunnelId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetIPSecConnectionTunnelResponse>{},
        body: await response.json(),
        bodyKey: "iPSecConnectionTunnel",
        bodyModel: "model.IPSecConnectionTunnel",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the specified tunnel's shared secret (pre-shared key). To get other information
   * about the tunnel, use {@link #getIPSecConnectionTunnel(GetIPSecConnectionTunnelRequest) getIPSecConnectionTunnel}.
   *
   * @param GetIPSecConnectionTunnelSharedSecretRequest
   * @return GetIPSecConnectionTunnelSharedSecretResponse
   * @throws OciError when an error occurs
   */
  public async getIPSecConnectionTunnelSharedSecret(
    getIPSecConnectionTunnelSharedSecretRequest: requests.GetIPSecConnectionTunnelSharedSecretRequest
  ): Promise<responses.GetIPSecConnectionTunnelSharedSecretResponse> {
    const pathParams = {
      "{ipscId}": getIPSecConnectionTunnelSharedSecretRequest.ipscId,
      "{tunnelId}": getIPSecConnectionTunnelSharedSecretRequest.tunnelId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/ipsecConnections/{ipscId}/tunnels/{tunnelId}/sharedSecret",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetIPSecConnectionTunnelSharedSecretResponse>{},
        body: await response.json(),
        bodyKey: "iPSecConnectionTunnelSharedSecret",
        bodyModel: "model.IPSecConnectionTunnelSharedSecret",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the specified internet gateway's information.
   * @param GetInternetGatewayRequest
   * @return GetInternetGatewayResponse
   * @throws OciError when an error occurs
   */
  public async getInternetGateway(
    getInternetGatewayRequest: requests.GetInternetGatewayRequest
  ): Promise<responses.GetInternetGatewayResponse> {
    const pathParams = {
      "{igId}": getInternetGatewayRequest.igId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/internetGateways/{igId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetInternetGatewayResponse>{},
        body: await response.json(),
        bodyKey: "internetGateway",
        bodyModel: "model.InternetGateway",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Renders a set of CPE configuration content for the specified IPSec connection (for all the
* tunnels in the connection). The content helps a network engineer configure the actual CPE
* device (for example, a hardware router) that the specified IPSec connection terminates on.
* <p>
The rendered content is specific to the type of CPE device (for example, Cisco ASA). Therefore the
* {@link Cpe} used by the specified {@link IPSecConnection}
* must have the CPE's device type specified by the `cpeDeviceShapeId` attribute. The content
* optionally includes answers that the customer provides (see
* {@link #updateTunnelCpeDeviceConfig(UpdateTunnelCpeDeviceConfigRequest) updateTunnelCpeDeviceConfig}),
* merged with a template of other information specific to the CPE device type.
* <p>
The operation returns configuration information for all tunnels in the single specified
* {@link IPSecConnection} object. Here are other similar
* operations:
* <p>
  * {@link #getTunnelCpeDeviceConfigContent(GetTunnelCpeDeviceConfigContentRequest) getTunnelCpeDeviceConfigContent}
*   returns CPE configuration content for a specific tunnel within an IPSec connection.
*   * {@link #getCpeDeviceConfigContent(GetCpeDeviceConfigContentRequest) getCpeDeviceConfigContent}
*   returns CPE configuration content for *all* IPSec connections that use a specific CPE.
* 
     * @param GetIpsecCpeDeviceConfigContentRequest
     * @return GetIpsecCpeDeviceConfigContentResponse
     * @throws OciError when an error occurs
     */
  public async getIpsecCpeDeviceConfigContent(
    getIpsecCpeDeviceConfigContentRequest: requests.GetIpsecCpeDeviceConfigContentRequest
  ): Promise<responses.GetIpsecCpeDeviceConfigContentResponse> {
    const pathParams = {
      "{ipscId}": getIpsecCpeDeviceConfigContentRequest.ipscId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getIpsecCpeDeviceConfigContentRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/ipsecConnections/{ipscId}/cpeConfigContent",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetIpsecCpeDeviceConfigContentResponse>{},

        body: response.body!,
        bodyKey: "value",
        bodyModel: "string",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the specified IPv6. You must specify the object's OCID.
   * Alternatively, you can get the object by using
   * {@link #listIpv6s(ListIpv6sRequest) listIpv6s}
   * with the IPv6 address (for example, 2001:0db8:0123:1111:98fe:dcba:9876:4321) and subnet OCID.
   *
   * @param GetIpv6Request
   * @return GetIpv6Response
   * @throws OciError when an error occurs
   */
  public async getIpv6(
    getIpv6Request: requests.GetIpv6Request
  ): Promise<responses.GetIpv6Response> {
    const pathParams = {
      "{ipv6Id}": getIpv6Request.ipv6Id
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getIpv6Request.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/ipv6/{ipv6Id}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetIpv6Response>{},
        body: await response.json(),
        bodyKey: "ipv6",
        bodyModel: "model.Ipv6",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the specified local peering connection's information.
   *
   * @param GetLocalPeeringConnectionRequest
   * @return GetLocalPeeringConnectionResponse
   * @throws OciError when an error occurs
   */
  public async getLocalPeeringConnection(
    getLocalPeeringConnectionRequest: requests.GetLocalPeeringConnectionRequest
  ): Promise<responses.GetLocalPeeringConnectionResponse> {
    const pathParams = {
      "{localPeeringConnectionId}": getLocalPeeringConnectionRequest.localPeeringConnectionId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/localPeeringConnections/{localPeeringConnectionId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetLocalPeeringConnectionResponse>{},
        body: await response.json(),
        bodyKey: "localPeeringConnection",
        bodyModel: "model.LocalPeeringConnection",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the specified local peering gateway's information.
   * @param GetLocalPeeringGatewayRequest
   * @return GetLocalPeeringGatewayResponse
   * @throws OciError when an error occurs
   */
  public async getLocalPeeringGateway(
    getLocalPeeringGatewayRequest: requests.GetLocalPeeringGatewayRequest
  ): Promise<responses.GetLocalPeeringGatewayResponse> {
    const pathParams = {
      "{localPeeringGatewayId}": getLocalPeeringGatewayRequest.localPeeringGatewayId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/localPeeringGateways/{localPeeringGatewayId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetLocalPeeringGatewayResponse>{},
        body: await response.json(),
        bodyKey: "localPeeringGateway",
        bodyModel: "model.LocalPeeringGateway",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the specified NAT gateway's information.
   * @param GetNatGatewayRequest
   * @return GetNatGatewayResponse
   * @throws OciError when an error occurs
   */
  public async getNatGateway(
    getNatGatewayRequest: requests.GetNatGatewayRequest
  ): Promise<responses.GetNatGatewayResponse> {
    const pathParams = {
      "{natGatewayId}": getNatGatewayRequest.natGatewayId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/natGateways/{natGatewayId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetNatGatewayResponse>{},
        body: await response.json(),
        bodyKey: "natGateway",
        bodyModel: "model.NatGateway",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Gets the specified network security group's information.
* <p>
To list the VNICs in an NSG, see
* {@link #listNetworkSecurityGroupVnics(ListNetworkSecurityGroupVnicsRequest) listNetworkSecurityGroupVnics}.
* <p>
To list the security rules in an NSG, see
* {@link #listNetworkSecurityGroupSecurityRules(ListNetworkSecurityGroupSecurityRulesRequest) listNetworkSecurityGroupSecurityRules}.
* 
     * @param GetNetworkSecurityGroupRequest
     * @return GetNetworkSecurityGroupResponse
     * @throws OciError when an error occurs
     */
  public async getNetworkSecurityGroup(
    getNetworkSecurityGroupRequest: requests.GetNetworkSecurityGroupRequest
  ): Promise<responses.GetNetworkSecurityGroupResponse> {
    const pathParams = {
      "{networkSecurityGroupId}": getNetworkSecurityGroupRequest.networkSecurityGroupId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/networkSecurityGroups/{networkSecurityGroupId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetNetworkSecurityGroupResponse>{},
        body: await response.json(),
        bodyKey: "networkSecurityGroup",
        bodyModel: "model.NetworkSecurityGroup",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the specified private IP. You must specify the object's OCID.
   * Alternatively, you can get the object by using
   * {@link #listPrivateIps(ListPrivateIpsRequest) listPrivateIps}
   * with the private IP address (for example, 10.0.3.3) and subnet OCID.
   *
   * @param GetPrivateIpRequest
   * @return GetPrivateIpResponse
   * @throws OciError when an error occurs
   */
  public async getPrivateIp(
    getPrivateIpRequest: requests.GetPrivateIpRequest
  ): Promise<responses.GetPrivateIpResponse> {
    const pathParams = {
      "{privateIpId}": getPrivateIpRequest.privateIpId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/privateIps/{privateIpId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetPrivateIpResponse>{},
        body: await response.json(),
        bodyKey: "privateIp",
        bodyModel: "model.PrivateIp",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Gets the specified public IP. You must specify the object's OCID.
* <p>
Alternatively, you can get the object by using {@link #getPublicIpByIpAddress(GetPublicIpByIpAddressRequest) getPublicIpByIpAddress}
* with the public IP address (for example, 129.146.2.1).
* <p>
Or you can use {@link #getPublicIpByPrivateIpId(GetPublicIpByPrivateIpIdRequest) getPublicIpByPrivateIpId}
* with the OCID of the private IP that the public IP is assigned to.
* <p>
**Note:** If you're fetching a reserved public IP that is in the process of being
* moved to a different private IP, the service returns the public IP object with
* `lifecycleState` = ASSIGNING and `assignedEntityId` = OCID of the target private IP.
* 
     * @param GetPublicIpRequest
     * @return GetPublicIpResponse
     * @throws OciError when an error occurs
     */
  public async getPublicIp(
    getPublicIpRequest: requests.GetPublicIpRequest
  ): Promise<responses.GetPublicIpResponse> {
    const pathParams = {
      "{publicIpId}": getPublicIpRequest.publicIpId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/publicIps/{publicIpId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetPublicIpResponse>{},
        body: await response.json(),
        bodyKey: "publicIp",
        bodyModel: "model.PublicIp",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the public IP based on the public IP address (for example, 129.146.2.1).
   * <p>
   **Note:** If you're fetching a reserved public IP that is in the process of being
   * moved to a different private IP, the service returns the public IP object with
   * `lifecycleState` = ASSIGNING and `assignedEntityId` = OCID of the target private IP.
   *
   * @param GetPublicIpByIpAddressRequest
   * @return GetPublicIpByIpAddressResponse
   * @throws OciError when an error occurs
   */
  public async getPublicIpByIpAddress(
    getPublicIpByIpAddressRequest: requests.GetPublicIpByIpAddressRequest
  ): Promise<responses.GetPublicIpByIpAddressResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/publicIps/actions/getByIpAddress",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        getPublicIpByIpAddressRequest.getPublicIpByIpAddressDetails,
        "GetPublicIpByIpAddressDetails",
        models.GetPublicIpByIpAddressDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetPublicIpByIpAddressResponse>{},
        body: await response.json(),
        bodyKey: "publicIp",
        bodyModel: "model.PublicIp",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the public IP assigned to the specified private IP. You must specify the OCID
   * of the private IP. If no public IP is assigned, a 404 is returned.
   * <p>
   **Note:** If you're fetching a reserved public IP that is in the process of being
   * moved to a different private IP, and you provide the OCID of the original private
   * IP, this operation returns a 404. If you instead provide the OCID of the target
   * private IP, or if you instead call
   * {@link #getPublicIp(GetPublicIpRequest) getPublicIp} or
   * {@link #getPublicIpByIpAddress(GetPublicIpByIpAddressRequest) getPublicIpByIpAddress}, the
   * service returns the public IP object with `lifecycleState` = ASSIGNING and
   * `assignedEntityId` = OCID of the target private IP.
   *
   * @param GetPublicIpByPrivateIpIdRequest
   * @return GetPublicIpByPrivateIpIdResponse
   * @throws OciError when an error occurs
   */
  public async getPublicIpByPrivateIpId(
    getPublicIpByPrivateIpIdRequest: requests.GetPublicIpByPrivateIpIdRequest
  ): Promise<responses.GetPublicIpByPrivateIpIdResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/publicIps/actions/getByPrivateIpId",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        getPublicIpByPrivateIpIdRequest.getPublicIpByPrivateIpIdDetails,
        "GetPublicIpByPrivateIpIdDetails",
        models.GetPublicIpByPrivateIpIdDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetPublicIpByPrivateIpIdResponse>{},
        body: await response.json(),
        bodyKey: "publicIp",
        bodyModel: "model.PublicIp",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Get the specified remote peering connection's information.
   *
   * @param GetRemotePeeringConnectionRequest
   * @return GetRemotePeeringConnectionResponse
   * @throws OciError when an error occurs
   */
  public async getRemotePeeringConnection(
    getRemotePeeringConnectionRequest: requests.GetRemotePeeringConnectionRequest
  ): Promise<responses.GetRemotePeeringConnectionResponse> {
    const pathParams = {
      "{remotePeeringConnectionId}": getRemotePeeringConnectionRequest.remotePeeringConnectionId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/remotePeeringConnections/{remotePeeringConnectionId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetRemotePeeringConnectionResponse>{},
        body: await response.json(),
        bodyKey: "remotePeeringConnection",
        bodyModel: "model.RemotePeeringConnection",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the specified route table's information.
   * @param GetRouteTableRequest
   * @return GetRouteTableResponse
   * @throws OciError when an error occurs
   */
  public async getRouteTable(
    getRouteTableRequest: requests.GetRouteTableRequest
  ): Promise<responses.GetRouteTableResponse> {
    const pathParams = {
      "{rtId}": getRouteTableRequest.rtId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/routeTables/{rtId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetRouteTableResponse>{},
        body: await response.json(),
        bodyKey: "routeTable",
        bodyModel: "model.RouteTable",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the specified security list's information.
   * @param GetSecurityListRequest
   * @return GetSecurityListResponse
   * @throws OciError when an error occurs
   */
  public async getSecurityList(
    getSecurityListRequest: requests.GetSecurityListRequest
  ): Promise<responses.GetSecurityListResponse> {
    const pathParams = {
      "{securityListId}": getSecurityListRequest.securityListId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/securityLists/{securityListId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetSecurityListResponse>{},
        body: await response.json(),
        bodyKey: "securityList",
        bodyModel: "model.SecurityList",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the specified {@link Service} object.
   *
   * @param GetServiceRequest
   * @return GetServiceResponse
   * @throws OciError when an error occurs
   */
  public async getService(
    getServiceRequest: requests.GetServiceRequest
  ): Promise<responses.GetServiceResponse> {
    const pathParams = {
      "{serviceId}": getServiceRequest.serviceId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/services/{serviceId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetServiceResponse>{},
        body: await response.json(),
        bodyKey: "service",
        bodyModel: "model.Service",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the specified service gateway's information.
   * @param GetServiceGatewayRequest
   * @return GetServiceGatewayResponse
   * @throws OciError when an error occurs
   */
  public async getServiceGateway(
    getServiceGatewayRequest: requests.GetServiceGatewayRequest
  ): Promise<responses.GetServiceGatewayResponse> {
    const pathParams = {
      "{serviceGatewayId}": getServiceGatewayRequest.serviceGatewayId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/serviceGateways/{serviceGatewayId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetServiceGatewayResponse>{},
        body: await response.json(),
        bodyKey: "serviceGateway",
        bodyModel: "model.ServiceGateway",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the specified subnet's information.
   * @param GetSubnetRequest
   * @return GetSubnetResponse
   * @throws OciError when an error occurs
   */
  public async getSubnet(
    getSubnetRequest: requests.GetSubnetRequest
  ): Promise<responses.GetSubnetResponse> {
    const pathParams = {
      "{subnetId}": getSubnetRequest.subnetId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/subnets/{subnetId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetSubnetResponse>{},
        body: await response.json(),
        bodyKey: "subnet",
        bodyModel: "model.Subnet",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the set of CPE configuration answers for the tunnel, which the customer provided in
   * {@link #updateTunnelCpeDeviceConfig(UpdateTunnelCpeDeviceConfigRequest) updateTunnelCpeDeviceConfig}.
   * To get the full set of content for the tunnel (any answers merged with the template of other
   * information specific to the CPE device type), use
   * {@link #getTunnelCpeDeviceConfigContent(GetTunnelCpeDeviceConfigContentRequest) getTunnelCpeDeviceConfigContent}.
   *
   * @param GetTunnelCpeDeviceConfigRequest
   * @return GetTunnelCpeDeviceConfigResponse
   * @throws OciError when an error occurs
   */
  public async getTunnelCpeDeviceConfig(
    getTunnelCpeDeviceConfigRequest: requests.GetTunnelCpeDeviceConfigRequest
  ): Promise<responses.GetTunnelCpeDeviceConfigResponse> {
    const pathParams = {
      "{ipscId}": getTunnelCpeDeviceConfigRequest.ipscId,
      "{tunnelId}": getTunnelCpeDeviceConfigRequest.tunnelId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getTunnelCpeDeviceConfigRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/ipsecConnections/{ipscId}/tunnels/{tunnelId}/tunnelDeviceConfig",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetTunnelCpeDeviceConfigResponse>{},
        body: await response.json(),
        bodyKey: "tunnelCpeDeviceConfig",
        bodyModel: "model.TunnelCpeDeviceConfig",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Renders a set of CPE configuration content for the specified IPSec tunnel. The content helps a
* network engineer configure the actual CPE device (for example, a hardware router) that the specified
* IPSec tunnel terminates on.
* <p>
The rendered content is specific to the type of CPE device (for example, Cisco ASA). Therefore the
* {@link Cpe} used by the specified {@link IPSecConnection}
* must have the CPE's device type specified by the `cpeDeviceShapeId` attribute. The content
* optionally includes answers that the customer provides (see
* {@link #updateTunnelCpeDeviceConfig(UpdateTunnelCpeDeviceConfigRequest) updateTunnelCpeDeviceConfig}),
* merged with a template of other information specific to the CPE device type.
* <p>
The operation returns configuration information for only the specified IPSec tunnel.
* Here are other similar operations:
* <p>
  * {@link #getIpsecCpeDeviceConfigContent(GetIpsecCpeDeviceConfigContentRequest) getIpsecCpeDeviceConfigContent}
*   returns CPE configuration content for all tunnels in a single IPSec connection.
*   * {@link #getCpeDeviceConfigContent(GetCpeDeviceConfigContentRequest) getCpeDeviceConfigContent}
*   returns CPE configuration content for *all* IPSec connections that use a specific CPE.
* 
     * @param GetTunnelCpeDeviceConfigContentRequest
     * @return GetTunnelCpeDeviceConfigContentResponse
     * @throws OciError when an error occurs
     */
  public async getTunnelCpeDeviceConfigContent(
    getTunnelCpeDeviceConfigContentRequest: requests.GetTunnelCpeDeviceConfigContentRequest
  ): Promise<responses.GetTunnelCpeDeviceConfigContentResponse> {
    const pathParams = {
      "{ipscId}": getTunnelCpeDeviceConfigContentRequest.ipscId,
      "{tunnelId}": getTunnelCpeDeviceConfigContentRequest.tunnelId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getTunnelCpeDeviceConfigContentRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/ipsecConnections/{ipscId}/tunnels/{tunnelId}/tunnelDeviceConfig/content",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetTunnelCpeDeviceConfigContentResponse>{},

        body: response.body!,
        bodyKey: "value",
        bodyModel: "string",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the specified VCN's information.
   * @param GetVcnRequest
   * @return GetVcnResponse
   * @throws OciError when an error occurs
   */
  public async getVcn(getVcnRequest: requests.GetVcnRequest): Promise<responses.GetVcnResponse> {
    const pathParams = {
      "{vcnId}": getVcnRequest.vcnId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/vcns/{vcnId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetVcnResponse>{},
        body: await response.json(),
        bodyKey: "vcn",
        bodyModel: "model.Vcn",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the specified virtual circuit's information.
   * @param GetVirtualCircuitRequest
   * @return GetVirtualCircuitResponse
   * @throws OciError when an error occurs
   */
  public async getVirtualCircuit(
    getVirtualCircuitRequest: requests.GetVirtualCircuitRequest
  ): Promise<responses.GetVirtualCircuitResponse> {
    const pathParams = {
      "{virtualCircuitId}": getVirtualCircuitRequest.virtualCircuitId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/virtualCircuits/{virtualCircuitId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetVirtualCircuitResponse>{},
        body: await response.json(),
        bodyKey: "virtualCircuit",
        bodyModel: "model.VirtualCircuit",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the information for the specified virtual network interface card (VNIC).
   * You can get the VNIC OCID from the
   * {@link #listVnicAttachments(ListVnicAttachmentsRequest) listVnicAttachments}
   * operation.
   *
   * @param GetVnicRequest
   * @return GetVnicResponse
   * @throws OciError when an error occurs
   */
  public async getVnic(
    getVnicRequest: requests.GetVnicRequest
  ): Promise<responses.GetVnicResponse> {
    const pathParams = {
      "{vnicId}": getVnicRequest.vnicId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/vnics/{vnicId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetVnicResponse>{},
        body: await response.json(),
        bodyKey: "vnic",
        bodyModel: "model.Vnic",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Lists the regions that support remote VCN peering (which is peering across regions).
   * For more information, see [VCN Peering](https://docs.cloud.oracle.com/Content/Network/Tasks/VCNpeering.htm).
   *
   * @param ListAllowedPeerRegionsForRemotePeeringRequest
   * @return ListAllowedPeerRegionsForRemotePeeringResponse
   * @throws OciError when an error occurs
   */
  public async listAllowedPeerRegionsForRemotePeering(
    listAllowedPeerRegionsForRemotePeeringRequest: requests.ListAllowedPeerRegionsForRemotePeeringRequest
  ): Promise<responses.ListAllowedPeerRegionsForRemotePeeringResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/allowedPeerRegionsForRemotePeering",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListAllowedPeerRegionsForRemotePeeringResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "PeerRegionForRemotePeering[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Lists the CPE device types that the Networking service provides CPE configuration
* content for (example: Cisco ASA). The content helps a network engineer configure
* the actual CPE device represented by a {@link Cpe} object.
* <p>
If you want to generate CPE configuration content for one of the returned CPE device types,
* ensure that the {@link Cpe} object's `cpeDeviceShapeId` attribute is set
* to the CPE device type's OCID (returned by this operation).
* <p>
For information about generating CPE configuration content, see these operations:
* <p>
  * {@link #getCpeDeviceConfigContent(GetCpeDeviceConfigContentRequest) getCpeDeviceConfigContent}
*   * {@link #getIpsecCpeDeviceConfigContent(GetIpsecCpeDeviceConfigContentRequest) getIpsecCpeDeviceConfigContent}
*   * {@link #getTunnelCpeDeviceConfigContent(GetTunnelCpeDeviceConfigContentRequest) getTunnelCpeDeviceConfigContent}
* 
     * @param ListCpeDeviceShapesRequest
     * @return ListCpeDeviceShapesResponse
     * @throws OciError when an error occurs
     */
  public async listCpeDeviceShapes(
    listCpeDeviceShapesRequest: requests.ListCpeDeviceShapesRequest
  ): Promise<responses.ListCpeDeviceShapesResponse> {
    const pathParams = {};

    const queryParams = {
      "limit": listCpeDeviceShapesRequest.limit,
      "page": listCpeDeviceShapesRequest.page
    };

    let headerParams = {
      "opc-request-id": listCpeDeviceShapesRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/cpeDeviceShapes",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListCpeDeviceShapesResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "CpeDeviceShapeSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.CpeDeviceShapeSummary objects
   * contained in responses from the listCpeDeviceShapes operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllCpeDeviceShapes(
    request: requests.ListCpeDeviceShapesRequest
  ): AsyncIterableIterator<models.CpeDeviceShapeSummary> {
    return paginateRecords(request, req => this.listCpeDeviceShapes(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listCpeDeviceShapes operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllCpeDeviceShapesResponses(
    request: requests.ListCpeDeviceShapesRequest
  ): AsyncIterableIterator<responses.ListCpeDeviceShapesResponse> {
    return paginateResponses(request, req => this.listCpeDeviceShapes(req));
  }

  /**
   * Lists the customer-premises equipment objects (CPEs) in the specified compartment.
   *
   * @param ListCpesRequest
   * @return ListCpesResponse
   * @throws OciError when an error occurs
   */
  public async listCpes(
    listCpesRequest: requests.ListCpesRequest
  ): Promise<responses.ListCpesResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listCpesRequest.compartmentId,
      "limit": listCpesRequest.limit,
      "page": listCpesRequest.page
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/cpes",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListCpesResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "Cpe[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.Cpe objects
   * contained in responses from the listCpes operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllCpes(request: requests.ListCpesRequest): AsyncIterableIterator<models.Cpe> {
    return paginateRecords(request, req => this.listCpes(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listCpes operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllCpesResponses(
    request: requests.ListCpesRequest
  ): AsyncIterableIterator<responses.ListCpesResponse> {
    return paginateResponses(request, req => this.listCpes(req));
  }

  /**
   * Lists the cross-connect groups in the specified compartment.
   *
   * @param ListCrossConnectGroupsRequest
   * @return ListCrossConnectGroupsResponse
   * @throws OciError when an error occurs
   */
  public async listCrossConnectGroups(
    listCrossConnectGroupsRequest: requests.ListCrossConnectGroupsRequest
  ): Promise<responses.ListCrossConnectGroupsResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listCrossConnectGroupsRequest.compartmentId,
      "limit": listCrossConnectGroupsRequest.limit,
      "page": listCrossConnectGroupsRequest.page,
      "displayName": listCrossConnectGroupsRequest.displayName,
      "sortBy": listCrossConnectGroupsRequest.sortBy,
      "sortOrder": listCrossConnectGroupsRequest.sortOrder,
      "lifecycleState": listCrossConnectGroupsRequest.lifecycleState
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/crossConnectGroups",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListCrossConnectGroupsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "CrossConnectGroup[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.CrossConnectGroup objects
   * contained in responses from the listCrossConnectGroups operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllCrossConnectGroups(
    request: requests.ListCrossConnectGroupsRequest
  ): AsyncIterableIterator<models.CrossConnectGroup> {
    return paginateRecords(request, req => this.listCrossConnectGroups(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listCrossConnectGroups operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllCrossConnectGroupsResponses(
    request: requests.ListCrossConnectGroupsRequest
  ): AsyncIterableIterator<responses.ListCrossConnectGroupsResponse> {
    return paginateResponses(request, req => this.listCrossConnectGroups(req));
  }

  /**
   * Lists the available FastConnect locations for cross-connect installation. You need
   * this information so you can specify your desired location when you create a cross-connect.
   *
   * @param ListCrossConnectLocationsRequest
   * @return ListCrossConnectLocationsResponse
   * @throws OciError when an error occurs
   */
  public async listCrossConnectLocations(
    listCrossConnectLocationsRequest: requests.ListCrossConnectLocationsRequest
  ): Promise<responses.ListCrossConnectLocationsResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listCrossConnectLocationsRequest.compartmentId,
      "limit": listCrossConnectLocationsRequest.limit,
      "page": listCrossConnectLocationsRequest.page
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/crossConnectLocations",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListCrossConnectLocationsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "CrossConnectLocation[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.CrossConnectLocation objects
   * contained in responses from the listCrossConnectLocations operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllCrossConnectLocations(
    request: requests.ListCrossConnectLocationsRequest
  ): AsyncIterableIterator<models.CrossConnectLocation> {
    return paginateRecords(request, req => this.listCrossConnectLocations(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listCrossConnectLocations operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllCrossConnectLocationsResponses(
    request: requests.ListCrossConnectLocationsRequest
  ): AsyncIterableIterator<responses.ListCrossConnectLocationsResponse> {
    return paginateResponses(request, req => this.listCrossConnectLocations(req));
  }

  /**
   * Lists the cross-connects in the specified compartment. You can filter the list
   * by specifying the OCID of a cross-connect group.
   *
   * @param ListCrossConnectsRequest
   * @return ListCrossConnectsResponse
   * @throws OciError when an error occurs
   */
  public async listCrossConnects(
    listCrossConnectsRequest: requests.ListCrossConnectsRequest
  ): Promise<responses.ListCrossConnectsResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listCrossConnectsRequest.compartmentId,
      "crossConnectGroupId": listCrossConnectsRequest.crossConnectGroupId,
      "limit": listCrossConnectsRequest.limit,
      "page": listCrossConnectsRequest.page,
      "displayName": listCrossConnectsRequest.displayName,
      "sortBy": listCrossConnectsRequest.sortBy,
      "sortOrder": listCrossConnectsRequest.sortOrder,
      "lifecycleState": listCrossConnectsRequest.lifecycleState
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/crossConnects",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListCrossConnectsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "CrossConnect[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.CrossConnect objects
   * contained in responses from the listCrossConnects operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllCrossConnects(
    request: requests.ListCrossConnectsRequest
  ): AsyncIterableIterator<models.CrossConnect> {
    return paginateRecords(request, req => this.listCrossConnects(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listCrossConnects operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllCrossConnectsResponses(
    request: requests.ListCrossConnectsRequest
  ): AsyncIterableIterator<responses.ListCrossConnectsResponse> {
    return paginateResponses(request, req => this.listCrossConnects(req));
  }

  /**
   * Lists the available port speeds for cross-connects. You need this information
   * so you can specify your desired port speed (that is, shape) when you create a
   * cross-connect.
   *
   * @param ListCrossconnectPortSpeedShapesRequest
   * @return ListCrossconnectPortSpeedShapesResponse
   * @throws OciError when an error occurs
   */
  public async listCrossconnectPortSpeedShapes(
    listCrossconnectPortSpeedShapesRequest: requests.ListCrossconnectPortSpeedShapesRequest
  ): Promise<responses.ListCrossconnectPortSpeedShapesResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listCrossconnectPortSpeedShapesRequest.compartmentId,
      "limit": listCrossconnectPortSpeedShapesRequest.limit,
      "page": listCrossconnectPortSpeedShapesRequest.page
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/crossConnectPortSpeedShapes",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListCrossconnectPortSpeedShapesResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "CrossConnectPortSpeedShape[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.CrossConnectPortSpeedShape objects
   * contained in responses from the listCrossconnectPortSpeedShapes operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllCrossconnectPortSpeedShapes(
    request: requests.ListCrossconnectPortSpeedShapesRequest
  ): AsyncIterableIterator<models.CrossConnectPortSpeedShape> {
    return paginateRecords(request, req => this.listCrossconnectPortSpeedShapes(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listCrossconnectPortSpeedShapes operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllCrossconnectPortSpeedShapesResponses(
    request: requests.ListCrossconnectPortSpeedShapesRequest
  ): AsyncIterableIterator<responses.ListCrossconnectPortSpeedShapesResponse> {
    return paginateResponses(request, req => this.listCrossconnectPortSpeedShapes(req));
  }

  /**
   * Lists the sets of DHCP options in the specified VCN and specified compartment.
   * The response includes the default set of options that automatically comes with each VCN,
   * plus any other sets you've created.
   *
   * @param ListDhcpOptionsRequest
   * @return ListDhcpOptionsResponse
   * @throws OciError when an error occurs
   */
  public async listDhcpOptions(
    listDhcpOptionsRequest: requests.ListDhcpOptionsRequest
  ): Promise<responses.ListDhcpOptionsResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listDhcpOptionsRequest.compartmentId,
      "vcnId": listDhcpOptionsRequest.vcnId,
      "limit": listDhcpOptionsRequest.limit,
      "page": listDhcpOptionsRequest.page,
      "displayName": listDhcpOptionsRequest.displayName,
      "sortBy": listDhcpOptionsRequest.sortBy,
      "sortOrder": listDhcpOptionsRequest.sortOrder,
      "lifecycleState": listDhcpOptionsRequest.lifecycleState
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/dhcps",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListDhcpOptionsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "DhcpOptions[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.DhcpOptions objects
   * contained in responses from the listDhcpOptions operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllDhcpOptions(
    request: requests.ListDhcpOptionsRequest
  ): AsyncIterableIterator<models.DhcpOptions> {
    return paginateRecords(request, req => this.listDhcpOptions(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listDhcpOptions operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllDhcpOptionsResponses(
    request: requests.ListDhcpOptionsRequest
  ): AsyncIterableIterator<responses.ListDhcpOptionsResponse> {
    return paginateResponses(request, req => this.listDhcpOptions(req));
  }

  /**
   * Lists the `DrgAttachment` objects for the specified compartment. You can filter the
   * results by VCN or DRG.
   *
   * @param ListDrgAttachmentsRequest
   * @return ListDrgAttachmentsResponse
   * @throws OciError when an error occurs
   */
  public async listDrgAttachments(
    listDrgAttachmentsRequest: requests.ListDrgAttachmentsRequest
  ): Promise<responses.ListDrgAttachmentsResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listDrgAttachmentsRequest.compartmentId,
      "vcnId": listDrgAttachmentsRequest.vcnId,
      "drgId": listDrgAttachmentsRequest.drgId,
      "limit": listDrgAttachmentsRequest.limit,
      "page": listDrgAttachmentsRequest.page
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/drgAttachments",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListDrgAttachmentsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "DrgAttachment[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.DrgAttachment objects
   * contained in responses from the listDrgAttachments operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllDrgAttachments(
    request: requests.ListDrgAttachmentsRequest
  ): AsyncIterableIterator<models.DrgAttachment> {
    return paginateRecords(request, req => this.listDrgAttachments(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listDrgAttachments operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllDrgAttachmentsResponses(
    request: requests.ListDrgAttachmentsRequest
  ): AsyncIterableIterator<responses.ListDrgAttachmentsResponse> {
    return paginateResponses(request, req => this.listDrgAttachments(req));
  }

  /**
   * Lists the DRGs in the specified compartment.
   *
   * @param ListDrgsRequest
   * @return ListDrgsResponse
   * @throws OciError when an error occurs
   */
  public async listDrgs(
    listDrgsRequest: requests.ListDrgsRequest
  ): Promise<responses.ListDrgsResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listDrgsRequest.compartmentId,
      "limit": listDrgsRequest.limit,
      "page": listDrgsRequest.page
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/drgs",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListDrgsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "Drg[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.Drg objects
   * contained in responses from the listDrgs operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllDrgs(request: requests.ListDrgsRequest): AsyncIterableIterator<models.Drg> {
    return paginateRecords(request, req => this.listDrgs(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listDrgs operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllDrgsResponses(
    request: requests.ListDrgsRequest
  ): AsyncIterableIterator<responses.ListDrgsResponse> {
    return paginateResponses(request, req => this.listDrgs(req));
  }

  /**
     * Lists the service offerings from supported providers. You need this
* information so you can specify your desired provider and service
* offering when you create a virtual circuit.
* <p>
For the compartment ID, provide the OCID of your tenancy (the root compartment).
* <p>
For more information, see [FastConnect Overview](https://docs.cloud.oracle.com/Content/Network/Concepts/fastconnect.htm).
* 
     * @param ListFastConnectProviderServicesRequest
     * @return ListFastConnectProviderServicesResponse
     * @throws OciError when an error occurs
     */
  public async listFastConnectProviderServices(
    listFastConnectProviderServicesRequest: requests.ListFastConnectProviderServicesRequest
  ): Promise<responses.ListFastConnectProviderServicesResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listFastConnectProviderServicesRequest.compartmentId,
      "limit": listFastConnectProviderServicesRequest.limit,
      "page": listFastConnectProviderServicesRequest.page
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/fastConnectProviderServices",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListFastConnectProviderServicesResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "FastConnectProviderService[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.FastConnectProviderService objects
   * contained in responses from the listFastConnectProviderServices operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllFastConnectProviderServices(
    request: requests.ListFastConnectProviderServicesRequest
  ): AsyncIterableIterator<models.FastConnectProviderService> {
    return paginateRecords(request, req => this.listFastConnectProviderServices(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listFastConnectProviderServices operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllFastConnectProviderServicesResponses(
    request: requests.ListFastConnectProviderServicesRequest
  ): AsyncIterableIterator<responses.ListFastConnectProviderServicesResponse> {
    return paginateResponses(request, req => this.listFastConnectProviderServices(req));
  }

  /**
     * Gets the list of available virtual circuit bandwidth levels for a provider.
* You need this information so you can specify your desired bandwidth level (shape) when you create a virtual circuit.
* <p>
For more information about virtual circuits, see [FastConnect Overview](https://docs.cloud.oracle.com/Content/Network/Concepts/fastconnect.htm).
* 
     * @param ListFastConnectProviderVirtualCircuitBandwidthShapesRequest
     * @return ListFastConnectProviderVirtualCircuitBandwidthShapesResponse
     * @throws OciError when an error occurs
     */
  public async listFastConnectProviderVirtualCircuitBandwidthShapes(
    listFastConnectProviderVirtualCircuitBandwidthShapesRequest: requests.ListFastConnectProviderVirtualCircuitBandwidthShapesRequest
  ): Promise<responses.ListFastConnectProviderVirtualCircuitBandwidthShapesResponse> {
    const pathParams = {
      "{providerServiceId}":
        listFastConnectProviderVirtualCircuitBandwidthShapesRequest.providerServiceId
    };

    const queryParams = {
      "limit": listFastConnectProviderVirtualCircuitBandwidthShapesRequest.limit,
      "page": listFastConnectProviderVirtualCircuitBandwidthShapesRequest.page
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/fastConnectProviderServices/{providerServiceId}/virtualCircuitBandwidthShapes",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListFastConnectProviderVirtualCircuitBandwidthShapesResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "VirtualCircuitBandwidthShape[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.VirtualCircuitBandwidthShape objects
   * contained in responses from the listFastConnectProviderVirtualCircuitBandwidthShapes operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllFastConnectProviderVirtualCircuitBandwidthShapes(
    request: requests.ListFastConnectProviderVirtualCircuitBandwidthShapesRequest
  ): AsyncIterableIterator<models.VirtualCircuitBandwidthShape> {
    return paginateRecords(request, req =>
      this.listFastConnectProviderVirtualCircuitBandwidthShapes(req)
    );
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listFastConnectProviderVirtualCircuitBandwidthShapes operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllFastConnectProviderVirtualCircuitBandwidthShapesResponses(
    request: requests.ListFastConnectProviderVirtualCircuitBandwidthShapesRequest
  ): AsyncIterableIterator<responses.ListFastConnectProviderVirtualCircuitBandwidthShapesResponse> {
    return paginateResponses(request, req =>
      this.listFastConnectProviderVirtualCircuitBandwidthShapes(req)
    );
  }

  /**
   * Lists the flow log configuration attachments for the specified compartment. You can filter the
   * results by a particular subnet by specifying both `targetEntityId` and `targetEntityType`.
   *
   * @param ListFlowLogConfigAttachmentsRequest
   * @return ListFlowLogConfigAttachmentsResponse
   * @throws OciError when an error occurs
   */
  public async listFlowLogConfigAttachments(
    listFlowLogConfigAttachmentsRequest: requests.ListFlowLogConfigAttachmentsRequest
  ): Promise<responses.ListFlowLogConfigAttachmentsResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listFlowLogConfigAttachmentsRequest.compartmentId,
      "targetEntityId": listFlowLogConfigAttachmentsRequest.targetEntityId,
      "targetEntityType": listFlowLogConfigAttachmentsRequest.targetEntityType,
      "limit": listFlowLogConfigAttachmentsRequest.limit,
      "page": listFlowLogConfigAttachmentsRequest.page
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/flowLogConfigAttachments",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListFlowLogConfigAttachmentsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "FlowLogConfigAttachment[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.FlowLogConfigAttachment objects
   * contained in responses from the listFlowLogConfigAttachments operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllFlowLogConfigAttachments(
    request: requests.ListFlowLogConfigAttachmentsRequest
  ): AsyncIterableIterator<models.FlowLogConfigAttachment> {
    return paginateRecords(request, req => this.listFlowLogConfigAttachments(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listFlowLogConfigAttachments operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllFlowLogConfigAttachmentsResponses(
    request: requests.ListFlowLogConfigAttachmentsRequest
  ): AsyncIterableIterator<responses.ListFlowLogConfigAttachmentsResponse> {
    return paginateResponses(request, req => this.listFlowLogConfigAttachments(req));
  }

  /**
   * Lists the flow log configurations for the specified compartment.
   *
   * @param ListFlowLogConfigsRequest
   * @return ListFlowLogConfigsResponse
   * @throws OciError when an error occurs
   */
  public async listFlowLogConfigs(
    listFlowLogConfigsRequest: requests.ListFlowLogConfigsRequest
  ): Promise<responses.ListFlowLogConfigsResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listFlowLogConfigsRequest.compartmentId,
      "limit": listFlowLogConfigsRequest.limit,
      "page": listFlowLogConfigsRequest.page,
      "displayName": listFlowLogConfigsRequest.displayName,
      "sortBy": listFlowLogConfigsRequest.sortBy,
      "sortOrder": listFlowLogConfigsRequest.sortOrder
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/flowLogConfigs",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListFlowLogConfigsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "FlowLogConfig[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.FlowLogConfig objects
   * contained in responses from the listFlowLogConfigs operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllFlowLogConfigs(
    request: requests.ListFlowLogConfigsRequest
  ): AsyncIterableIterator<models.FlowLogConfig> {
    return paginateRecords(request, req => this.listFlowLogConfigs(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listFlowLogConfigs operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllFlowLogConfigsResponses(
    request: requests.ListFlowLogConfigsRequest
  ): AsyncIterableIterator<responses.ListFlowLogConfigsResponse> {
    return paginateResponses(request, req => this.listFlowLogConfigs(req));
  }

  /**
   * Lists the tunnel information for the specified IPSec connection.
   *
   * @param ListIPSecConnectionTunnelsRequest
   * @return ListIPSecConnectionTunnelsResponse
   * @throws OciError when an error occurs
   */
  public async listIPSecConnectionTunnels(
    listIPSecConnectionTunnelsRequest: requests.ListIPSecConnectionTunnelsRequest
  ): Promise<responses.ListIPSecConnectionTunnelsResponse> {
    const pathParams = {
      "{ipscId}": listIPSecConnectionTunnelsRequest.ipscId
    };

    const queryParams = {
      "limit": listIPSecConnectionTunnelsRequest.limit,
      "page": listIPSecConnectionTunnelsRequest.page
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/ipsecConnections/{ipscId}/tunnels",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListIPSecConnectionTunnelsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "IPSecConnectionTunnel[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.IPSecConnectionTunnel objects
   * contained in responses from the listIPSecConnectionTunnels operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllIPSecConnectionTunnels(
    request: requests.ListIPSecConnectionTunnelsRequest
  ): AsyncIterableIterator<models.IPSecConnectionTunnel> {
    return paginateRecords(request, req => this.listIPSecConnectionTunnels(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listIPSecConnectionTunnels operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllIPSecConnectionTunnelsResponses(
    request: requests.ListIPSecConnectionTunnelsRequest
  ): AsyncIterableIterator<responses.ListIPSecConnectionTunnelsResponse> {
    return paginateResponses(request, req => this.listIPSecConnectionTunnels(req));
  }

  /**
   * Lists the IPSec connections for the specified compartment. You can filter the
   * results by DRG or CPE.
   *
   * @param ListIPSecConnectionsRequest
   * @return ListIPSecConnectionsResponse
   * @throws OciError when an error occurs
   */
  public async listIPSecConnections(
    listIPSecConnectionsRequest: requests.ListIPSecConnectionsRequest
  ): Promise<responses.ListIPSecConnectionsResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listIPSecConnectionsRequest.compartmentId,
      "drgId": listIPSecConnectionsRequest.drgId,
      "cpeId": listIPSecConnectionsRequest.cpeId,
      "limit": listIPSecConnectionsRequest.limit,
      "page": listIPSecConnectionsRequest.page
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/ipsecConnections",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListIPSecConnectionsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "IPSecConnection[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.IPSecConnection objects
   * contained in responses from the listIPSecConnections operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllIPSecConnections(
    request: requests.ListIPSecConnectionsRequest
  ): AsyncIterableIterator<models.IPSecConnection> {
    return paginateRecords(request, req => this.listIPSecConnections(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listIPSecConnections operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllIPSecConnectionsResponses(
    request: requests.ListIPSecConnectionsRequest
  ): AsyncIterableIterator<responses.ListIPSecConnectionsResponse> {
    return paginateResponses(request, req => this.listIPSecConnections(req));
  }

  /**
   * Lists the internet gateways in the specified VCN and the specified compartment.
   *
   * @param ListInternetGatewaysRequest
   * @return ListInternetGatewaysResponse
   * @throws OciError when an error occurs
   */
  public async listInternetGateways(
    listInternetGatewaysRequest: requests.ListInternetGatewaysRequest
  ): Promise<responses.ListInternetGatewaysResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listInternetGatewaysRequest.compartmentId,
      "vcnId": listInternetGatewaysRequest.vcnId,
      "limit": listInternetGatewaysRequest.limit,
      "page": listInternetGatewaysRequest.page,
      "displayName": listInternetGatewaysRequest.displayName,
      "sortBy": listInternetGatewaysRequest.sortBy,
      "sortOrder": listInternetGatewaysRequest.sortOrder,
      "lifecycleState": listInternetGatewaysRequest.lifecycleState
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/internetGateways",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListInternetGatewaysResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "InternetGateway[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.InternetGateway objects
   * contained in responses from the listInternetGateways operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllInternetGateways(
    request: requests.ListInternetGatewaysRequest
  ): AsyncIterableIterator<models.InternetGateway> {
    return paginateRecords(request, req => this.listInternetGateways(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listInternetGateways operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllInternetGatewaysResponses(
    request: requests.ListInternetGatewaysRequest
  ): AsyncIterableIterator<responses.ListInternetGatewaysResponse> {
    return paginateResponses(request, req => this.listInternetGateways(req));
  }

  /**
   * Lists the {@link Ipv6} objects based
   * on one of these filters:
   * <p>
   * Subnet OCID.
   *   * VNIC OCID.
   *   * Both IPv6 address and subnet OCID: This lets you get an `Ipv6` object based on its private
   *   IPv6 address (for example, 2001:0db8:0123:1111:abcd:ef01:2345:6789) and not its OCID. For comparison,
   *   {@link #getIpv6(GetIpv6Request) getIpv6} requires the OCID.
   *
   * @param ListIpv6sRequest
   * @return ListIpv6sResponse
   * @throws OciError when an error occurs
   */
  public async listIpv6s(
    listIpv6sRequest: requests.ListIpv6sRequest
  ): Promise<responses.ListIpv6sResponse> {
    const pathParams = {};

    const queryParams = {
      "limit": listIpv6sRequest.limit,
      "page": listIpv6sRequest.page,
      "ipAddress": listIpv6sRequest.ipAddress,
      "subnetId": listIpv6sRequest.subnetId,
      "vnicId": listIpv6sRequest.vnicId
    };

    let headerParams = {
      "opc-request-id": listIpv6sRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/ipv6",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListIpv6sResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "Ipv6[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.Ipv6 objects
   * contained in responses from the listIpv6s operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllIpv6s(request: requests.ListIpv6sRequest): AsyncIterableIterator<models.Ipv6> {
    return paginateRecords(request, req => this.listIpv6s(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listIpv6s operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllIpv6sResponses(
    request: requests.ListIpv6sRequest
  ): AsyncIterableIterator<responses.ListIpv6sResponse> {
    return paginateResponses(request, req => this.listIpv6s(req));
  }

  /**
   * Lists the local peering connections in the specified VCN and specified compartment.
   *
   * @param ListLocalPeeringConnectionsRequest
   * @return ListLocalPeeringConnectionsResponse
   * @throws OciError when an error occurs
   */
  public async listLocalPeeringConnections(
    listLocalPeeringConnectionsRequest: requests.ListLocalPeeringConnectionsRequest
  ): Promise<responses.ListLocalPeeringConnectionsResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listLocalPeeringConnectionsRequest.compartmentId,
      "limit": listLocalPeeringConnectionsRequest.limit,
      "page": listLocalPeeringConnectionsRequest.page,
      "vcnId": listLocalPeeringConnectionsRequest.vcnId
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/localPeeringConnections",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListLocalPeeringConnectionsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "LocalPeeringConnection[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.LocalPeeringConnection objects
   * contained in responses from the listLocalPeeringConnections operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllLocalPeeringConnections(
    request: requests.ListLocalPeeringConnectionsRequest
  ): AsyncIterableIterator<models.LocalPeeringConnection> {
    return paginateRecords(request, req => this.listLocalPeeringConnections(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listLocalPeeringConnections operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllLocalPeeringConnectionsResponses(
    request: requests.ListLocalPeeringConnectionsRequest
  ): AsyncIterableIterator<responses.ListLocalPeeringConnectionsResponse> {
    return paginateResponses(request, req => this.listLocalPeeringConnections(req));
  }

  /**
   * Lists the local peering gateways (LPGs) for the specified VCN and compartment
   * (the LPG's compartment).
   *
   * @param ListLocalPeeringGatewaysRequest
   * @return ListLocalPeeringGatewaysResponse
   * @throws OciError when an error occurs
   */
  public async listLocalPeeringGateways(
    listLocalPeeringGatewaysRequest: requests.ListLocalPeeringGatewaysRequest
  ): Promise<responses.ListLocalPeeringGatewaysResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listLocalPeeringGatewaysRequest.compartmentId,
      "limit": listLocalPeeringGatewaysRequest.limit,
      "page": listLocalPeeringGatewaysRequest.page,
      "vcnId": listLocalPeeringGatewaysRequest.vcnId
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/localPeeringGateways",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListLocalPeeringGatewaysResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "LocalPeeringGateway[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.LocalPeeringGateway objects
   * contained in responses from the listLocalPeeringGateways operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllLocalPeeringGateways(
    request: requests.ListLocalPeeringGatewaysRequest
  ): AsyncIterableIterator<models.LocalPeeringGateway> {
    return paginateRecords(request, req => this.listLocalPeeringGateways(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listLocalPeeringGateways operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllLocalPeeringGatewaysResponses(
    request: requests.ListLocalPeeringGatewaysRequest
  ): AsyncIterableIterator<responses.ListLocalPeeringGatewaysResponse> {
    return paginateResponses(request, req => this.listLocalPeeringGateways(req));
  }

  /**
   * Lists the NAT gateways in the specified compartment. You may optionally specify a VCN OCID
   * to filter the results by VCN.
   *
   * @param ListNatGatewaysRequest
   * @return ListNatGatewaysResponse
   * @throws OciError when an error occurs
   */
  public async listNatGateways(
    listNatGatewaysRequest: requests.ListNatGatewaysRequest
  ): Promise<responses.ListNatGatewaysResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listNatGatewaysRequest.compartmentId,
      "vcnId": listNatGatewaysRequest.vcnId,
      "limit": listNatGatewaysRequest.limit,
      "page": listNatGatewaysRequest.page,
      "displayName": listNatGatewaysRequest.displayName,
      "sortBy": listNatGatewaysRequest.sortBy,
      "sortOrder": listNatGatewaysRequest.sortOrder,
      "lifecycleState": listNatGatewaysRequest.lifecycleState
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/natGateways",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListNatGatewaysResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "NatGateway[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.NatGateway objects
   * contained in responses from the listNatGateways operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllNatGateways(
    request: requests.ListNatGatewaysRequest
  ): AsyncIterableIterator<models.NatGateway> {
    return paginateRecords(request, req => this.listNatGateways(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listNatGateways operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllNatGatewaysResponses(
    request: requests.ListNatGatewaysRequest
  ): AsyncIterableIterator<responses.ListNatGatewaysResponse> {
    return paginateResponses(request, req => this.listNatGateways(req));
  }

  /**
   * Lists the security rules in the specified network security group.
   *
   * @param ListNetworkSecurityGroupSecurityRulesRequest
   * @return ListNetworkSecurityGroupSecurityRulesResponse
   * @throws OciError when an error occurs
   */
  public async listNetworkSecurityGroupSecurityRules(
    listNetworkSecurityGroupSecurityRulesRequest: requests.ListNetworkSecurityGroupSecurityRulesRequest
  ): Promise<responses.ListNetworkSecurityGroupSecurityRulesResponse> {
    const pathParams = {
      "{networkSecurityGroupId}":
        listNetworkSecurityGroupSecurityRulesRequest.networkSecurityGroupId
    };

    const queryParams = {
      "direction": listNetworkSecurityGroupSecurityRulesRequest.direction,
      "limit": listNetworkSecurityGroupSecurityRulesRequest.limit,
      "page": listNetworkSecurityGroupSecurityRulesRequest.page,
      "sortBy": listNetworkSecurityGroupSecurityRulesRequest.sortBy,
      "sortOrder": listNetworkSecurityGroupSecurityRulesRequest.sortOrder
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/networkSecurityGroups/{networkSecurityGroupId}/securityRules",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListNetworkSecurityGroupSecurityRulesResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "SecurityRule[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.SecurityRule objects
   * contained in responses from the listNetworkSecurityGroupSecurityRules operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllNetworkSecurityGroupSecurityRules(
    request: requests.ListNetworkSecurityGroupSecurityRulesRequest
  ): AsyncIterableIterator<models.SecurityRule> {
    return paginateRecords(request, req => this.listNetworkSecurityGroupSecurityRules(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listNetworkSecurityGroupSecurityRules operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllNetworkSecurityGroupSecurityRulesResponses(
    request: requests.ListNetworkSecurityGroupSecurityRulesRequest
  ): AsyncIterableIterator<responses.ListNetworkSecurityGroupSecurityRulesResponse> {
    return paginateResponses(request, req => this.listNetworkSecurityGroupSecurityRules(req));
  }

  /**
   * Lists the VNICs in the specified network security group.
   *
   * @param ListNetworkSecurityGroupVnicsRequest
   * @return ListNetworkSecurityGroupVnicsResponse
   * @throws OciError when an error occurs
   */
  public async listNetworkSecurityGroupVnics(
    listNetworkSecurityGroupVnicsRequest: requests.ListNetworkSecurityGroupVnicsRequest
  ): Promise<responses.ListNetworkSecurityGroupVnicsResponse> {
    const pathParams = {
      "{networkSecurityGroupId}": listNetworkSecurityGroupVnicsRequest.networkSecurityGroupId
    };

    const queryParams = {
      "limit": listNetworkSecurityGroupVnicsRequest.limit,
      "page": listNetworkSecurityGroupVnicsRequest.page,
      "sortBy": listNetworkSecurityGroupVnicsRequest.sortBy,
      "sortOrder": listNetworkSecurityGroupVnicsRequest.sortOrder
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/networkSecurityGroups/{networkSecurityGroupId}/vnics",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListNetworkSecurityGroupVnicsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "NetworkSecurityGroupVnic[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.NetworkSecurityGroupVnic objects
   * contained in responses from the listNetworkSecurityGroupVnics operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllNetworkSecurityGroupVnics(
    request: requests.ListNetworkSecurityGroupVnicsRequest
  ): AsyncIterableIterator<models.NetworkSecurityGroupVnic> {
    return paginateRecords(request, req => this.listNetworkSecurityGroupVnics(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listNetworkSecurityGroupVnics operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllNetworkSecurityGroupVnicsResponses(
    request: requests.ListNetworkSecurityGroupVnicsRequest
  ): AsyncIterableIterator<responses.ListNetworkSecurityGroupVnicsResponse> {
    return paginateResponses(request, req => this.listNetworkSecurityGroupVnics(req));
  }

  /**
   * Lists the network security groups in the specified compartment.
   *
   * @param ListNetworkSecurityGroupsRequest
   * @return ListNetworkSecurityGroupsResponse
   * @throws OciError when an error occurs
   */
  public async listNetworkSecurityGroups(
    listNetworkSecurityGroupsRequest: requests.ListNetworkSecurityGroupsRequest
  ): Promise<responses.ListNetworkSecurityGroupsResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listNetworkSecurityGroupsRequest.compartmentId,
      "vcnId": listNetworkSecurityGroupsRequest.vcnId,
      "limit": listNetworkSecurityGroupsRequest.limit,
      "page": listNetworkSecurityGroupsRequest.page,
      "displayName": listNetworkSecurityGroupsRequest.displayName,
      "sortBy": listNetworkSecurityGroupsRequest.sortBy,
      "sortOrder": listNetworkSecurityGroupsRequest.sortOrder,
      "lifecycleState": listNetworkSecurityGroupsRequest.lifecycleState
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/networkSecurityGroups",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListNetworkSecurityGroupsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "NetworkSecurityGroup[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.NetworkSecurityGroup objects
   * contained in responses from the listNetworkSecurityGroups operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllNetworkSecurityGroups(
    request: requests.ListNetworkSecurityGroupsRequest
  ): AsyncIterableIterator<models.NetworkSecurityGroup> {
    return paginateRecords(request, req => this.listNetworkSecurityGroups(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listNetworkSecurityGroups operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllNetworkSecurityGroupsResponses(
    request: requests.ListNetworkSecurityGroupsRequest
  ): AsyncIterableIterator<responses.ListNetworkSecurityGroupsResponse> {
    return paginateResponses(request, req => this.listNetworkSecurityGroups(req));
  }

  /**
     * Lists the {@link PrivateIp} objects based
* on one of these filters:
* <p>
  - Subnet OCID.
*   - VNIC OCID.
*   - Both private IP address and subnet OCID: This lets
*   you get a `privateIP` object based on its private IP
*   address (for example, 10.0.3.3) and not its OCID. For comparison,
*   {@link #getPrivateIp(GetPrivateIpRequest) getPrivateIp}
*   requires the OCID.
* <p>
If you're listing all the private IPs associated with a given subnet
* or VNIC, the response includes both primary and secondary private IPs.
* 
     * @param ListPrivateIpsRequest
     * @return ListPrivateIpsResponse
     * @throws OciError when an error occurs
     */
  public async listPrivateIps(
    listPrivateIpsRequest: requests.ListPrivateIpsRequest
  ): Promise<responses.ListPrivateIpsResponse> {
    const pathParams = {};

    const queryParams = {
      "limit": listPrivateIpsRequest.limit,
      "page": listPrivateIpsRequest.page,
      "ipAddress": listPrivateIpsRequest.ipAddress,
      "subnetId": listPrivateIpsRequest.subnetId,
      "vnicId": listPrivateIpsRequest.vnicId
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/privateIps",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListPrivateIpsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "PrivateIp[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.PrivateIp objects
   * contained in responses from the listPrivateIps operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllPrivateIps(
    request: requests.ListPrivateIpsRequest
  ): AsyncIterableIterator<models.PrivateIp> {
    return paginateRecords(request, req => this.listPrivateIps(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listPrivateIps operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllPrivateIpsResponses(
    request: requests.ListPrivateIpsRequest
  ): AsyncIterableIterator<responses.ListPrivateIpsResponse> {
    return paginateResponses(request, req => this.listPrivateIps(req));
  }

  /**
     * Lists the {@link PublicIp} objects
* in the specified compartment. You can filter the list by using query parameters.
* <p>
To list your reserved public IPs:
*   * Set `scope` = `REGION`  (required)
*   * Leave the `availabilityDomain` parameter empty
*   * Set `lifetime` = `RESERVED`
* <p>
To list the ephemeral public IPs assigned to a regional entity such as a NAT gateway:
*   * Set `scope` = `REGION`  (required)
*   * Leave the `availabilityDomain` parameter empty
*   * Set `lifetime` = `EPHEMERAL`
* <p>
To list the ephemeral public IPs assigned to private IPs:
*   * Set `scope` = `AVAILABILITY_DOMAIN` (required)
*   * Set the `availabilityDomain` parameter to the desired availability domain (required)
*   * Set `lifetime` = `EPHEMERAL`
* <p>
**Note:** An ephemeral public IP assigned to a private IP
* is always in the same availability domain and compartment as the private IP.
* 
     * @param ListPublicIpsRequest
     * @return ListPublicIpsResponse
     * @throws OciError when an error occurs
     */
  public async listPublicIps(
    listPublicIpsRequest: requests.ListPublicIpsRequest
  ): Promise<responses.ListPublicIpsResponse> {
    const pathParams = {};

    const queryParams = {
      "limit": listPublicIpsRequest.limit,
      "page": listPublicIpsRequest.page,
      "scope": listPublicIpsRequest.scope,
      "availabilityDomain": listPublicIpsRequest.availabilityDomain,
      "lifetime": listPublicIpsRequest.lifetime,
      "compartmentId": listPublicIpsRequest.compartmentId
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/publicIps",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListPublicIpsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "PublicIp[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.PublicIp objects
   * contained in responses from the listPublicIps operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllPublicIps(
    request: requests.ListPublicIpsRequest
  ): AsyncIterableIterator<models.PublicIp> {
    return paginateRecords(request, req => this.listPublicIps(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listPublicIps operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllPublicIpsResponses(
    request: requests.ListPublicIpsRequest
  ): AsyncIterableIterator<responses.ListPublicIpsResponse> {
    return paginateResponses(request, req => this.listPublicIps(req));
  }

  /**
   * Lists the remote peering connections (RPCs) for the specified DRG and compartment
   * (the RPC's compartment).
   *
   * @param ListRemotePeeringConnectionsRequest
   * @return ListRemotePeeringConnectionsResponse
   * @throws OciError when an error occurs
   */
  public async listRemotePeeringConnections(
    listRemotePeeringConnectionsRequest: requests.ListRemotePeeringConnectionsRequest
  ): Promise<responses.ListRemotePeeringConnectionsResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listRemotePeeringConnectionsRequest.compartmentId,
      "drgId": listRemotePeeringConnectionsRequest.drgId,
      "limit": listRemotePeeringConnectionsRequest.limit,
      "page": listRemotePeeringConnectionsRequest.page
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/remotePeeringConnections",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListRemotePeeringConnectionsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "RemotePeeringConnection[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.RemotePeeringConnection objects
   * contained in responses from the listRemotePeeringConnections operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllRemotePeeringConnections(
    request: requests.ListRemotePeeringConnectionsRequest
  ): AsyncIterableIterator<models.RemotePeeringConnection> {
    return paginateRecords(request, req => this.listRemotePeeringConnections(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listRemotePeeringConnections operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllRemotePeeringConnectionsResponses(
    request: requests.ListRemotePeeringConnectionsRequest
  ): AsyncIterableIterator<responses.ListRemotePeeringConnectionsResponse> {
    return paginateResponses(request, req => this.listRemotePeeringConnections(req));
  }

  /**
   * Lists the route tables in the specified VCN and specified compartment. The response
   * includes the default route table that automatically comes with each VCN, plus any route tables
   * you've created.
   *
   * @param ListRouteTablesRequest
   * @return ListRouteTablesResponse
   * @throws OciError when an error occurs
   */
  public async listRouteTables(
    listRouteTablesRequest: requests.ListRouteTablesRequest
  ): Promise<responses.ListRouteTablesResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listRouteTablesRequest.compartmentId,
      "limit": listRouteTablesRequest.limit,
      "page": listRouteTablesRequest.page,
      "vcnId": listRouteTablesRequest.vcnId,
      "displayName": listRouteTablesRequest.displayName,
      "sortBy": listRouteTablesRequest.sortBy,
      "sortOrder": listRouteTablesRequest.sortOrder,
      "lifecycleState": listRouteTablesRequest.lifecycleState
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/routeTables",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListRouteTablesResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "RouteTable[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.RouteTable objects
   * contained in responses from the listRouteTables operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllRouteTables(
    request: requests.ListRouteTablesRequest
  ): AsyncIterableIterator<models.RouteTable> {
    return paginateRecords(request, req => this.listRouteTables(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listRouteTables operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllRouteTablesResponses(
    request: requests.ListRouteTablesRequest
  ): AsyncIterableIterator<responses.ListRouteTablesResponse> {
    return paginateResponses(request, req => this.listRouteTables(req));
  }

  /**
   * Lists the security lists in the specified VCN and compartment.
   *
   * @param ListSecurityListsRequest
   * @return ListSecurityListsResponse
   * @throws OciError when an error occurs
   */
  public async listSecurityLists(
    listSecurityListsRequest: requests.ListSecurityListsRequest
  ): Promise<responses.ListSecurityListsResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listSecurityListsRequest.compartmentId,
      "limit": listSecurityListsRequest.limit,
      "page": listSecurityListsRequest.page,
      "vcnId": listSecurityListsRequest.vcnId,
      "displayName": listSecurityListsRequest.displayName,
      "sortBy": listSecurityListsRequest.sortBy,
      "sortOrder": listSecurityListsRequest.sortOrder,
      "lifecycleState": listSecurityListsRequest.lifecycleState
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/securityLists",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListSecurityListsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "SecurityList[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.SecurityList objects
   * contained in responses from the listSecurityLists operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllSecurityLists(
    request: requests.ListSecurityListsRequest
  ): AsyncIterableIterator<models.SecurityList> {
    return paginateRecords(request, req => this.listSecurityLists(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listSecurityLists operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllSecurityListsResponses(
    request: requests.ListSecurityListsRequest
  ): AsyncIterableIterator<responses.ListSecurityListsResponse> {
    return paginateResponses(request, req => this.listSecurityLists(req));
  }

  /**
   * Lists the service gateways in the specified compartment. You may optionally specify a VCN OCID
   * to filter the results by VCN.
   *
   * @param ListServiceGatewaysRequest
   * @return ListServiceGatewaysResponse
   * @throws OciError when an error occurs
   */
  public async listServiceGateways(
    listServiceGatewaysRequest: requests.ListServiceGatewaysRequest
  ): Promise<responses.ListServiceGatewaysResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listServiceGatewaysRequest.compartmentId,
      "vcnId": listServiceGatewaysRequest.vcnId,
      "limit": listServiceGatewaysRequest.limit,
      "page": listServiceGatewaysRequest.page,
      "sortBy": listServiceGatewaysRequest.sortBy,
      "sortOrder": listServiceGatewaysRequest.sortOrder,
      "lifecycleState": listServiceGatewaysRequest.lifecycleState
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/serviceGateways",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListServiceGatewaysResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "ServiceGateway[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.ServiceGateway objects
   * contained in responses from the listServiceGateways operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllServiceGateways(
    request: requests.ListServiceGatewaysRequest
  ): AsyncIterableIterator<models.ServiceGateway> {
    return paginateRecords(request, req => this.listServiceGateways(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listServiceGateways operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllServiceGatewaysResponses(
    request: requests.ListServiceGatewaysRequest
  ): AsyncIterableIterator<responses.ListServiceGatewaysResponse> {
    return paginateResponses(request, req => this.listServiceGateways(req));
  }

  /**
   * Lists the available {@link Service} objects that you can enable for a
   * service gateway in this region.
   *
   * @param ListServicesRequest
   * @return ListServicesResponse
   * @throws OciError when an error occurs
   */
  public async listServices(
    listServicesRequest: requests.ListServicesRequest
  ): Promise<responses.ListServicesResponse> {
    const pathParams = {};

    const queryParams = {
      "limit": listServicesRequest.limit,
      "page": listServicesRequest.page
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/services",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListServicesResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "Service[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.Service objects
   * contained in responses from the listServices operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllServices(
    request: requests.ListServicesRequest
  ): AsyncIterableIterator<models.Service> {
    return paginateRecords(request, req => this.listServices(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listServices operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllServicesResponses(
    request: requests.ListServicesRequest
  ): AsyncIterableIterator<responses.ListServicesResponse> {
    return paginateResponses(request, req => this.listServices(req));
  }

  /**
   * Lists the subnets in the specified VCN and the specified compartment.
   *
   * @param ListSubnetsRequest
   * @return ListSubnetsResponse
   * @throws OciError when an error occurs
   */
  public async listSubnets(
    listSubnetsRequest: requests.ListSubnetsRequest
  ): Promise<responses.ListSubnetsResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listSubnetsRequest.compartmentId,
      "limit": listSubnetsRequest.limit,
      "page": listSubnetsRequest.page,
      "vcnId": listSubnetsRequest.vcnId,
      "displayName": listSubnetsRequest.displayName,
      "sortBy": listSubnetsRequest.sortBy,
      "sortOrder": listSubnetsRequest.sortOrder,
      "lifecycleState": listSubnetsRequest.lifecycleState
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/subnets",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListSubnetsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "Subnet[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.Subnet objects
   * contained in responses from the listSubnets operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllSubnets(
    request: requests.ListSubnetsRequest
  ): AsyncIterableIterator<models.Subnet> {
    return paginateRecords(request, req => this.listSubnets(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listSubnets operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllSubnetsResponses(
    request: requests.ListSubnetsRequest
  ): AsyncIterableIterator<responses.ListSubnetsResponse> {
    return paginateResponses(request, req => this.listSubnets(req));
  }

  /**
   * Lists the virtual cloud networks (VCNs) in the specified compartment.
   *
   * @param ListVcnsRequest
   * @return ListVcnsResponse
   * @throws OciError when an error occurs
   */
  public async listVcns(
    listVcnsRequest: requests.ListVcnsRequest
  ): Promise<responses.ListVcnsResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listVcnsRequest.compartmentId,
      "limit": listVcnsRequest.limit,
      "page": listVcnsRequest.page,
      "displayName": listVcnsRequest.displayName,
      "sortBy": listVcnsRequest.sortBy,
      "sortOrder": listVcnsRequest.sortOrder,
      "lifecycleState": listVcnsRequest.lifecycleState
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/vcns",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListVcnsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "Vcn[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.Vcn objects
   * contained in responses from the listVcns operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllVcns(request: requests.ListVcnsRequest): AsyncIterableIterator<models.Vcn> {
    return paginateRecords(request, req => this.listVcns(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listVcns operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllVcnsResponses(
    request: requests.ListVcnsRequest
  ): AsyncIterableIterator<responses.ListVcnsResponse> {
    return paginateResponses(request, req => this.listVcns(req));
  }

  /**
   * The deprecated operation lists available bandwidth levels for virtual circuits. For the compartment ID, provide the OCID of your tenancy (the root compartment).
   *
   * @param ListVirtualCircuitBandwidthShapesRequest
   * @return ListVirtualCircuitBandwidthShapesResponse
   * @throws OciError when an error occurs
   */
  public async listVirtualCircuitBandwidthShapes(
    listVirtualCircuitBandwidthShapesRequest: requests.ListVirtualCircuitBandwidthShapesRequest
  ): Promise<responses.ListVirtualCircuitBandwidthShapesResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listVirtualCircuitBandwidthShapesRequest.compartmentId,
      "limit": listVirtualCircuitBandwidthShapesRequest.limit,
      "page": listVirtualCircuitBandwidthShapesRequest.page
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/virtualCircuitBandwidthShapes",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListVirtualCircuitBandwidthShapesResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "VirtualCircuitBandwidthShape[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.VirtualCircuitBandwidthShape objects
   * contained in responses from the listVirtualCircuitBandwidthShapes operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllVirtualCircuitBandwidthShapes(
    request: requests.ListVirtualCircuitBandwidthShapesRequest
  ): AsyncIterableIterator<models.VirtualCircuitBandwidthShape> {
    return paginateRecords(request, req => this.listVirtualCircuitBandwidthShapes(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listVirtualCircuitBandwidthShapes operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllVirtualCircuitBandwidthShapesResponses(
    request: requests.ListVirtualCircuitBandwidthShapesRequest
  ): AsyncIterableIterator<responses.ListVirtualCircuitBandwidthShapesResponse> {
    return paginateResponses(request, req => this.listVirtualCircuitBandwidthShapes(req));
  }

  /**
   * Lists the public IP prefixes and their details for the specified
   * public virtual circuit.
   *
   * @param ListVirtualCircuitPublicPrefixesRequest
   * @return ListVirtualCircuitPublicPrefixesResponse
   * @throws OciError when an error occurs
   */
  public async listVirtualCircuitPublicPrefixes(
    listVirtualCircuitPublicPrefixesRequest: requests.ListVirtualCircuitPublicPrefixesRequest
  ): Promise<responses.ListVirtualCircuitPublicPrefixesResponse> {
    const pathParams = {
      "{virtualCircuitId}": listVirtualCircuitPublicPrefixesRequest.virtualCircuitId
    };

    const queryParams = {
      "verificationState": listVirtualCircuitPublicPrefixesRequest.verificationState
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/virtualCircuits/{virtualCircuitId}/publicPrefixes",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListVirtualCircuitPublicPrefixesResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "VirtualCircuitPublicPrefix[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Lists the virtual circuits in the specified compartment.
   *
   * @param ListVirtualCircuitsRequest
   * @return ListVirtualCircuitsResponse
   * @throws OciError when an error occurs
   */
  public async listVirtualCircuits(
    listVirtualCircuitsRequest: requests.ListVirtualCircuitsRequest
  ): Promise<responses.ListVirtualCircuitsResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listVirtualCircuitsRequest.compartmentId,
      "limit": listVirtualCircuitsRequest.limit,
      "page": listVirtualCircuitsRequest.page,
      "displayName": listVirtualCircuitsRequest.displayName,
      "sortBy": listVirtualCircuitsRequest.sortBy,
      "sortOrder": listVirtualCircuitsRequest.sortOrder,
      "lifecycleState": listVirtualCircuitsRequest.lifecycleState
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/virtualCircuits",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListVirtualCircuitsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "VirtualCircuit[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.VirtualCircuit objects
   * contained in responses from the listVirtualCircuits operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllVirtualCircuits(
    request: requests.ListVirtualCircuitsRequest
  ): AsyncIterableIterator<models.VirtualCircuit> {
    return paginateRecords(request, req => this.listVirtualCircuits(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listVirtualCircuits operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllVirtualCircuitsResponses(
    request: requests.ListVirtualCircuitsRequest
  ): AsyncIterableIterator<responses.ListVirtualCircuitsResponse> {
    return paginateResponses(request, req => this.listVirtualCircuits(req));
  }

  /**
   * Removes one or more security rules from the specified network security group.
   *
   * @param RemoveNetworkSecurityGroupSecurityRulesRequest
   * @return RemoveNetworkSecurityGroupSecurityRulesResponse
   * @throws OciError when an error occurs
   */
  public async removeNetworkSecurityGroupSecurityRules(
    removeNetworkSecurityGroupSecurityRulesRequest: requests.RemoveNetworkSecurityGroupSecurityRulesRequest
  ): Promise<responses.RemoveNetworkSecurityGroupSecurityRulesResponse> {
    const pathParams = {
      "{networkSecurityGroupId}":
        removeNetworkSecurityGroupSecurityRulesRequest.networkSecurityGroupId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/networkSecurityGroups/{networkSecurityGroupId}/actions/removeSecurityRules",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        removeNetworkSecurityGroupSecurityRulesRequest.removeNetworkSecurityGroupSecurityRulesDetails,
        "RemoveNetworkSecurityGroupSecurityRulesDetails",
        models.RemoveNetworkSecurityGroupSecurityRulesDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.RemoveNetworkSecurityGroupSecurityRulesResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates the specified CPE's display name or tags.
   * Avoid entering confidential information.
   *
   * @param UpdateCpeRequest
   * @return UpdateCpeResponse
   * @throws OciError when an error occurs
   */
  public async updateCpe(
    updateCpeRequest: requests.UpdateCpeRequest
  ): Promise<responses.UpdateCpeResponse> {
    const pathParams = {
      "{cpeId}": updateCpeRequest.cpeId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateCpeRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/cpes/{cpeId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateCpeRequest.updateCpeDetails,
        "UpdateCpeDetails",
        models.UpdateCpeDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateCpeResponse>{},
        body: await response.json(),
        bodyKey: "cpe",
        bodyModel: "model.Cpe",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates the specified cross-connect.
   * @param UpdateCrossConnectRequest
   * @return UpdateCrossConnectResponse
   * @throws OciError when an error occurs
   */
  public async updateCrossConnect(
    updateCrossConnectRequest: requests.UpdateCrossConnectRequest
  ): Promise<responses.UpdateCrossConnectResponse> {
    const pathParams = {
      "{crossConnectId}": updateCrossConnectRequest.crossConnectId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateCrossConnectRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/crossConnects/{crossConnectId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateCrossConnectRequest.updateCrossConnectDetails,
        "UpdateCrossConnectDetails",
        models.UpdateCrossConnectDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateCrossConnectResponse>{},
        body: await response.json(),
        bodyKey: "crossConnect",
        bodyModel: "model.CrossConnect",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates the specified cross-connect group's display name.
   * Avoid entering confidential information.
   *
   * @param UpdateCrossConnectGroupRequest
   * @return UpdateCrossConnectGroupResponse
   * @throws OciError when an error occurs
   */
  public async updateCrossConnectGroup(
    updateCrossConnectGroupRequest: requests.UpdateCrossConnectGroupRequest
  ): Promise<responses.UpdateCrossConnectGroupResponse> {
    const pathParams = {
      "{crossConnectGroupId}": updateCrossConnectGroupRequest.crossConnectGroupId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateCrossConnectGroupRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/crossConnectGroups/{crossConnectGroupId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateCrossConnectGroupRequest.updateCrossConnectGroupDetails,
        "UpdateCrossConnectGroupDetails",
        models.UpdateCrossConnectGroupDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateCrossConnectGroupResponse>{},
        body: await response.json(),
        bodyKey: "crossConnectGroup",
        bodyModel: "model.CrossConnectGroup",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Updates the specified set of DHCP options. You can update the display name or the options
* themselves. Avoid entering confidential information.
* <p>
Note that the `options` object you provide replaces the entire existing set of options.
* 
     * @param UpdateDhcpOptionsRequest
     * @return UpdateDhcpOptionsResponse
     * @throws OciError when an error occurs
     */
  public async updateDhcpOptions(
    updateDhcpOptionsRequest: requests.UpdateDhcpOptionsRequest
  ): Promise<responses.UpdateDhcpOptionsResponse> {
    const pathParams = {
      "{dhcpId}": updateDhcpOptionsRequest.dhcpId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateDhcpOptionsRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/dhcps/{dhcpId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateDhcpOptionsRequest.updateDhcpDetails,
        "UpdateDhcpDetails",
        models.UpdateDhcpDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateDhcpOptionsResponse>{},
        body: await response.json(),
        bodyKey: "dhcpOptions",
        bodyModel: "model.DhcpOptions",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates the specified DRG's display name or tags. Avoid entering confidential information.
   *
   * @param UpdateDrgRequest
   * @return UpdateDrgResponse
   * @throws OciError when an error occurs
   */
  public async updateDrg(
    updateDrgRequest: requests.UpdateDrgRequest
  ): Promise<responses.UpdateDrgResponse> {
    const pathParams = {
      "{drgId}": updateDrgRequest.drgId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateDrgRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/drgs/{drgId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateDrgRequest.updateDrgDetails,
        "UpdateDrgDetails",
        models.UpdateDrgDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateDrgResponse>{},
        body: await response.json(),
        bodyKey: "drg",
        bodyModel: "model.Drg",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates the display name for the specified `DrgAttachment`.
   * Avoid entering confidential information.
   *
   * @param UpdateDrgAttachmentRequest
   * @return UpdateDrgAttachmentResponse
   * @throws OciError when an error occurs
   */
  public async updateDrgAttachment(
    updateDrgAttachmentRequest: requests.UpdateDrgAttachmentRequest
  ): Promise<responses.UpdateDrgAttachmentResponse> {
    const pathParams = {
      "{drgAttachmentId}": updateDrgAttachmentRequest.drgAttachmentId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateDrgAttachmentRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/drgAttachments/{drgAttachmentId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateDrgAttachmentRequest.updateDrgAttachmentDetails,
        "UpdateDrgAttachmentDetails",
        models.UpdateDrgAttachmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateDrgAttachmentResponse>{},
        body: await response.json(),
        bodyKey: "drgAttachment",
        bodyModel: "model.DrgAttachment",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates a flow log configuration.
   *
   * @param UpdateFlowLogConfigRequest
   * @return UpdateFlowLogConfigResponse
   * @throws OciError when an error occurs
   */
  public async updateFlowLogConfig(
    updateFlowLogConfigRequest: requests.UpdateFlowLogConfigRequest
  ): Promise<responses.UpdateFlowLogConfigResponse> {
    const pathParams = {
      "{flowLogConfigId}": updateFlowLogConfigRequest.flowLogConfigId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateFlowLogConfigRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/flowLogConfigs/{flowLogConfigId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateFlowLogConfigRequest.updateFlowLogConfigDetails,
        "UpdateFlowLogConfigDetails",
        models.UpdateFlowLogConfigDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateFlowLogConfigResponse>{},
        body: await response.json(),
        bodyKey: "flowLogConfig",
        bodyModel: "model.FlowLogConfig",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates the specified flow log configuration attachment.
   *
   * @param UpdateFlowLogConfigAttachmentRequest
   * @return UpdateFlowLogConfigAttachmentResponse
   * @throws OciError when an error occurs
   */
  public async updateFlowLogConfigAttachment(
    updateFlowLogConfigAttachmentRequest: requests.UpdateFlowLogConfigAttachmentRequest
  ): Promise<responses.UpdateFlowLogConfigAttachmentResponse> {
    const pathParams = {
      "{flowLogConfigAttachmentId}": updateFlowLogConfigAttachmentRequest.flowLogConfigAttachmentId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateFlowLogConfigAttachmentRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/flowLogConfigAttachments/{flowLogConfigAttachmentId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateFlowLogConfigAttachmentRequest.updateFlowLogConfigAttachmentDetails,
        "UpdateFlowLogConfigAttachmentDetails",
        models.UpdateFlowLogConfigAttachmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateFlowLogConfigAttachmentResponse>{},
        body: await response.json(),
        bodyKey: "flowLogConfigAttachment",
        bodyModel: "model.FlowLogConfigAttachment",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Updates the specified IPSec connection.
* <p>
To update an individual IPSec tunnel's attributes, use
* {@link #updateIPSecConnectionTunnel(UpdateIPSecConnectionTunnelRequest) updateIPSecConnectionTunnel}.
* 
     * @param UpdateIPSecConnectionRequest
     * @return UpdateIPSecConnectionResponse
     * @throws OciError when an error occurs
     */
  public async updateIPSecConnection(
    updateIPSecConnectionRequest: requests.UpdateIPSecConnectionRequest
  ): Promise<responses.UpdateIPSecConnectionResponse> {
    const pathParams = {
      "{ipscId}": updateIPSecConnectionRequest.ipscId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateIPSecConnectionRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/ipsecConnections/{ipscId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateIPSecConnectionRequest.updateIPSecConnectionDetails,
        "UpdateIPSecConnectionDetails",
        models.UpdateIPSecConnectionDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateIPSecConnectionResponse>{},
        body: await response.json(),
        bodyKey: "iPSecConnection",
        bodyModel: "model.IPSecConnection",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates the specified tunnel. This operation lets you change tunnel attributes such as the
   * routing type (BGP dynamic routing or static routing). Here are some important notes:
   * <p>
   * If you change the tunnel's routing type or BGP session configuration, the tunnel will go
   *     down while it's reprovisioned.
   * <p>
   * If you want to switch the tunnel's `routing` from `STATIC` to `BGP`, make sure the tunnel's
   *     BGP session configuration attributes have been set ({@link #bgpSessionInfo(BgpSessionInfoRequest) bgpSessionInfo}).
   * <p>
   * If you want to switch the tunnel's `routing` from `BGP` to `STATIC`, make sure the
   *     {@link IPSecConnection} already has at least one valid CIDR
   *     static route.
   *
   * @param UpdateIPSecConnectionTunnelRequest
   * @return UpdateIPSecConnectionTunnelResponse
   * @throws OciError when an error occurs
   */
  public async updateIPSecConnectionTunnel(
    updateIPSecConnectionTunnelRequest: requests.UpdateIPSecConnectionTunnelRequest
  ): Promise<responses.UpdateIPSecConnectionTunnelResponse> {
    const pathParams = {
      "{ipscId}": updateIPSecConnectionTunnelRequest.ipscId,
      "{tunnelId}": updateIPSecConnectionTunnelRequest.tunnelId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateIPSecConnectionTunnelRequest.ifMatch,
      "opc-request-id": updateIPSecConnectionTunnelRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/ipsecConnections/{ipscId}/tunnels/{tunnelId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateIPSecConnectionTunnelRequest.updateIPSecConnectionTunnelDetails,
        "UpdateIPSecConnectionTunnelDetails",
        models.UpdateIPSecConnectionTunnelDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateIPSecConnectionTunnelResponse>{},
        body: await response.json(),
        bodyKey: "iPSecConnectionTunnel",
        bodyModel: "model.IPSecConnectionTunnel",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates the shared secret (pre-shared key) for the specified tunnel.
   * <p>
   **Important:** If you change the shared secret, the tunnel will go down while it's reprovisioned.
   *
   * @param UpdateIPSecConnectionTunnelSharedSecretRequest
   * @return UpdateIPSecConnectionTunnelSharedSecretResponse
   * @throws OciError when an error occurs
   */
  public async updateIPSecConnectionTunnelSharedSecret(
    updateIPSecConnectionTunnelSharedSecretRequest: requests.UpdateIPSecConnectionTunnelSharedSecretRequest
  ): Promise<responses.UpdateIPSecConnectionTunnelSharedSecretResponse> {
    const pathParams = {
      "{ipscId}": updateIPSecConnectionTunnelSharedSecretRequest.ipscId,
      "{tunnelId}": updateIPSecConnectionTunnelSharedSecretRequest.tunnelId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateIPSecConnectionTunnelSharedSecretRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/ipsecConnections/{ipscId}/tunnels/{tunnelId}/sharedSecret",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateIPSecConnectionTunnelSharedSecretRequest.updateIPSecConnectionTunnelSharedSecretDetails,
        "UpdateIPSecConnectionTunnelSharedSecretDetails",
        models.UpdateIPSecConnectionTunnelSharedSecretDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateIPSecConnectionTunnelSharedSecretResponse>{},
        body: await response.json(),
        bodyKey: "iPSecConnectionTunnelSharedSecret",
        bodyModel: "model.IPSecConnectionTunnelSharedSecret",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Updates the specified internet gateway. You can disable/enable it, or change its display name
* or tags. Avoid entering confidential information.
* <p>
If the gateway is disabled, that means no traffic will flow to/from the internet even if there's
* a route rule that enables that traffic.
* 
     * @param UpdateInternetGatewayRequest
     * @return UpdateInternetGatewayResponse
     * @throws OciError when an error occurs
     */
  public async updateInternetGateway(
    updateInternetGatewayRequest: requests.UpdateInternetGatewayRequest
  ): Promise<responses.UpdateInternetGatewayResponse> {
    const pathParams = {
      "{igId}": updateInternetGatewayRequest.igId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateInternetGatewayRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/internetGateways/{igId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateInternetGatewayRequest.updateInternetGatewayDetails,
        "UpdateInternetGatewayDetails",
        models.UpdateInternetGatewayDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateInternetGatewayResponse>{},
        body: await response.json(),
        bodyKey: "internetGateway",
        bodyModel: "model.InternetGateway",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates the specified IPv6. You must specify the object's OCID.
   * Use this operation if you want to:
   * <p>
   * Move an IPv6 to a different VNIC in the same subnet.
   *   * Enable/disable internet access for an IPv6.
   *   * Change the display name for an IPv6.
   *   * Update resource tags for an IPv6.
   *
   * @param UpdateIpv6Request
   * @return UpdateIpv6Response
   * @throws OciError when an error occurs
   */
  public async updateIpv6(
    updateIpv6Request: requests.UpdateIpv6Request
  ): Promise<responses.UpdateIpv6Response> {
    const pathParams = {
      "{ipv6Id}": updateIpv6Request.ipv6Id
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateIpv6Request.ifMatch,
      "opc-request-id": updateIpv6Request.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/ipv6/{ipv6Id}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateIpv6Request.updateIpv6Details,
        "UpdateIpv6Details",
        models.UpdateIpv6Details.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateIpv6Response>{},
        body: await response.json(),
        bodyKey: "ipv6",
        bodyModel: "model.Ipv6",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates the specified local peering connection.
   *
   * @param UpdateLocalPeeringConnectionRequest
   * @return UpdateLocalPeeringConnectionResponse
   * @throws OciError when an error occurs
   */
  public async updateLocalPeeringConnection(
    updateLocalPeeringConnectionRequest: requests.UpdateLocalPeeringConnectionRequest
  ): Promise<responses.UpdateLocalPeeringConnectionResponse> {
    const pathParams = {
      "{localPeeringConnectionId}": updateLocalPeeringConnectionRequest.localPeeringConnectionId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateLocalPeeringConnectionRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/localPeeringConnections/{localPeeringConnectionId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateLocalPeeringConnectionRequest.updateLocalPeeringConnectionDetails,
        "UpdateLocalPeeringConnectionDetails",
        models.UpdateLocalPeeringConnectionDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateLocalPeeringConnectionResponse>{},
        body: await response.json(),
        bodyKey: "localPeeringConnection",
        bodyModel: "model.LocalPeeringConnection",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates the specified local peering gateway (LPG).
   *
   * @param UpdateLocalPeeringGatewayRequest
   * @return UpdateLocalPeeringGatewayResponse
   * @throws OciError when an error occurs
   */
  public async updateLocalPeeringGateway(
    updateLocalPeeringGatewayRequest: requests.UpdateLocalPeeringGatewayRequest
  ): Promise<responses.UpdateLocalPeeringGatewayResponse> {
    const pathParams = {
      "{localPeeringGatewayId}": updateLocalPeeringGatewayRequest.localPeeringGatewayId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateLocalPeeringGatewayRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/localPeeringGateways/{localPeeringGatewayId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateLocalPeeringGatewayRequest.updateLocalPeeringGatewayDetails,
        "UpdateLocalPeeringGatewayDetails",
        models.UpdateLocalPeeringGatewayDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateLocalPeeringGatewayResponse>{},
        body: await response.json(),
        bodyKey: "localPeeringGateway",
        bodyModel: "model.LocalPeeringGateway",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates the specified NAT gateway.
   *
   * @param UpdateNatGatewayRequest
   * @return UpdateNatGatewayResponse
   * @throws OciError when an error occurs
   */
  public async updateNatGateway(
    updateNatGatewayRequest: requests.UpdateNatGatewayRequest
  ): Promise<responses.UpdateNatGatewayResponse> {
    const pathParams = {
      "{natGatewayId}": updateNatGatewayRequest.natGatewayId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateNatGatewayRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/natGateways/{natGatewayId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateNatGatewayRequest.updateNatGatewayDetails,
        "UpdateNatGatewayDetails",
        models.UpdateNatGatewayDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateNatGatewayResponse>{},
        body: await response.json(),
        bodyKey: "natGateway",
        bodyModel: "model.NatGateway",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Updates the specified network security group.
* <p>
To add or remove an existing VNIC from the group, use
* {@link #updateVnic(UpdateVnicRequest) updateVnic}.
* <p>
To add a VNIC to the group *when you create the VNIC*, specify the NSG's OCID during creation.
* For example, see the `nsgIds` attribute in {@link #createVnicDetails(CreateVnicDetailsRequest) createVnicDetails}.
* <p>
To add or remove security rules from the group, use
* {@link #addNetworkSecurityGroupSecurityRules(AddNetworkSecurityGroupSecurityRulesRequest) addNetworkSecurityGroupSecurityRules}
* or
* {@link #removeNetworkSecurityGroupSecurityRules(RemoveNetworkSecurityGroupSecurityRulesRequest) removeNetworkSecurityGroupSecurityRules}.
* <p>
To edit the contents of existing security rules in the group, use
* {@link #updateNetworkSecurityGroupSecurityRules(UpdateNetworkSecurityGroupSecurityRulesRequest) updateNetworkSecurityGroupSecurityRules}.
* 
     * @param UpdateNetworkSecurityGroupRequest
     * @return UpdateNetworkSecurityGroupResponse
     * @throws OciError when an error occurs
     */
  public async updateNetworkSecurityGroup(
    updateNetworkSecurityGroupRequest: requests.UpdateNetworkSecurityGroupRequest
  ): Promise<responses.UpdateNetworkSecurityGroupResponse> {
    const pathParams = {
      "{networkSecurityGroupId}": updateNetworkSecurityGroupRequest.networkSecurityGroupId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateNetworkSecurityGroupRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/networkSecurityGroups/{networkSecurityGroupId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateNetworkSecurityGroupRequest.updateNetworkSecurityGroupDetails,
        "UpdateNetworkSecurityGroupDetails",
        models.UpdateNetworkSecurityGroupDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateNetworkSecurityGroupResponse>{},
        body: await response.json(),
        bodyKey: "networkSecurityGroup",
        bodyModel: "model.NetworkSecurityGroup",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates one or more security rules in the specified network security group.
   *
   * @param UpdateNetworkSecurityGroupSecurityRulesRequest
   * @return UpdateNetworkSecurityGroupSecurityRulesResponse
   * @throws OciError when an error occurs
   */
  public async updateNetworkSecurityGroupSecurityRules(
    updateNetworkSecurityGroupSecurityRulesRequest: requests.UpdateNetworkSecurityGroupSecurityRulesRequest
  ): Promise<responses.UpdateNetworkSecurityGroupSecurityRulesResponse> {
    const pathParams = {
      "{networkSecurityGroupId}":
        updateNetworkSecurityGroupSecurityRulesRequest.networkSecurityGroupId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/networkSecurityGroups/{networkSecurityGroupId}/actions/updateSecurityRules",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        updateNetworkSecurityGroupSecurityRulesRequest.updateNetworkSecurityGroupSecurityRulesDetails,
        "UpdateNetworkSecurityGroupSecurityRulesDetails",
        models.UpdateNetworkSecurityGroupSecurityRulesDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateNetworkSecurityGroupSecurityRulesResponse>{},
        body: await response.json(),
        bodyKey: "updatedNetworkSecurityGroupSecurityRules",
        bodyModel: "model.UpdatedNetworkSecurityGroupSecurityRules",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Updates the specified private IP. You must specify the object's OCID.
* Use this operation if you want to:
* <p>
  - Move a secondary private IP to a different VNIC in the same subnet.
*   - Change the display name for a secondary private IP.
*   - Change the hostname for a secondary private IP.
* <p>
This operation cannot be used with primary private IPs.
* To update the hostname for the primary IP on a VNIC, use
* {@link #updateVnic(UpdateVnicRequest) updateVnic}.
* 
     * @param UpdatePrivateIpRequest
     * @return UpdatePrivateIpResponse
     * @throws OciError when an error occurs
     */
  public async updatePrivateIp(
    updatePrivateIpRequest: requests.UpdatePrivateIpRequest
  ): Promise<responses.UpdatePrivateIpResponse> {
    const pathParams = {
      "{privateIpId}": updatePrivateIpRequest.privateIpId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updatePrivateIpRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/privateIps/{privateIpId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updatePrivateIpRequest.updatePrivateIpDetails,
        "UpdatePrivateIpDetails",
        models.UpdatePrivateIpDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdatePrivateIpResponse>{},
        body: await response.json(),
        bodyKey: "privateIp",
        bodyModel: "model.PrivateIp",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Updates the specified public IP. You must specify the object's OCID. Use this operation if you want to:
* <p>
* Assign a reserved public IP in your pool to a private IP.
* * Move a reserved public IP to a different private IP.
* * Unassign a reserved public IP from a private IP (which returns it to your pool
* of reserved public IPs).
* * Change the display name or tags for a public IP.
* <p>
Assigning, moving, and unassigning a reserved public IP are asynchronous
* operations. Poll the public IP's `lifecycleState` to determine if the operation
* succeeded.
* <p>
**Note:** When moving a reserved public IP, the target private IP
* must not already have a public IP with `lifecycleState` = ASSIGNING or ASSIGNED. If it
* does, an error is returned. Also, the initial unassignment from the original
* private IP always succeeds, but the assignment to the target private IP is asynchronous and
* could fail silently (for example, if the target private IP is deleted or has a different public IP
* assigned to it in the interim). If that occurs, the public IP remains unassigned and its
* `lifecycleState` switches to AVAILABLE (it is not reassigned to its original private IP).
* You must poll the public IP's `lifecycleState` to determine if the move succeeded.
* <p>
Regarding ephemeral public IPs:
* <p>
* If you want to assign an ephemeral public IP to a primary private IP, use
* {@link #createPublicIp(CreatePublicIpRequest) createPublicIp}.
* * You can't move an ephemeral public IP to a different private IP.
* * If you want to unassign an ephemeral public IP from its private IP, use
* {@link #deletePublicIp(DeletePublicIpRequest) deletePublicIp}, which
* unassigns and deletes the ephemeral public IP.
* <p>
**Note:** If a public IP is assigned to a secondary private
* IP (see {@link PrivateIp}), and you move that secondary
* private IP to another VNIC, the public IP moves with it.
* <p>
**Note:** There's a limit to the number of {@link PublicIp}
* a VNIC or instance can have. If you try to move a reserved public IP
* to a VNIC or instance that has already reached its public IP limit, an error is
* returned. For information about the public IP limits, see
* [Public IP Addresses](https://docs.cloud.oracle.com/Content/Network/Tasks/managingpublicIPs.htm).
* 
     * @param UpdatePublicIpRequest
     * @return UpdatePublicIpResponse
     * @throws OciError when an error occurs
     */
  public async updatePublicIp(
    updatePublicIpRequest: requests.UpdatePublicIpRequest
  ): Promise<responses.UpdatePublicIpResponse> {
    const pathParams = {
      "{publicIpId}": updatePublicIpRequest.publicIpId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updatePublicIpRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/publicIps/{publicIpId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updatePublicIpRequest.updatePublicIpDetails,
        "UpdatePublicIpDetails",
        models.UpdatePublicIpDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdatePublicIpResponse>{},
        body: await response.json(),
        bodyKey: "publicIp",
        bodyModel: "model.PublicIp",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates the specified remote peering connection (RPC).
   *
   * @param UpdateRemotePeeringConnectionRequest
   * @return UpdateRemotePeeringConnectionResponse
   * @throws OciError when an error occurs
   */
  public async updateRemotePeeringConnection(
    updateRemotePeeringConnectionRequest: requests.UpdateRemotePeeringConnectionRequest
  ): Promise<responses.UpdateRemotePeeringConnectionResponse> {
    const pathParams = {
      "{remotePeeringConnectionId}": updateRemotePeeringConnectionRequest.remotePeeringConnectionId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateRemotePeeringConnectionRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/remotePeeringConnections/{remotePeeringConnectionId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateRemotePeeringConnectionRequest.updateRemotePeeringConnectionDetails,
        "UpdateRemotePeeringConnectionDetails",
        models.UpdateRemotePeeringConnectionDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateRemotePeeringConnectionResponse>{},
        body: await response.json(),
        bodyKey: "remotePeeringConnection",
        bodyModel: "model.RemotePeeringConnection",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Updates the specified route table's display name or route rules.
* Avoid entering confidential information.
* <p>
Note that the `routeRules` object you provide replaces the entire existing set of rules.
* 
     * @param UpdateRouteTableRequest
     * @return UpdateRouteTableResponse
     * @throws OciError when an error occurs
     */
  public async updateRouteTable(
    updateRouteTableRequest: requests.UpdateRouteTableRequest
  ): Promise<responses.UpdateRouteTableResponse> {
    const pathParams = {
      "{rtId}": updateRouteTableRequest.rtId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateRouteTableRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/routeTables/{rtId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateRouteTableRequest.updateRouteTableDetails,
        "UpdateRouteTableDetails",
        models.UpdateRouteTableDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateRouteTableResponse>{},
        body: await response.json(),
        bodyKey: "routeTable",
        bodyModel: "model.RouteTable",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Updates the specified security list's display name or rules.
* Avoid entering confidential information.
* <p>
Note that the `egressSecurityRules` or `ingressSecurityRules` objects you provide replace the entire
* existing objects.
* 
     * @param UpdateSecurityListRequest
     * @return UpdateSecurityListResponse
     * @throws OciError when an error occurs
     */
  public async updateSecurityList(
    updateSecurityListRequest: requests.UpdateSecurityListRequest
  ): Promise<responses.UpdateSecurityListResponse> {
    const pathParams = {
      "{securityListId}": updateSecurityListRequest.securityListId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateSecurityListRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/securityLists/{securityListId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateSecurityListRequest.updateSecurityListDetails,
        "UpdateSecurityListDetails",
        models.UpdateSecurityListDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateSecurityListResponse>{},
        body: await response.json(),
        bodyKey: "securityList",
        bodyModel: "model.SecurityList",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates the specified service gateway. The information you provide overwrites the existing
   * attributes of the gateway.
   *
   * @param UpdateServiceGatewayRequest
   * @return UpdateServiceGatewayResponse
   * @throws OciError when an error occurs
   */
  public async updateServiceGateway(
    updateServiceGatewayRequest: requests.UpdateServiceGatewayRequest
  ): Promise<responses.UpdateServiceGatewayResponse> {
    const pathParams = {
      "{serviceGatewayId}": updateServiceGatewayRequest.serviceGatewayId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateServiceGatewayRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/serviceGateways/{serviceGatewayId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateServiceGatewayRequest.updateServiceGatewayDetails,
        "UpdateServiceGatewayDetails",
        models.UpdateServiceGatewayDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateServiceGatewayResponse>{},
        body: await response.json(),
        bodyKey: "serviceGateway",
        bodyModel: "model.ServiceGateway",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates the specified subnet.
   *
   * @param UpdateSubnetRequest
   * @return UpdateSubnetResponse
   * @throws OciError when an error occurs
   */
  public async updateSubnet(
    updateSubnetRequest: requests.UpdateSubnetRequest
  ): Promise<responses.UpdateSubnetResponse> {
    const pathParams = {
      "{subnetId}": updateSubnetRequest.subnetId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateSubnetRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/subnets/{subnetId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateSubnetRequest.updateSubnetDetails,
        "UpdateSubnetDetails",
        models.UpdateSubnetDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateSubnetResponse>{},
        body: await response.json(),
        bodyKey: "subnet",
        bodyModel: "model.Subnet",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates or updates the set of CPE configuration answers for the specified tunnel.
   * The answers correlate to the questions that are specific to the CPE device type (see the
   * `parameters` attribute of {@link CpeDeviceShapeDetail}).
   *
   * @param UpdateTunnelCpeDeviceConfigRequest
   * @return UpdateTunnelCpeDeviceConfigResponse
   * @throws OciError when an error occurs
   */
  public async updateTunnelCpeDeviceConfig(
    updateTunnelCpeDeviceConfigRequest: requests.UpdateTunnelCpeDeviceConfigRequest
  ): Promise<responses.UpdateTunnelCpeDeviceConfigResponse> {
    const pathParams = {
      "{ipscId}": updateTunnelCpeDeviceConfigRequest.ipscId,
      "{tunnelId}": updateTunnelCpeDeviceConfigRequest.tunnelId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateTunnelCpeDeviceConfigRequest.ifMatch,
      "opc-retry-token": updateTunnelCpeDeviceConfigRequest.opcRetryToken,
      "opc-request-id": updateTunnelCpeDeviceConfigRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/ipsecConnections/{ipscId}/tunnels/{tunnelId}/tunnelDeviceConfig",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateTunnelCpeDeviceConfigRequest.updateTunnelCpeDeviceConfigDetails,
        "UpdateTunnelCpeDeviceConfigDetails",
        models.UpdateTunnelCpeDeviceConfigDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateTunnelCpeDeviceConfigResponse>{},
        body: await response.json(),
        bodyKey: "tunnelCpeDeviceConfig",
        bodyModel: "model.TunnelCpeDeviceConfig",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates the specified VCN.
   *
   * @param UpdateVcnRequest
   * @return UpdateVcnResponse
   * @throws OciError when an error occurs
   */
  public async updateVcn(
    updateVcnRequest: requests.UpdateVcnRequest
  ): Promise<responses.UpdateVcnResponse> {
    const pathParams = {
      "{vcnId}": updateVcnRequest.vcnId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateVcnRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/vcns/{vcnId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateVcnRequest.updateVcnDetails,
        "UpdateVcnDetails",
        models.UpdateVcnDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateVcnResponse>{},
        body: await response.json(),
        bodyKey: "vcn",
        bodyModel: "model.Vcn",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Updates the specified virtual circuit. This can be called by
* either the customer who owns the virtual circuit, or the
* provider (when provisioning or de-provisioning the virtual
* circuit from their end). The documentation for
* {@link #updateVirtualCircuitDetails(UpdateVirtualCircuitDetailsRequest) updateVirtualCircuitDetails}
* indicates who can update each property of the virtual circuit.
* <p>
**Important:** If the virtual circuit is working and in the
* PROVISIONED state, updating any of the network-related properties
* (such as the DRG being used, the BGP ASN, and so on) will cause the virtual
* circuit's state to switch to PROVISIONING and the related BGP
* session to go down. After Oracle re-provisions the virtual circuit,
* its state will return to PROVISIONED. Make sure you confirm that
* the associated BGP session is back up. For more information
* about the various states and how to test connectivity, see
* [FastConnect Overview](https://docs.cloud.oracle.com/Content/Network/Concepts/fastconnect.htm).
* <p>
To change the list of public IP prefixes for a public virtual circuit,
* use {@link #bulkAddVirtualCircuitPublicPrefixes(BulkAddVirtualCircuitPublicPrefixesRequest) bulkAddVirtualCircuitPublicPrefixes}
* and
* {@link #bulkDeleteVirtualCircuitPublicPrefixes(BulkDeleteVirtualCircuitPublicPrefixesRequest) bulkDeleteVirtualCircuitPublicPrefixes}.
* Updating the list of prefixes does NOT cause the BGP session to go down. However,
* Oracle must verify the customer's ownership of each added prefix before
* traffic for that prefix will flow across the virtual circuit.
* 
     * @param UpdateVirtualCircuitRequest
     * @return UpdateVirtualCircuitResponse
     * @throws OciError when an error occurs
     */
  public async updateVirtualCircuit(
    updateVirtualCircuitRequest: requests.UpdateVirtualCircuitRequest
  ): Promise<responses.UpdateVirtualCircuitResponse> {
    const pathParams = {
      "{virtualCircuitId}": updateVirtualCircuitRequest.virtualCircuitId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateVirtualCircuitRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/virtualCircuits/{virtualCircuitId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateVirtualCircuitRequest.updateVirtualCircuitDetails,
        "UpdateVirtualCircuitDetails",
        models.UpdateVirtualCircuitDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateVirtualCircuitResponse>{},
        body: await response.json(),
        bodyKey: "virtualCircuit",
        bodyModel: "model.VirtualCircuit",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates the specified VNIC.
   *
   * @param UpdateVnicRequest
   * @return UpdateVnicResponse
   * @throws OciError when an error occurs
   */
  public async updateVnic(
    updateVnicRequest: requests.UpdateVnicRequest
  ): Promise<responses.UpdateVnicResponse> {
    const pathParams = {
      "{vnicId}": updateVnicRequest.vnicId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateVnicRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/vnics/{vnicId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateVnicRequest.updateVnicDetails,
        "UpdateVnicDetails",
        models.UpdateVnicDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateVnicResponse>{},
        body: await response.json(),
        bodyKey: "vnic",
        bodyModel: "model.Vnic",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }
}
