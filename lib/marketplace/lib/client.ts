/**
 * Marketplace Service API
 * Manage applications in Oracle Cloud Infrastructure Marketplace.
 * OpenAPI spec version: 20181001
 *
 *
 * NOTE: This class is auto generated by OracleSDKGenerator.
 * Do not edit the class manually.
 *
 * Copyright (c) 2020, Oracle and/or its affiliates.  All rights reserved.
 * This software is dual-licensed to you under the Universal Permissive License (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl or Apache License 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose either license.
 */

import common = require("oci-common");
import * as requests from "./request";
import * as models from "./model";
import * as responses from "./response";
import { paginateRecords, paginateResponses } from "oci-common";
import { composeResponse, composeRequest } from "oci-common";

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum MarketplaceApiKeys {}

export class MarketplaceClient {
  protected static serviceEndpointTemplate = "https://marketplace.{region}.oci.{secondLevelDomain}";
  protected "_endpoint": string = "";
  protected "_defaultHeaders": any = {};

  protected _httpClient: common.HttpClient;

  constructor(params: common.AuthParams) {
    const requestSigner = params.authenticationDetailsProvider
      ? new common.DefaultRequestSigner(params.authenticationDetailsProvider)
      : null;
    this._httpClient = params.httpClient || new common.FetchHttpClient(requestSigner);

    if (
      params.authenticationDetailsProvider &&
      common.isRegionProvider(params.authenticationDetailsProvider)
    ) {
      const provider: common.RegionProvider = params.authenticationDetailsProvider;
      if (provider.getRegion()) {
        this.region = provider.getRegion();
      }
    }
  }

  /**
   * Sets the endpoint to call (ex, https://www.example.com).
   * @param endpoint The endpoint of the service.
   */
  public set endpoint(endpoint: string) {
    this._endpoint = endpoint;
    this._endpoint = this._endpoint + "/20181001";
  }

  /**
   * Sets the region to call (ex, Region.US_PHOENIX_1).
   * Note, this will call {@link #endpoint(String) endpoint} after resolving the endpoint.
   * @param region The region of the service.
   */
  public set region(region: common.Region) {
    this.endpoint = common.EndpointBuilder.createEndpointFromRegion(
      MarketplaceClient.serviceEndpointTemplate,
      region
    );
  }

  /**
   * Sets the regionId to call (ex, 'us-phoenix-1').
   *
   * Note, this will first try to map the region ID to a known Region and call {@link #region(Region) region}.
   * If no known Region could be determined, it will create an endpoint assuming its in default Realm OC1
   * and then call {@link #endpoint(String) endpoint}.
   * @param regionId The public region ID.
   */
  public set regionId(regionId: string) {
    this.endpoint = common.EndpointBuilder.createEndpointFromRegionId(
      MarketplaceClient.serviceEndpointTemplate,
      regionId
    );
  }

  /**
   * Accepts a terms of use agreement for a specific package version of a listing. You must accept all
   * terms of use for a package before you can deploy the package.
   *
   * @param CreateAcceptedAgreementRequest
   * @return CreateAcceptedAgreementResponse
   * @throws OciError when an error occurs
   */
  public async createAcceptedAgreement(
    createAcceptedAgreementRequest: requests.CreateAcceptedAgreementRequest
  ): Promise<responses.CreateAcceptedAgreementResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-request-id": createAcceptedAgreementRequest.opcRequestId,
      "opc-retry-token": createAcceptedAgreementRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/acceptedAgreements",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createAcceptedAgreementRequest.createAcceptedAgreementDetails,
        "CreateAcceptedAgreementDetails",
        models.CreateAcceptedAgreementDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateAcceptedAgreementResponse>{},
        body: await response.json(),
        bodyKey: "acceptedAgreement",
        bodyModel: "model.AcceptedAgreement",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Removes a previously accepted terms of use agreement from the list of agreements that Marketplace checks
   * before initiating a deployment. Listings in the Marketplace that require acceptance of the specified terms
   * of use can no longer be deployed, but existing deployments aren't affected.
   *
   * @param DeleteAcceptedAgreementRequest
   * @return DeleteAcceptedAgreementResponse
   * @throws OciError when an error occurs
   */
  public async deleteAcceptedAgreement(
    deleteAcceptedAgreementRequest: requests.DeleteAcceptedAgreementRequest
  ): Promise<responses.DeleteAcceptedAgreementResponse> {
    const pathParams = {
      "{acceptedAgreementId}": deleteAcceptedAgreementRequest.acceptedAgreementId
    };

    const queryParams = {
      "signature": deleteAcceptedAgreementRequest.signature
    };

    let headerParams = {
      "opc-request-id": deleteAcceptedAgreementRequest.opcRequestId,
      "if-match": deleteAcceptedAgreementRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/acceptedAgreements/{acceptedAgreementId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteAcceptedAgreementResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the details of a specific, previously accepted terms of use agreement.
   *
   * @param GetAcceptedAgreementRequest
   * @return GetAcceptedAgreementResponse
   * @throws OciError when an error occurs
   */
  public async getAcceptedAgreement(
    getAcceptedAgreementRequest: requests.GetAcceptedAgreementRequest
  ): Promise<responses.GetAcceptedAgreementResponse> {
    const pathParams = {
      "{acceptedAgreementId}": getAcceptedAgreementRequest.acceptedAgreementId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getAcceptedAgreementRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/acceptedAgreements/{acceptedAgreementId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetAcceptedAgreementResponse>{},
        body: await response.json(),
        bodyKey: "acceptedAgreement",
        bodyModel: "model.AcceptedAgreement",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Returns a terms of use agreement for a package with a time-based signature that can be used to
   * accept the agreement.
   *
   * @param GetAgreementRequest
   * @return GetAgreementResponse
   * @throws OciError when an error occurs
   */
  public async getAgreement(
    getAgreementRequest: requests.GetAgreementRequest
  ): Promise<responses.GetAgreementResponse> {
    const pathParams = {
      "{listingId}": getAgreementRequest.listingId,
      "{packageVersion}": getAgreementRequest.packageVersion,
      "{agreementId}": getAgreementRequest.agreementId
    };

    const queryParams = {
      "compartmentId": getAgreementRequest.compartmentId
    };

    let headerParams = {
      "opc-request-id": getAgreementRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/listings/{listingId}/packages/{packageVersion}/agreements/{agreementId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetAgreementResponse>{},
        body: await response.json(),
        bodyKey: "agreement",
        bodyModel: "model.Agreement",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Gets detailed information about a listing, including the listing's name, version, description, and
* resources.
* <p>
If you plan to launch an instance from an image listing, you must first subscribe to the listing. When
* you launch the instance, you also need to provide the image ID of the listing resource version that you want.
* <p>
Subscribing to the listing requires you to first get a signature from the terms of use agreement for the
* listing resource version. To get the signature, issue a [GetAppCatalogListingAgreements](https://docs.cloud.oracle.com/en-us/iaas/api/#/en/iaas/latest/AppCatalogListingResourceVersionAgreements/GetAppCatalogListingAgreements) API call.
* The [AppCatalogListingResourceVersionAgreements](https://docs.cloud.oracle.com/en-us/iaas/api/#/en/iaas/latest/AppCatalogListingResourceVersionAgreements) object, including
* its signature, is returned in the response. With the signature for the terms of use agreement for the desired
* listing resource version, create a subscription by issuing a
* [CreateAppCatalogSubscription](https://docs.cloud.oracle.com/en-us/iaas/api/#/en/iaas/latest/AppCatalogSubscription/CreateAppCatalogSubscription) API call.
* <p>
To get the image ID to launch an instance, issue a [GetAppCatalogListingResourceVersion](https://docs.cloud.oracle.com/en-us/iaas/api/#/en/iaas/latest/AppCatalogListingResourceVersion/GetAppCatalogListingResourceVersion) API call.
* Lastly, to launch the instance, use the image ID of the listing resource version to issue a [LaunchInstance](https://docs.cloud.oracle.com/en-us/iaas/api/#/en/iaas/latest/Instance/LaunchInstance) API call.
* 
     * @param GetListingRequest
     * @return GetListingResponse
     * @throws OciError when an error occurs
     */
  public async getListing(
    getListingRequest: requests.GetListingRequest
  ): Promise<responses.GetListingResponse> {
    const pathParams = {
      "{listingId}": getListingRequest.listingId
    };

    const queryParams = {
      "compartmentId": getListingRequest.compartmentId
    };

    let headerParams = {
      "opc-request-id": getListingRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/listings/{listingId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetListingResponse>{},
        body: await response.json(),
        bodyKey: "listing",
        bodyModel: "model.Listing",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Get the details of the specified version of a package, including information needed to launch the package.
* <p>
If you plan to launch an instance from an image listing, you must first subscribe to the listing. When
* you launch the instance, you also need to provide the image ID of the listing resource version that you want.
* <p>
Subscribing to the listing requires you to first get a signature from the terms of use agreement for the
* listing resource version. To get the signature, issue a [GetAppCatalogListingAgreements](https://docs.cloud.oracle.com/en-us/iaas/api/#/en/iaas/latest/AppCatalogListingResourceVersionAgreements/GetAppCatalogListingAgreements) API call.
* The [AppCatalogListingResourceVersionAgreements](https://docs.cloud.oracle.com/en-us/iaas/api/#/en/iaas/latest/AppCatalogListingResourceVersionAgreements) object, including
* its signature, is returned in the response. With the signature for the terms of use agreement for the desired
* listing resource version, create a subscription by issuing a
* [CreateAppCatalogSubscription](https://docs.cloud.oracle.com/en-us/iaas/api/#/en/iaas/latest/AppCatalogSubscription/CreateAppCatalogSubscription) API call.
* <p>
To get the image ID to launch an instance, issue a [GetAppCatalogListingResourceVersion](https://docs.cloud.oracle.com/en-us/iaas/api/#/en/iaas/latest/AppCatalogListingResourceVersion/GetAppCatalogListingResourceVersion) API call.
* Lastly, to launch the instance, use the image ID of the listing resource version to issue a [LaunchInstance](https://docs.cloud.oracle.com/en-us/iaas/api/#/en/iaas/latest/Instance/LaunchInstance) API call.
* 
     * @param GetPackageRequest
     * @return GetPackageResponse
     * @throws OciError when an error occurs
     */
  public async getPackage(
    getPackageRequest: requests.GetPackageRequest
  ): Promise<responses.GetPackageResponse> {
    const pathParams = {
      "{listingId}": getPackageRequest.listingId,
      "{packageVersion}": getPackageRequest.packageVersion
    };

    const queryParams = {
      "compartmentId": getPackageRequest.compartmentId
    };

    let headerParams = {
      "opc-request-id": getPackageRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/listings/{listingId}/packages/{packageVersion}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetPackageResponse>{},
        body: await response.json(),
        bodyKey: "listingPackage",
        bodyModel: "model.ListingPackage",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Lists the terms of use agreements that have been accepted in the specified compartment.
   * You can filter results by specifying query parameters.
   *
   * @param ListAcceptedAgreementsRequest
   * @return ListAcceptedAgreementsResponse
   * @throws OciError when an error occurs
   */
  public async listAcceptedAgreements(
    listAcceptedAgreementsRequest: requests.ListAcceptedAgreementsRequest
  ): Promise<responses.ListAcceptedAgreementsResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listAcceptedAgreementsRequest.compartmentId,
      "displayName": listAcceptedAgreementsRequest.displayName,
      "listingId": listAcceptedAgreementsRequest.listingId,
      "packageVersion": listAcceptedAgreementsRequest.packageVersion,
      "acceptedAgreementId": listAcceptedAgreementsRequest.acceptedAgreementId,
      "sortBy": listAcceptedAgreementsRequest.sortBy,
      "sortOrder": listAcceptedAgreementsRequest.sortOrder,
      "limit": listAcceptedAgreementsRequest.limit,
      "page": listAcceptedAgreementsRequest.page
    };

    let headerParams = {
      "opc-request-id": listAcceptedAgreementsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/acceptedAgreements",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListAcceptedAgreementsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "AcceptedAgreementSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.AcceptedAgreementSummary objects
   * contained in responses from the listAcceptedAgreements operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllAcceptedAgreements(
    request: requests.ListAcceptedAgreementsRequest
  ): AsyncIterableIterator<models.AcceptedAgreementSummary> {
    return paginateRecords(request, req => this.listAcceptedAgreements(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listAcceptedAgreements operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllAcceptedAgreementsResponses(
    request: requests.ListAcceptedAgreementsRequest
  ): AsyncIterableIterator<responses.ListAcceptedAgreementsResponse> {
    return paginateResponses(request, req => this.listAcceptedAgreements(req));
  }

  /**
   * Returns the terms of use agreements that must be accepted before you can deploy the specified version of a package.
   *
   * @param ListAgreementsRequest
   * @return ListAgreementsResponse
   * @throws OciError when an error occurs
   */
  public async listAgreements(
    listAgreementsRequest: requests.ListAgreementsRequest
  ): Promise<responses.ListAgreementsResponse> {
    const pathParams = {
      "{listingId}": listAgreementsRequest.listingId,
      "{packageVersion}": listAgreementsRequest.packageVersion
    };

    const queryParams = {
      "limit": listAgreementsRequest.limit,
      "page": listAgreementsRequest.page,
      "compartmentId": listAgreementsRequest.compartmentId
    };

    let headerParams = {
      "opc-request-id": listAgreementsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/listings/{listingId}/packages/{packageVersion}/agreements",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListAgreementsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "AgreementSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.AgreementSummary objects
   * contained in responses from the listAgreements operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllAgreements(
    request: requests.ListAgreementsRequest
  ): AsyncIterableIterator<models.AgreementSummary> {
    return paginateRecords(request, req => this.listAgreements(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listAgreements operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllAgreementsResponses(
    request: requests.ListAgreementsRequest
  ): AsyncIterableIterator<responses.ListAgreementsResponse> {
    return paginateResponses(request, req => this.listAgreements(req));
  }

  /**
   * Gets the list of all the categories for listings published to Oracle Cloud Infrastructure Marketplace. Categories apply
   * to the software product provided by the listing.
   *
   * @param ListCategoriesRequest
   * @return ListCategoriesResponse
   * @throws OciError when an error occurs
   */
  public async listCategories(
    listCategoriesRequest: requests.ListCategoriesRequest
  ): Promise<responses.ListCategoriesResponse> {
    const pathParams = {};

    const queryParams = {
      "limit": listCategoriesRequest.limit,
      "page": listCategoriesRequest.page,
      "compartmentId": listCategoriesRequest.compartmentId
    };

    let headerParams = {
      "opc-request-id": listCategoriesRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/categories",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListCategoriesResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "CategorySummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.CategorySummary objects
   * contained in responses from the listCategories operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllCategories(
    request: requests.ListCategoriesRequest
  ): AsyncIterableIterator<models.CategorySummary> {
    return paginateRecords(request, req => this.listCategories(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listCategories operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllCategoriesResponses(
    request: requests.ListCategoriesRequest
  ): AsyncIterableIterator<responses.ListCategoriesResponse> {
    return paginateResponses(request, req => this.listCategories(req));
  }

  /**
     * Gets a list of listings from Oracle Cloud Infrastructure Marketplace by searching keywords and
* filtering according to listing attributes.
* <p>
If you plan to launch an instance from an image listing, you must first subscribe to the listing. When
* you launch the instance, you also need to provide the image ID of the listing resource version that you want.
* <p>
Subscribing to the listing requires you to first get a signature from the terms of use agreement for the
* listing resource version. To get the signature, issue a [GetAppCatalogListingAgreements](https://docs.cloud.oracle.com/en-us/iaas/api/#/en/iaas/latest/AppCatalogListingResourceVersionAgreements/GetAppCatalogListingAgreements) API call.
* The [AppCatalogListingResourceVersionAgreements](https://docs.cloud.oracle.com/en-us/iaas/api/#/en/iaas/latest/AppCatalogListingResourceVersionAgreements) object, including
* its signature, is returned in the response. With the signature for the terms of use agreement for the desired
* listing resource version, create a subscription by issuing a
* [CreateAppCatalogSubscription](https://docs.cloud.oracle.com/en-us/iaas/api/#/en/iaas/latest/AppCatalogSubscription/CreateAppCatalogSubscription) API call.
* <p>
To get the image ID to launch an instance, issue a [GetAppCatalogListingResourceVersion](https://docs.cloud.oracle.com/en-us/iaas/api/#/en/iaas/latest/AppCatalogListingResourceVersion/GetAppCatalogListingResourceVersion) API call.
* Lastly, to launch the instance, use the image ID of the listing resource version to issue a [LaunchInstance](https://docs.cloud.oracle.com/en-us/iaas/api/#/en/iaas/latest/Instance/LaunchInstance) API call.
* 
     * @param ListListingsRequest
     * @return ListListingsResponse
     * @throws OciError when an error occurs
     */
  public async listListings(
    listListingsRequest: requests.ListListingsRequest
  ): Promise<responses.ListListingsResponse> {
    const pathParams = {};

    const queryParams = {
      "name": listListingsRequest.name,
      "listingId": listListingsRequest.listingId,
      "publisherId": listListingsRequest.publisherId,
      "packageType": listListingsRequest.packageType,
      "limit": listListingsRequest.limit,
      "page": listListingsRequest.page,
      "sortBy": listListingsRequest.sortBy,
      "sortOrder": listListingsRequest.sortOrder,
      "category": listListingsRequest.category,
      "pricing": listListingsRequest.pricing,
      "isFeatured": listListingsRequest.isFeatured,
      "compartmentId": listListingsRequest.compartmentId
    };

    let headerParams = {
      "opc-request-id": listListingsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/listings",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListListingsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "ListingSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.ListingSummary objects
   * contained in responses from the listListings operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllListings(
    request: requests.ListListingsRequest
  ): AsyncIterableIterator<models.ListingSummary> {
    return paginateRecords(request, req => this.listListings(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listListings operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllListingsResponses(
    request: requests.ListListingsRequest
  ): AsyncIterableIterator<responses.ListListingsResponse> {
    return paginateResponses(request, req => this.listListings(req));
  }

  /**
     * Gets the list of packages for a listing.
* <p>
If you plan to launch an instance from an image listing, you must first subscribe to the listing. When
* you launch the instance, you also need to provide the image ID of the listing resource version that you want.
* <p>
Subscribing to the listing requires you to first get a signature from the terms of use agreement for the
* listing resource version. To get the signature, issue a [GetAppCatalogListingAgreements](https://docs.cloud.oracle.com/en-us/iaas/api/#/en/iaas/latest/AppCatalogListingResourceVersionAgreements/GetAppCatalogListingAgreements) API call.
* The [AppCatalogListingResourceVersionAgreements](https://docs.cloud.oracle.com/en-us/iaas/api/#/en/iaas/latest/AppCatalogListingResourceVersionAgreements) object, including
* its signature, is returned in the response. With the signature for the terms of use agreement for the desired
* listing resource version, create a subscription by issuing a
* [CreateAppCatalogSubscription](https://docs.cloud.oracle.com/en-us/iaas/api/#/en/iaas/latest/AppCatalogSubscription/CreateAppCatalogSubscription) API call.
* <p>
To get the image ID to launch an instance, issue a [GetAppCatalogListingResourceVersion](https://docs.cloud.oracle.com/en-us/iaas/api/#/en/iaas/latest/AppCatalogListingResourceVersion/GetAppCatalogListingResourceVersion) API call.
* Lastly, to launch the instance, use the image ID of the listing resource version to issue a [LaunchInstance](https://docs.cloud.oracle.com/en-us/iaas/api/#/en/iaas/latest/Instance/LaunchInstance) API call.
* 
     * @param ListPackagesRequest
     * @return ListPackagesResponse
     * @throws OciError when an error occurs
     */
  public async listPackages(
    listPackagesRequest: requests.ListPackagesRequest
  ): Promise<responses.ListPackagesResponse> {
    const pathParams = {
      "{listingId}": listPackagesRequest.listingId
    };

    const queryParams = {
      "packageVersion": listPackagesRequest.packageVersion,
      "packageType": listPackagesRequest.packageType,
      "limit": listPackagesRequest.limit,
      "page": listPackagesRequest.page,
      "sortBy": listPackagesRequest.sortBy,
      "sortOrder": listPackagesRequest.sortOrder,
      "compartmentId": listPackagesRequest.compartmentId
    };

    let headerParams = {
      "opc-request-id": listPackagesRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/listings/{listingId}/packages",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListPackagesResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "ListingPackageSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.ListingPackageSummary objects
   * contained in responses from the listPackages operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllPackages(
    request: requests.ListPackagesRequest
  ): AsyncIterableIterator<models.ListingPackageSummary> {
    return paginateRecords(request, req => this.listPackages(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listPackages operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllPackagesResponses(
    request: requests.ListPackagesRequest
  ): AsyncIterableIterator<responses.ListPackagesResponse> {
    return paginateResponses(request, req => this.listPackages(req));
  }

  /**
   * Gets the list of all the publishers of listings available in Oracle Cloud Infrastructure Marketplace.
   *
   * @param ListPublishersRequest
   * @return ListPublishersResponse
   * @throws OciError when an error occurs
   */
  public async listPublishers(
    listPublishersRequest: requests.ListPublishersRequest
  ): Promise<responses.ListPublishersResponse> {
    const pathParams = {};

    const queryParams = {
      "publisherId": listPublishersRequest.publisherId,
      "limit": listPublishersRequest.limit,
      "page": listPublishersRequest.page,
      "compartmentId": listPublishersRequest.compartmentId
    };

    let headerParams = {
      "opc-request-id": listPublishersRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/publishers",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListPublishersResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "PublisherSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.PublisherSummary objects
   * contained in responses from the listPublishers operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllPublishers(
    request: requests.ListPublishersRequest
  ): AsyncIterableIterator<models.PublisherSummary> {
    return paginateRecords(request, req => this.listPublishers(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listPublishers operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllPublishersResponses(
    request: requests.ListPublishersRequest
  ): AsyncIterableIterator<responses.ListPublishersResponse> {
    return paginateResponses(request, req => this.listPublishers(req));
  }

  /**
   * Lists available types of reports for the compartment.
   * @param ListReportTypesRequest
   * @return ListReportTypesResponse
   * @throws OciError when an error occurs
   */
  public async listReportTypes(
    listReportTypesRequest: requests.ListReportTypesRequest
  ): Promise<responses.ListReportTypesResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listReportTypesRequest.compartmentId,
      "page": listReportTypesRequest.page
    };

    let headerParams = {
      "opc-request-id": listReportTypesRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/reportTypes",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListReportTypesResponse>{},
        body: await response.json(),
        bodyKey: "reportTypeCollection",
        bodyModel: "model.ReportTypeCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Lists reports in the compartment that match the specified report type and date.
   * @param ListReportsRequest
   * @return ListReportsResponse
   * @throws OciError when an error occurs
   */
  public async listReports(
    listReportsRequest: requests.ListReportsRequest
  ): Promise<responses.ListReportsResponse> {
    const pathParams = {};

    const queryParams = {
      "reportType": listReportsRequest.reportType,
      "date": listReportsRequest.date,
      "compartmentId": listReportsRequest.compartmentId,
      "page": listReportsRequest.page
    };

    let headerParams = {
      "opc-request-id": listReportsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/reports",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListReportsResponse>{},
        body: await response.json(),
        bodyKey: "reportCollection",
        bodyModel: "model.ReportCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates the display name or tags associated with a listing's previously accepted terms of use agreement.
   *
   * @param UpdateAcceptedAgreementRequest
   * @return UpdateAcceptedAgreementResponse
   * @throws OciError when an error occurs
   */
  public async updateAcceptedAgreement(
    updateAcceptedAgreementRequest: requests.UpdateAcceptedAgreementRequest
  ): Promise<responses.UpdateAcceptedAgreementResponse> {
    const pathParams = {
      "{acceptedAgreementId}": updateAcceptedAgreementRequest.acceptedAgreementId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": updateAcceptedAgreementRequest.opcRequestId,
      "opc-retry-token": updateAcceptedAgreementRequest.opcRetryToken,
      "if-match": updateAcceptedAgreementRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/acceptedAgreements/{acceptedAgreementId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateAcceptedAgreementRequest.updateAcceptedAgreementDetails,
        "UpdateAcceptedAgreementDetails",
        models.UpdateAcceptedAgreementDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateAcceptedAgreementResponse>{},
        body: await response.json(),
        bodyKey: "acceptedAgreement",
        bodyModel: "model.AcceptedAgreement",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }
}
