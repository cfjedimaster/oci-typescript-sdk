/**
 * Load Balancing API
 * API for the Load Balancing service. Use this API to manage load balancers, backend sets, and related items. For more
information, see [Overview of Load Balancing](/iaas/Content/Balance/Concepts/balanceoverview.htm).

 * OpenAPI spec version: 20170115
 * 
 *
 * NOTE: This class is auto generated by OracleSDKGenerator.
 * Do not edit the class manually.
 *
 * Copyright (c) 2020, Oracle and/or its affiliates.  All rights reserved.
 * This software is dual-licensed to you under the Universal Permissive License (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl or Apache License 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose either license.
 */

import common = require("oci-common");
import * as requests from "./request";
import * as models from "./model";
import * as responses from "./response";
import { paginateRecords, paginateResponses } from "oci-common";
import { LoadBalancerWaiter } from "./loadbalancer-waiter";
import { composeResponse, composeRequest } from "oci-common";

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum LoadBalancerApiKeys {}

export class LoadBalancerClient {
  protected static serviceEndpointTemplate = "https://iaas.{region}.{secondLevelDomain}";
  protected "_endpoint": string = "";
  protected "_defaultHeaders": any = {};
  protected "_waiters": LoadBalancerWaiter;

  protected _httpClient: common.HttpClient;

  constructor(params: common.AuthParams) {
    const requestSigner = params.authenticationDetailsProvider
      ? new common.DefaultRequestSigner(params.authenticationDetailsProvider)
      : null;
    this._httpClient = params.httpClient || new common.FetchHttpClient(requestSigner);

    if (
      params.authenticationDetailsProvider &&
      common.isRegionProvider(params.authenticationDetailsProvider)
    ) {
      const provider: common.RegionProvider = params.authenticationDetailsProvider;
      if (provider.getRegion()) {
        this.region = provider.getRegion();
      }
    }
  }

  /**
   * Sets the endpoint to call (ex, https://www.example.com).
   * @param endpoint The endpoint of the service.
   */
  public set endpoint(endpoint: string) {
    this._endpoint = endpoint;
    this._endpoint = this._endpoint + "/20170115";
  }

  /**
   * Sets the region to call (ex, Region.US_PHOENIX_1).
   * Note, this will call {@link #endpoint(String) endpoint} after resolving the endpoint.
   * @param region The region of the service.
   */
  public set region(region: common.Region) {
    this.endpoint = common.EndpointBuilder.createEndpointFromRegion(
      LoadBalancerClient.serviceEndpointTemplate,
      region
    );
  }

  /**
   * Sets the regionId to call (ex, 'us-phoenix-1').
   *
   * Note, this will first try to map the region ID to a known Region and call {@link #region(Region) region}.
   * If no known Region could be determined, it will create an endpoint assuming its in default Realm OC1
   * and then call {@link #endpoint(String) endpoint}.
   * @param regionId The public region ID.
   */
  public set regionId(regionId: string) {
    this.endpoint = common.EndpointBuilder.createEndpointFromRegionId(
      LoadBalancerClient.serviceEndpointTemplate,
      regionId
    );
  }

  /**
   * Creates a new LoadBalancerWaiter for resources for this service.
   *
   * @param config The waiter configuration for termination and delay strategy
   * @return The service waiters.
   */
  public createWaiters(config?: common.WaiterConfiguration): LoadBalancerWaiter {
    this._waiters = new LoadBalancerWaiter(this, config);
    return this._waiters;
  }

  /**
   * Gets the waiters available for resources for this service.
   *
   * @return The service waiters.
   */
  public getWaiters(): LoadBalancerWaiter {
    if (this._waiters) {
      return this._waiters;
    }
    throw Error("Waiters do not exist. Please create waiters.");
  }

  /**
   * Moves a load balancer into a different compartment within the same tenancy. For information about moving resources
   * between compartments, see [Moving Resources to a Different Compartment](https://docs.cloud.oracle.com/iaas/Content/Identity/Tasks/managingcompartments.htm#moveRes).
   *
   * @param ChangeLoadBalancerCompartmentRequest
   * @return ChangeLoadBalancerCompartmentResponse
   * @throws OciError when an error occurs
   */
  public async changeLoadBalancerCompartment(
    changeLoadBalancerCompartmentRequest: requests.ChangeLoadBalancerCompartmentRequest
  ): Promise<responses.ChangeLoadBalancerCompartmentResponse> {
    const pathParams = {
      "{loadBalancerId}": changeLoadBalancerCompartmentRequest.loadBalancerId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": changeLoadBalancerCompartmentRequest.opcRequestId,
      "opc-retry-token": changeLoadBalancerCompartmentRequest.opcRetryToken,
      "if-match": changeLoadBalancerCompartmentRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/loadBalancers/{loadBalancerId}/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeLoadBalancerCompartmentRequest.changeLoadBalancerCompartmentDetails,
        "ChangeLoadBalancerCompartmentDetails",
        models.ChangeLoadBalancerCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeLoadBalancerCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Adds a backend server to a backend set.
   * @param CreateBackendRequest
   * @return CreateBackendResponse
   * @throws OciError when an error occurs
   */
  public async createBackend(
    createBackendRequest: requests.CreateBackendRequest
  ): Promise<responses.CreateBackendResponse> {
    const pathParams = {
      "{loadBalancerId}": createBackendRequest.loadBalancerId,
      "{backendSetName}": createBackendRequest.backendSetName
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": createBackendRequest.opcRequestId,
      "opc-retry-token": createBackendRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/loadBalancers/{loadBalancerId}/backendSets/{backendSetName}/backends",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createBackendRequest.createBackendDetails,
        "CreateBackendDetails",
        models.CreateBackendDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateBackendResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Adds a backend set to a load balancer.
   * @param CreateBackendSetRequest
   * @return CreateBackendSetResponse
   * @throws OciError when an error occurs
   */
  public async createBackendSet(
    createBackendSetRequest: requests.CreateBackendSetRequest
  ): Promise<responses.CreateBackendSetResponse> {
    const pathParams = {
      "{loadBalancerId}": createBackendSetRequest.loadBalancerId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": createBackendSetRequest.opcRequestId,
      "opc-retry-token": createBackendSetRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/loadBalancers/{loadBalancerId}/backendSets",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createBackendSetRequest.createBackendSetDetails,
        "CreateBackendSetDetails",
        models.CreateBackendSetDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateBackendSetResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates an asynchronous request to add an SSL certificate bundle.
   * @param CreateCertificateRequest
   * @return CreateCertificateResponse
   * @throws OciError when an error occurs
   */
  public async createCertificate(
    createCertificateRequest: requests.CreateCertificateRequest
  ): Promise<responses.CreateCertificateResponse> {
    const pathParams = {
      "{loadBalancerId}": createCertificateRequest.loadBalancerId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": createCertificateRequest.opcRequestId,
      "opc-retry-token": createCertificateRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/loadBalancers/{loadBalancerId}/certificates",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createCertificateRequest.createCertificateDetails,
        "CreateCertificateDetails",
        models.CreateCertificateDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateCertificateResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Adds a hostname resource to the specified load balancer. For more information, see
   * [Managing Request Routing](https://docs.cloud.oracle.com/Content/Balance/Tasks/managingrequest.htm).
   *
   * @param CreateHostnameRequest
   * @return CreateHostnameResponse
   * @throws OciError when an error occurs
   */
  public async createHostname(
    createHostnameRequest: requests.CreateHostnameRequest
  ): Promise<responses.CreateHostnameResponse> {
    const pathParams = {
      "{loadBalancerId}": createHostnameRequest.loadBalancerId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": createHostnameRequest.opcRequestId,
      "opc-retry-token": createHostnameRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/loadBalancers/{loadBalancerId}/hostnames",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createHostnameRequest.createHostnameDetails,
        "CreateHostnameDetails",
        models.CreateHostnameDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateHostnameResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Adds a listener to a load balancer.
   * @param CreateListenerRequest
   * @return CreateListenerResponse
   * @throws OciError when an error occurs
   */
  public async createListener(
    createListenerRequest: requests.CreateListenerRequest
  ): Promise<responses.CreateListenerResponse> {
    const pathParams = {
      "{loadBalancerId}": createListenerRequest.loadBalancerId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": createListenerRequest.opcRequestId,
      "opc-retry-token": createListenerRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/loadBalancers/{loadBalancerId}/listeners",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createListenerRequest.createListenerDetails,
        "CreateListenerDetails",
        models.CreateListenerDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateListenerResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Creates a new load balancer in the specified compartment. For general information about load balancers,
* see [Overview of the Load Balancing Service](https://docs.cloud.oracle.com/Content/Balance/Concepts/balanceoverview.htm).
* <p>
For the purposes of access control, you must provide the OCID of the compartment where you want
* the load balancer to reside. Notice that the load balancer doesn't have to be in the same compartment as the VCN
* or backend set. If you're not sure which compartment to use, put the load balancer in the same compartment as the VCN.
* For information about access control and compartments, see
* [Overview of the IAM Service](https://docs.cloud.oracle.com/Content/Identity/Concepts/overview.htm).
* <p>
You must specify a display name for the load balancer. It does not have to be unique, and you can change it.
* <p>
For information about Availability Domains, see
* [Regions and Availability Domains](https://docs.cloud.oracle.com/Content/General/Concepts/regions.htm).
* To get a list of Availability Domains, use the `ListAvailabilityDomains` operation
* in the Identity and Access Management Service API.
* <p>
All Oracle Cloud Infrastructure resources, including load balancers, get an Oracle-assigned,
* unique ID called an Oracle Cloud Identifier (OCID). When you create a resource, you can find its OCID
* in the response. You can also retrieve a resource's OCID by using a List API operation on that resource type,
* or by viewing the resource in the Console. Fore more information, see
* [Resource Identifiers](https://docs.cloud.oracle.com/Content/General/Concepts/identifiers.htm).
* <p>
After you send your request, the new object's state will temporarily be PROVISIONING. Before using the
* object, first make sure its state has changed to RUNNING.
* <p>
When you create a load balancer, the system assigns an IP address.
* To get the IP address, use the {@link #getLoadBalancer(GetLoadBalancerRequest) getLoadBalancer} operation.
* 
     * @param CreateLoadBalancerRequest
     * @return CreateLoadBalancerResponse
     * @throws OciError when an error occurs
     */
  public async createLoadBalancer(
    createLoadBalancerRequest: requests.CreateLoadBalancerRequest
  ): Promise<responses.CreateLoadBalancerResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-request-id": createLoadBalancerRequest.opcRequestId,
      "opc-retry-token": createLoadBalancerRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/loadBalancers",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createLoadBalancerRequest.createLoadBalancerDetails,
        "CreateLoadBalancerDetails",
        models.CreateLoadBalancerDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateLoadBalancerResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Adds a path route set to a load balancer. For more information, see
   * [Managing Request Routing](https://docs.cloud.oracle.com/Content/Balance/Tasks/managingrequest.htm).
   *
   * @param CreatePathRouteSetRequest
   * @return CreatePathRouteSetResponse
   * @throws OciError when an error occurs
   */
  public async createPathRouteSet(
    createPathRouteSetRequest: requests.CreatePathRouteSetRequest
  ): Promise<responses.CreatePathRouteSetResponse> {
    const pathParams = {
      "{loadBalancerId}": createPathRouteSetRequest.loadBalancerId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": createPathRouteSetRequest.opcRequestId,
      "opc-retry-token": createPathRouteSetRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/loadBalancers/{loadBalancerId}/pathRouteSets",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createPathRouteSetRequest.createPathRouteSetDetails,
        "CreatePathRouteSetDetails",
        models.CreatePathRouteSetDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreatePathRouteSetResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new rule set associated with the specified load balancer. For more information, see
   * [Managing Rule Sets](https://docs.cloud.oracle.com/Content/Balance/Tasks/managingrulesets.htm).
   *
   * @param CreateRuleSetRequest
   * @return CreateRuleSetResponse
   * @throws OciError when an error occurs
   */
  public async createRuleSet(
    createRuleSetRequest: requests.CreateRuleSetRequest
  ): Promise<responses.CreateRuleSetResponse> {
    const pathParams = {
      "{loadBalancerId}": createRuleSetRequest.loadBalancerId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": createRuleSetRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/loadBalancers/{loadBalancerId}/ruleSets",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createRuleSetRequest.createRuleSetDetails,
        "CreateRuleSetDetails",
        models.CreateRuleSetDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateRuleSetResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Removes a backend server from a given load balancer and backend set.
   * @param DeleteBackendRequest
   * @return DeleteBackendResponse
   * @throws OciError when an error occurs
   */
  public async deleteBackend(
    deleteBackendRequest: requests.DeleteBackendRequest
  ): Promise<responses.DeleteBackendResponse> {
    const pathParams = {
      "{loadBalancerId}": deleteBackendRequest.loadBalancerId,
      "{backendSetName}": deleteBackendRequest.backendSetName,
      "{backendName}": deleteBackendRequest.backendName
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": deleteBackendRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/loadBalancers/{loadBalancerId}/backendSets/{backendSetName}/backends/{backendName}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteBackendResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Deletes the specified backend set. Note that deleting a backend set removes its backend servers from the load balancer.
* <p>
Before you can delete a backend set, you must remove it from any active listeners.
* 
     * @param DeleteBackendSetRequest
     * @return DeleteBackendSetResponse
     * @throws OciError when an error occurs
     */
  public async deleteBackendSet(
    deleteBackendSetRequest: requests.DeleteBackendSetRequest
  ): Promise<responses.DeleteBackendSetResponse> {
    const pathParams = {
      "{loadBalancerId}": deleteBackendSetRequest.loadBalancerId,
      "{backendSetName}": deleteBackendSetRequest.backendSetName
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": deleteBackendSetRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/loadBalancers/{loadBalancerId}/backendSets/{backendSetName}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteBackendSetResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Deletes an SSL certificate bundle from a load balancer.
   * @param DeleteCertificateRequest
   * @return DeleteCertificateResponse
   * @throws OciError when an error occurs
   */
  public async deleteCertificate(
    deleteCertificateRequest: requests.DeleteCertificateRequest
  ): Promise<responses.DeleteCertificateResponse> {
    const pathParams = {
      "{loadBalancerId}": deleteCertificateRequest.loadBalancerId,
      "{certificateName}": deleteCertificateRequest.certificateName
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": deleteCertificateRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/loadBalancers/{loadBalancerId}/certificates/{certificateName}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteCertificateResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Deletes a hostname resource from the specified load balancer.
   *
   * @param DeleteHostnameRequest
   * @return DeleteHostnameResponse
   * @throws OciError when an error occurs
   */
  public async deleteHostname(
    deleteHostnameRequest: requests.DeleteHostnameRequest
  ): Promise<responses.DeleteHostnameResponse> {
    const pathParams = {
      "{loadBalancerId}": deleteHostnameRequest.loadBalancerId,
      "{name}": deleteHostnameRequest.name
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": deleteHostnameRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/loadBalancers/{loadBalancerId}/hostnames/{name}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteHostnameResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Deletes a listener from a load balancer.
   * @param DeleteListenerRequest
   * @return DeleteListenerResponse
   * @throws OciError when an error occurs
   */
  public async deleteListener(
    deleteListenerRequest: requests.DeleteListenerRequest
  ): Promise<responses.DeleteListenerResponse> {
    const pathParams = {
      "{loadBalancerId}": deleteListenerRequest.loadBalancerId,
      "{listenerName}": deleteListenerRequest.listenerName
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": deleteListenerRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/loadBalancers/{loadBalancerId}/listeners/{listenerName}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteListenerResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Stops a load balancer and removes it from service.
   * @param DeleteLoadBalancerRequest
   * @return DeleteLoadBalancerResponse
   * @throws OciError when an error occurs
   */
  public async deleteLoadBalancer(
    deleteLoadBalancerRequest: requests.DeleteLoadBalancerRequest
  ): Promise<responses.DeleteLoadBalancerResponse> {
    const pathParams = {
      "{loadBalancerId}": deleteLoadBalancerRequest.loadBalancerId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": deleteLoadBalancerRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/loadBalancers/{loadBalancerId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteLoadBalancerResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Deletes a path route set from the specified load balancer.
* <p>
To delete a path route rule from a path route set, use the
* {@link #updatePathRouteSet(UpdatePathRouteSetRequest) updatePathRouteSet} operation.
* 
     * @param DeletePathRouteSetRequest
     * @return DeletePathRouteSetResponse
     * @throws OciError when an error occurs
     */
  public async deletePathRouteSet(
    deletePathRouteSetRequest: requests.DeletePathRouteSetRequest
  ): Promise<responses.DeletePathRouteSetResponse> {
    const pathParams = {
      "{loadBalancerId}": deletePathRouteSetRequest.loadBalancerId,
      "{pathRouteSetName}": deletePathRouteSetRequest.pathRouteSetName
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": deletePathRouteSetRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/loadBalancers/{loadBalancerId}/pathRouteSets/{pathRouteSetName}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeletePathRouteSetResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Deletes a rule set from the specified load balancer.
* <p>
To delete a rule from a rule set, use the
* {@link #updateRuleSet(UpdateRuleSetRequest) updateRuleSet} operation.
* 
     * @param DeleteRuleSetRequest
     * @return DeleteRuleSetResponse
     * @throws OciError when an error occurs
     */
  public async deleteRuleSet(
    deleteRuleSetRequest: requests.DeleteRuleSetRequest
  ): Promise<responses.DeleteRuleSetResponse> {
    const pathParams = {
      "{loadBalancerId}": deleteRuleSetRequest.loadBalancerId,
      "{ruleSetName}": deleteRuleSetRequest.ruleSetName
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": deleteRuleSetRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/loadBalancers/{loadBalancerId}/ruleSets/{ruleSetName}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteRuleSetResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the specified backend server's configuration information.
   * @param GetBackendRequest
   * @return GetBackendResponse
   * @throws OciError when an error occurs
   */
  public async getBackend(
    getBackendRequest: requests.GetBackendRequest
  ): Promise<responses.GetBackendResponse> {
    const pathParams = {
      "{loadBalancerId}": getBackendRequest.loadBalancerId,
      "{backendSetName}": getBackendRequest.backendSetName,
      "{backendName}": getBackendRequest.backendName
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getBackendRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/loadBalancers/{loadBalancerId}/backendSets/{backendSetName}/backends/{backendName}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetBackendResponse>{},
        body: await response.json(),
        bodyKey: "backend",
        bodyModel: "model.Backend",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the current health status of the specified backend server.
   * @param GetBackendHealthRequest
   * @return GetBackendHealthResponse
   * @throws OciError when an error occurs
   */
  public async getBackendHealth(
    getBackendHealthRequest: requests.GetBackendHealthRequest
  ): Promise<responses.GetBackendHealthResponse> {
    const pathParams = {
      "{loadBalancerId}": getBackendHealthRequest.loadBalancerId,
      "{backendSetName}": getBackendHealthRequest.backendSetName,
      "{backendName}": getBackendHealthRequest.backendName
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getBackendHealthRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path:
        "/loadBalancers/{loadBalancerId}/backendSets/{backendSetName}/backends/{backendName}/health",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetBackendHealthResponse>{},
        body: await response.json(),
        bodyKey: "backendHealth",
        bodyModel: "model.BackendHealth",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the specified backend set's configuration information.
   * @param GetBackendSetRequest
   * @return GetBackendSetResponse
   * @throws OciError when an error occurs
   */
  public async getBackendSet(
    getBackendSetRequest: requests.GetBackendSetRequest
  ): Promise<responses.GetBackendSetResponse> {
    const pathParams = {
      "{loadBalancerId}": getBackendSetRequest.loadBalancerId,
      "{backendSetName}": getBackendSetRequest.backendSetName
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getBackendSetRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/loadBalancers/{loadBalancerId}/backendSets/{backendSetName}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetBackendSetResponse>{},
        body: await response.json(),
        bodyKey: "backendSet",
        bodyModel: "model.BackendSet",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the health status for the specified backend set.
   * @param GetBackendSetHealthRequest
   * @return GetBackendSetHealthResponse
   * @throws OciError when an error occurs
   */
  public async getBackendSetHealth(
    getBackendSetHealthRequest: requests.GetBackendSetHealthRequest
  ): Promise<responses.GetBackendSetHealthResponse> {
    const pathParams = {
      "{loadBalancerId}": getBackendSetHealthRequest.loadBalancerId,
      "{backendSetName}": getBackendSetHealthRequest.backendSetName
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getBackendSetHealthRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/loadBalancers/{loadBalancerId}/backendSets/{backendSetName}/health",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetBackendSetHealthResponse>{},
        body: await response.json(),
        bodyKey: "backendSetHealth",
        bodyModel: "model.BackendSetHealth",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the health check policy information for a given load balancer and backend set.
   * @param GetHealthCheckerRequest
   * @return GetHealthCheckerResponse
   * @throws OciError when an error occurs
   */
  public async getHealthChecker(
    getHealthCheckerRequest: requests.GetHealthCheckerRequest
  ): Promise<responses.GetHealthCheckerResponse> {
    const pathParams = {
      "{loadBalancerId}": getHealthCheckerRequest.loadBalancerId,
      "{backendSetName}": getHealthCheckerRequest.backendSetName
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getHealthCheckerRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/loadBalancers/{loadBalancerId}/backendSets/{backendSetName}/healthChecker",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetHealthCheckerResponse>{},
        body: await response.json(),
        bodyKey: "healthChecker",
        bodyModel: "model.HealthChecker",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the specified hostname resource's configuration information.
   * @param GetHostnameRequest
   * @return GetHostnameResponse
   * @throws OciError when an error occurs
   */
  public async getHostname(
    getHostnameRequest: requests.GetHostnameRequest
  ): Promise<responses.GetHostnameResponse> {
    const pathParams = {
      "{loadBalancerId}": getHostnameRequest.loadBalancerId,
      "{name}": getHostnameRequest.name
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getHostnameRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/loadBalancers/{loadBalancerId}/hostnames/{name}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetHostnameResponse>{},
        body: await response.json(),
        bodyKey: "hostname",
        bodyModel: "model.Hostname",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the specified load balancer's configuration information.
   * @param GetLoadBalancerRequest
   * @return GetLoadBalancerResponse
   * @throws OciError when an error occurs
   */
  public async getLoadBalancer(
    getLoadBalancerRequest: requests.GetLoadBalancerRequest
  ): Promise<responses.GetLoadBalancerResponse> {
    const pathParams = {
      "{loadBalancerId}": getLoadBalancerRequest.loadBalancerId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getLoadBalancerRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/loadBalancers/{loadBalancerId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetLoadBalancerResponse>{},
        body: await response.json(),
        bodyKey: "loadBalancer",
        bodyModel: "model.LoadBalancer",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the health status for the specified load balancer.
   * @param GetLoadBalancerHealthRequest
   * @return GetLoadBalancerHealthResponse
   * @throws OciError when an error occurs
   */
  public async getLoadBalancerHealth(
    getLoadBalancerHealthRequest: requests.GetLoadBalancerHealthRequest
  ): Promise<responses.GetLoadBalancerHealthResponse> {
    const pathParams = {
      "{loadBalancerId}": getLoadBalancerHealthRequest.loadBalancerId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getLoadBalancerHealthRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/loadBalancers/{loadBalancerId}/health",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetLoadBalancerHealthResponse>{},
        body: await response.json(),
        bodyKey: "loadBalancerHealth",
        bodyModel: "model.LoadBalancerHealth",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the specified path route set's configuration information.
   * @param GetPathRouteSetRequest
   * @return GetPathRouteSetResponse
   * @throws OciError when an error occurs
   */
  public async getPathRouteSet(
    getPathRouteSetRequest: requests.GetPathRouteSetRequest
  ): Promise<responses.GetPathRouteSetResponse> {
    const pathParams = {
      "{loadBalancerId}": getPathRouteSetRequest.loadBalancerId,
      "{pathRouteSetName}": getPathRouteSetRequest.pathRouteSetName
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getPathRouteSetRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/loadBalancers/{loadBalancerId}/pathRouteSets/{pathRouteSetName}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetPathRouteSetResponse>{},
        body: await response.json(),
        bodyKey: "pathRouteSet",
        bodyModel: "model.PathRouteSet",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the specified set of rules.
   * @param GetRuleSetRequest
   * @return GetRuleSetResponse
   * @throws OciError when an error occurs
   */
  public async getRuleSet(
    getRuleSetRequest: requests.GetRuleSetRequest
  ): Promise<responses.GetRuleSetResponse> {
    const pathParams = {
      "{loadBalancerId}": getRuleSetRequest.loadBalancerId,
      "{ruleSetName}": getRuleSetRequest.ruleSetName
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getRuleSetRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/loadBalancers/{loadBalancerId}/ruleSets/{ruleSetName}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetRuleSetResponse>{},
        body: await response.json(),
        bodyKey: "ruleSet",
        bodyModel: "model.RuleSet",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the details of a work request.
   * @param GetWorkRequestRequest
   * @return GetWorkRequestResponse
   * @throws OciError when an error occurs
   */
  public async getWorkRequest(
    getWorkRequestRequest: requests.GetWorkRequestRequest
  ): Promise<responses.GetWorkRequestResponse> {
    const pathParams = {
      "{workRequestId}": getWorkRequestRequest.workRequestId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getWorkRequestRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/loadBalancerWorkRequests/{workRequestId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetWorkRequestResponse>{},
        body: await response.json(),
        bodyKey: "workRequest",
        bodyModel: "model.WorkRequest",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Lists all backend sets associated with a given load balancer.
   * @param ListBackendSetsRequest
   * @return ListBackendSetsResponse
   * @throws OciError when an error occurs
   */
  public async listBackendSets(
    listBackendSetsRequest: requests.ListBackendSetsRequest
  ): Promise<responses.ListBackendSetsResponse> {
    const pathParams = {
      "{loadBalancerId}": listBackendSetsRequest.loadBalancerId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": listBackendSetsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/loadBalancers/{loadBalancerId}/backendSets",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListBackendSetsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "BackendSet[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Lists the backend servers for a given load balancer and backend set.
   * @param ListBackendsRequest
   * @return ListBackendsResponse
   * @throws OciError when an error occurs
   */
  public async listBackends(
    listBackendsRequest: requests.ListBackendsRequest
  ): Promise<responses.ListBackendsResponse> {
    const pathParams = {
      "{loadBalancerId}": listBackendsRequest.loadBalancerId,
      "{backendSetName}": listBackendsRequest.backendSetName
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": listBackendsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/loadBalancers/{loadBalancerId}/backendSets/{backendSetName}/backends",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListBackendsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "Backend[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Lists all SSL certificates bundles associated with a given load balancer.
   * @param ListCertificatesRequest
   * @return ListCertificatesResponse
   * @throws OciError when an error occurs
   */
  public async listCertificates(
    listCertificatesRequest: requests.ListCertificatesRequest
  ): Promise<responses.ListCertificatesResponse> {
    const pathParams = {
      "{loadBalancerId}": listCertificatesRequest.loadBalancerId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": listCertificatesRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/loadBalancers/{loadBalancerId}/certificates",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListCertificatesResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "Certificate[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Lists all hostname resources associated with the specified load balancer.
   * @param ListHostnamesRequest
   * @return ListHostnamesResponse
   * @throws OciError when an error occurs
   */
  public async listHostnames(
    listHostnamesRequest: requests.ListHostnamesRequest
  ): Promise<responses.ListHostnamesResponse> {
    const pathParams = {
      "{loadBalancerId}": listHostnamesRequest.loadBalancerId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": listHostnamesRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/loadBalancers/{loadBalancerId}/hostnames",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListHostnamesResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "Hostname[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Lists all of the rules from all of the rule sets associated with the specified listener. The response organizes
   * the rules in the following order:
   * <p>
   *  Access control rules
   * *  Allow method rules
   * *  Request header rules
   * *  Response header rules
   *
   * @param ListListenerRulesRequest
   * @return ListListenerRulesResponse
   * @throws OciError when an error occurs
   */
  public async listListenerRules(
    listListenerRulesRequest: requests.ListListenerRulesRequest
  ): Promise<responses.ListListenerRulesResponse> {
    const pathParams = {
      "{loadBalancerId}": listListenerRulesRequest.loadBalancerId,
      "{listenerName}": listListenerRulesRequest.listenerName
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": listListenerRulesRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/loadBalancers/{loadBalancerId}/listeners/{listenerName}/rules",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListListenerRulesResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "ListenerRuleSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Lists the summary health statuses for all load balancers in the specified compartment.
   * @param ListLoadBalancerHealthsRequest
   * @return ListLoadBalancerHealthsResponse
   * @throws OciError when an error occurs
   */
  public async listLoadBalancerHealths(
    listLoadBalancerHealthsRequest: requests.ListLoadBalancerHealthsRequest
  ): Promise<responses.ListLoadBalancerHealthsResponse> {
    const pathParams = {};

    const queryParams = {
      "limit": listLoadBalancerHealthsRequest.limit,
      "page": listLoadBalancerHealthsRequest.page,
      "compartmentId": listLoadBalancerHealthsRequest.compartmentId
    };

    let headerParams = {
      "opc-request-id": listLoadBalancerHealthsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/loadBalancerHealths",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListLoadBalancerHealthsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "LoadBalancerHealthSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.LoadBalancerHealthSummary objects
   * contained in responses from the listLoadBalancerHealths operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllLoadBalancerHealths(
    request: requests.ListLoadBalancerHealthsRequest
  ): AsyncIterableIterator<models.LoadBalancerHealthSummary> {
    return paginateRecords(request, req => this.listLoadBalancerHealths(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listLoadBalancerHealths operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllLoadBalancerHealthsResponses(
    request: requests.ListLoadBalancerHealthsRequest
  ): AsyncIterableIterator<responses.ListLoadBalancerHealthsResponse> {
    return paginateResponses(request, req => this.listLoadBalancerHealths(req));
  }

  /**
   * Lists all load balancers in the specified compartment.
   * @param ListLoadBalancersRequest
   * @return ListLoadBalancersResponse
   * @throws OciError when an error occurs
   */
  public async listLoadBalancers(
    listLoadBalancersRequest: requests.ListLoadBalancersRequest
  ): Promise<responses.ListLoadBalancersResponse> {
    const pathParams = {};

    const queryParams = {
      "limit": listLoadBalancersRequest.limit,
      "page": listLoadBalancersRequest.page,
      "compartmentId": listLoadBalancersRequest.compartmentId,
      "detail": listLoadBalancersRequest.detail,
      "sortBy": listLoadBalancersRequest.sortBy,
      "sortOrder": listLoadBalancersRequest.sortOrder,
      "displayName": listLoadBalancersRequest.displayName,
      "lifecycleState": listLoadBalancersRequest.lifecycleState
    };

    let headerParams = {
      "opc-request-id": listLoadBalancersRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/loadBalancers",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListLoadBalancersResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "LoadBalancer[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.LoadBalancer objects
   * contained in responses from the listLoadBalancers operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllLoadBalancers(
    request: requests.ListLoadBalancersRequest
  ): AsyncIterableIterator<models.LoadBalancer> {
    return paginateRecords(request, req => this.listLoadBalancers(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listLoadBalancers operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllLoadBalancersResponses(
    request: requests.ListLoadBalancersRequest
  ): AsyncIterableIterator<responses.ListLoadBalancersResponse> {
    return paginateResponses(request, req => this.listLoadBalancers(req));
  }

  /**
   * Lists all path route sets associated with the specified load balancer.
   * @param ListPathRouteSetsRequest
   * @return ListPathRouteSetsResponse
   * @throws OciError when an error occurs
   */
  public async listPathRouteSets(
    listPathRouteSetsRequest: requests.ListPathRouteSetsRequest
  ): Promise<responses.ListPathRouteSetsResponse> {
    const pathParams = {
      "{loadBalancerId}": listPathRouteSetsRequest.loadBalancerId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": listPathRouteSetsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/loadBalancers/{loadBalancerId}/pathRouteSets",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListPathRouteSetsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "PathRouteSet[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Lists the available load balancer policies.
   * @param ListPoliciesRequest
   * @return ListPoliciesResponse
   * @throws OciError when an error occurs
   */
  public async listPolicies(
    listPoliciesRequest: requests.ListPoliciesRequest
  ): Promise<responses.ListPoliciesResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listPoliciesRequest.compartmentId,
      "limit": listPoliciesRequest.limit,
      "page": listPoliciesRequest.page
    };

    let headerParams = {
      "opc-request-id": listPoliciesRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/loadBalancerPolicies",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListPoliciesResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "LoadBalancerPolicy[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.LoadBalancerPolicy objects
   * contained in responses from the listPolicies operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllPolicies(
    request: requests.ListPoliciesRequest
  ): AsyncIterableIterator<models.LoadBalancerPolicy> {
    return paginateRecords(request, req => this.listPolicies(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listPolicies operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllPoliciesResponses(
    request: requests.ListPoliciesRequest
  ): AsyncIterableIterator<responses.ListPoliciesResponse> {
    return paginateResponses(request, req => this.listPolicies(req));
  }

  /**
   * Lists all supported traffic protocols.
   * @param ListProtocolsRequest
   * @return ListProtocolsResponse
   * @throws OciError when an error occurs
   */
  public async listProtocols(
    listProtocolsRequest: requests.ListProtocolsRequest
  ): Promise<responses.ListProtocolsResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listProtocolsRequest.compartmentId,
      "limit": listProtocolsRequest.limit,
      "page": listProtocolsRequest.page
    };

    let headerParams = {
      "opc-request-id": listProtocolsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/loadBalancerProtocols",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListProtocolsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "LoadBalancerProtocol[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.LoadBalancerProtocol objects
   * contained in responses from the listProtocols operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllProtocols(
    request: requests.ListProtocolsRequest
  ): AsyncIterableIterator<models.LoadBalancerProtocol> {
    return paginateRecords(request, req => this.listProtocols(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listProtocols operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllProtocolsResponses(
    request: requests.ListProtocolsRequest
  ): AsyncIterableIterator<responses.ListProtocolsResponse> {
    return paginateResponses(request, req => this.listProtocols(req));
  }

  /**
   * Lists all rule sets associated with the specified load balancer.
   * @param ListRuleSetsRequest
   * @return ListRuleSetsResponse
   * @throws OciError when an error occurs
   */
  public async listRuleSets(
    listRuleSetsRequest: requests.ListRuleSetsRequest
  ): Promise<responses.ListRuleSetsResponse> {
    const pathParams = {
      "{loadBalancerId}": listRuleSetsRequest.loadBalancerId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": listRuleSetsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/loadBalancers/{loadBalancerId}/ruleSets",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListRuleSetsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "RuleSet[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Lists the valid load balancer shapes.
   * @param ListShapesRequest
   * @return ListShapesResponse
   * @throws OciError when an error occurs
   */
  public async listShapes(
    listShapesRequest: requests.ListShapesRequest
  ): Promise<responses.ListShapesResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listShapesRequest.compartmentId,
      "limit": listShapesRequest.limit,
      "page": listShapesRequest.page
    };

    let headerParams = {
      "opc-request-id": listShapesRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/loadBalancerShapes",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListShapesResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "LoadBalancerShape[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.LoadBalancerShape objects
   * contained in responses from the listShapes operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllShapes(
    request: requests.ListShapesRequest
  ): AsyncIterableIterator<models.LoadBalancerShape> {
    return paginateRecords(request, req => this.listShapes(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listShapes operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllShapesResponses(
    request: requests.ListShapesRequest
  ): AsyncIterableIterator<responses.ListShapesResponse> {
    return paginateResponses(request, req => this.listShapes(req));
  }

  /**
   * Lists the work requests for a given load balancer.
   * @param ListWorkRequestsRequest
   * @return ListWorkRequestsResponse
   * @throws OciError when an error occurs
   */
  public async listWorkRequests(
    listWorkRequestsRequest: requests.ListWorkRequestsRequest
  ): Promise<responses.ListWorkRequestsResponse> {
    const pathParams = {
      "{loadBalancerId}": listWorkRequestsRequest.loadBalancerId
    };

    const queryParams = {
      "limit": listWorkRequestsRequest.limit,
      "page": listWorkRequestsRequest.page
    };

    let headerParams = {
      "opc-request-id": listWorkRequestsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/loadBalancers/{loadBalancerId}/workRequests",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListWorkRequestsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "WorkRequest[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.WorkRequest objects
   * contained in responses from the listWorkRequests operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllWorkRequests(
    request: requests.ListWorkRequestsRequest
  ): AsyncIterableIterator<models.WorkRequest> {
    return paginateRecords(request, req => this.listWorkRequests(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listWorkRequests operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllWorkRequestsResponses(
    request: requests.ListWorkRequestsRequest
  ): AsyncIterableIterator<responses.ListWorkRequestsResponse> {
    return paginateResponses(request, req => this.listWorkRequests(req));
  }

  /**
   * Updates the configuration of a backend server within the specified backend set.
   * @param UpdateBackendRequest
   * @return UpdateBackendResponse
   * @throws OciError when an error occurs
   */
  public async updateBackend(
    updateBackendRequest: requests.UpdateBackendRequest
  ): Promise<responses.UpdateBackendResponse> {
    const pathParams = {
      "{loadBalancerId}": updateBackendRequest.loadBalancerId,
      "{backendSetName}": updateBackendRequest.backendSetName,
      "{backendName}": updateBackendRequest.backendName
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": updateBackendRequest.opcRequestId,
      "opc-retry-token": updateBackendRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/loadBalancers/{loadBalancerId}/backendSets/{backendSetName}/backends/{backendName}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateBackendRequest.updateBackendDetails,
        "UpdateBackendDetails",
        models.UpdateBackendDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateBackendResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates a backend set.
   * @param UpdateBackendSetRequest
   * @return UpdateBackendSetResponse
   * @throws OciError when an error occurs
   */
  public async updateBackendSet(
    updateBackendSetRequest: requests.UpdateBackendSetRequest
  ): Promise<responses.UpdateBackendSetResponse> {
    const pathParams = {
      "{loadBalancerId}": updateBackendSetRequest.loadBalancerId,
      "{backendSetName}": updateBackendSetRequest.backendSetName
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": updateBackendSetRequest.opcRequestId,
      "opc-retry-token": updateBackendSetRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/loadBalancers/{loadBalancerId}/backendSets/{backendSetName}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateBackendSetRequest.updateBackendSetDetails,
        "UpdateBackendSetDetails",
        models.UpdateBackendSetDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateBackendSetResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates the health check policy for a given load balancer and backend set.
   * @param UpdateHealthCheckerRequest
   * @return UpdateHealthCheckerResponse
   * @throws OciError when an error occurs
   */
  public async updateHealthChecker(
    updateHealthCheckerRequest: requests.UpdateHealthCheckerRequest
  ): Promise<responses.UpdateHealthCheckerResponse> {
    const pathParams = {
      "{loadBalancerId}": updateHealthCheckerRequest.loadBalancerId,
      "{backendSetName}": updateHealthCheckerRequest.backendSetName
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": updateHealthCheckerRequest.opcRequestId,
      "opc-retry-token": updateHealthCheckerRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/loadBalancers/{loadBalancerId}/backendSets/{backendSetName}/healthChecker",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateHealthCheckerRequest.healthChecker,
        "UpdateHealthCheckerDetails",
        models.UpdateHealthCheckerDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateHealthCheckerResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Overwrites an existing hostname resource on the specified load balancer. Use this operation to change a
   * virtual hostname.
   *
   * @param UpdateHostnameRequest
   * @return UpdateHostnameResponse
   * @throws OciError when an error occurs
   */
  public async updateHostname(
    updateHostnameRequest: requests.UpdateHostnameRequest
  ): Promise<responses.UpdateHostnameResponse> {
    const pathParams = {
      "{loadBalancerId}": updateHostnameRequest.loadBalancerId,
      "{name}": updateHostnameRequest.name
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": updateHostnameRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/loadBalancers/{loadBalancerId}/hostnames/{name}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateHostnameRequest.updateHostnameDetails,
        "UpdateHostnameDetails",
        models.UpdateHostnameDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateHostnameResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates a listener for a given load balancer.
   * @param UpdateListenerRequest
   * @return UpdateListenerResponse
   * @throws OciError when an error occurs
   */
  public async updateListener(
    updateListenerRequest: requests.UpdateListenerRequest
  ): Promise<responses.UpdateListenerResponse> {
    const pathParams = {
      "{loadBalancerId}": updateListenerRequest.loadBalancerId,
      "{listenerName}": updateListenerRequest.listenerName
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": updateListenerRequest.opcRequestId,
      "opc-retry-token": updateListenerRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/loadBalancers/{loadBalancerId}/listeners/{listenerName}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateListenerRequest.updateListenerDetails,
        "UpdateListenerDetails",
        models.UpdateListenerDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateListenerResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates a load balancer's configuration.
   * @param UpdateLoadBalancerRequest
   * @return UpdateLoadBalancerResponse
   * @throws OciError when an error occurs
   */
  public async updateLoadBalancer(
    updateLoadBalancerRequest: requests.UpdateLoadBalancerRequest
  ): Promise<responses.UpdateLoadBalancerResponse> {
    const pathParams = {
      "{loadBalancerId}": updateLoadBalancerRequest.loadBalancerId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": updateLoadBalancerRequest.opcRequestId,
      "opc-retry-token": updateLoadBalancerRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/loadBalancers/{loadBalancerId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateLoadBalancerRequest.updateLoadBalancerDetails,
        "UpdateLoadBalancerDetails",
        models.UpdateLoadBalancerDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateLoadBalancerResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates the network security groups associated with the specified load balancer.
   * @param UpdateNetworkSecurityGroupsRequest
   * @return UpdateNetworkSecurityGroupsResponse
   * @throws OciError when an error occurs
   */
  public async updateNetworkSecurityGroups(
    updateNetworkSecurityGroupsRequest: requests.UpdateNetworkSecurityGroupsRequest
  ): Promise<responses.UpdateNetworkSecurityGroupsResponse> {
    const pathParams = {
      "{loadBalancerId}": updateNetworkSecurityGroupsRequest.loadBalancerId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": updateNetworkSecurityGroupsRequest.opcRequestId,
      "opc-retry-token": updateNetworkSecurityGroupsRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/loadBalancers/{loadBalancerId}/networkSecurityGroups",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateNetworkSecurityGroupsRequest.updateNetworkSecurityGroupsDetails,
        "UpdateNetworkSecurityGroupsDetails",
        models.UpdateNetworkSecurityGroupsDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateNetworkSecurityGroupsResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Overwrites an existing path route set on the specified load balancer. Use this operation to add, delete, or alter
* path route rules in a path route set.
* <p>
To add a new path route rule to a path route set, the `pathRoutes` in the
* {@link #updatePathRouteSetDetails(UpdatePathRouteSetDetailsRequest) updatePathRouteSetDetails} object must include
* both the new path route rule to add and the existing path route rules to retain.
* 
     * @param UpdatePathRouteSetRequest
     * @return UpdatePathRouteSetResponse
     * @throws OciError when an error occurs
     */
  public async updatePathRouteSet(
    updatePathRouteSetRequest: requests.UpdatePathRouteSetRequest
  ): Promise<responses.UpdatePathRouteSetResponse> {
    const pathParams = {
      "{loadBalancerId}": updatePathRouteSetRequest.loadBalancerId,
      "{pathRouteSetName}": updatePathRouteSetRequest.pathRouteSetName
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": updatePathRouteSetRequest.opcRequestId,
      "opc-retry-token": updatePathRouteSetRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/loadBalancers/{loadBalancerId}/pathRouteSets/{pathRouteSetName}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updatePathRouteSetRequest.updatePathRouteSetDetails,
        "UpdatePathRouteSetDetails",
        models.UpdatePathRouteSetDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdatePathRouteSetResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Overwrites an existing set of rules on the specified load balancer. Use this operation to add or alter
* the rules in a rule set.
* <p>
To add a new rule to a set, the body must include both the new rule to add and the existing rules to retain.
* 
     * @param UpdateRuleSetRequest
     * @return UpdateRuleSetResponse
     * @throws OciError when an error occurs
     */
  public async updateRuleSet(
    updateRuleSetRequest: requests.UpdateRuleSetRequest
  ): Promise<responses.UpdateRuleSetResponse> {
    const pathParams = {
      "{loadBalancerId}": updateRuleSetRequest.loadBalancerId,
      "{ruleSetName}": updateRuleSetRequest.ruleSetName
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": updateRuleSetRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/loadBalancers/{loadBalancerId}/ruleSets/{ruleSetName}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateRuleSetRequest.updateRuleSetDetails,
        "UpdateRuleSetDetails",
        models.UpdateRuleSetDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);

    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateRuleSetResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      let errBody = null;
      if (response.json) {
        errBody = await response.json();
      }
      throw common.handleErrorResponse(response, errBody);
    }
  }
}
