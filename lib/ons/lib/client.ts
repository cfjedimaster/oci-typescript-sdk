/**
 * Notifications API
 * Use the Notifications API to broadcast messages to distributed components by topic, using a publish-subscribe pattern.
For information about managing topics, subscriptions, and messages, see [Notifications Overview](/iaas/Content/Notification/Concepts/notificationoverview.htm).

 * OpenAPI spec version: 20181201
 * 
 *
 * NOTE: This class is auto generated by OracleSDKGenerator.
 * Do not edit the class manually.
 *
 * Copyright (c) 2020, Oracle and/or its affiliates.  All rights reserved.
 * This software is dual-licensed to you under the Universal Permissive License (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl or Apache License 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose either license.
 */

import common = require("oci-common");
import * as requests from "./request";
import * as models from "./model";
import * as responses from "./response";
import { paginateRecords, paginateResponses } from "oci-common";
import { NotificationDataPlaneWaiter } from "./notificationdataplane-waiter";
import { composeResponse, composeRequest } from "oci-common";

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum NotificationControlPlaneApiKeys {}

export class NotificationControlPlaneClient {
  protected static serviceEndpointTemplate = "https://notification.{region}.{secondLevelDomain}";
  protected "_endpoint": string = "";
  protected "_defaultHeaders": any = {};

  protected _httpClient: common.HttpClient;

  constructor(params: common.AuthParams) {
    const requestSigner = params.authenticationDetailsProvider
      ? new common.DefaultRequestSigner(params.authenticationDetailsProvider)
      : null;
    this._httpClient = params.httpClient || new common.FetchHttpClient(requestSigner);

    if (
      params.authenticationDetailsProvider &&
      common.isRegionProvider(params.authenticationDetailsProvider)
    ) {
      const provider: common.RegionProvider = params.authenticationDetailsProvider;
      if (provider.getRegion()) {
        this.region = provider.getRegion();
      }
    }
  }

  /**
   * Sets the endpoint to call (ex, https://www.example.com).
   * @param endpoint The endpoint of the service.
   */
  public set endpoint(endpoint: string) {
    this._endpoint = endpoint;
    this._endpoint = this._endpoint + "/20181201";
  }

  /**
   * Sets the region to call (ex, Region.US_PHOENIX_1).
   * Note, this will call {@link #endpoint(String) endpoint} after resolving the endpoint.
   * @param region The region of the service.
   */
  public set region(region: common.Region) {
    this.endpoint = common.EndpointBuilder.createEndpointFromRegion(
      NotificationControlPlaneClient.serviceEndpointTemplate,
      region
    );
  }

  /**
   * Sets the regionId to call (ex, 'us-phoenix-1').
   *
   * Note, this will first try to map the region ID to a known Region and call {@link #region(Region) region}.
   * If no known Region could be determined, it will create an endpoint assuming its in default Realm OC1
   * and then call {@link #endpoint(String) endpoint}.
   * @param regionId The public region ID.
   */
  public set regionId(regionId: string) {
    this.endpoint = common.EndpointBuilder.createEndpointFromRegionId(
      NotificationControlPlaneClient.serviceEndpointTemplate,
      regionId
    );
  }

  /**
     * Moves a topic into a different compartment within the same tenancy. For information about moving resources
* between compartments, see
* [Moving Resources to a Different Compartment](https://docs.cloud.oracle.com/iaas/Content/Identity/Tasks/managingcompartments.htm#moveRes).
* <p>
Transactions Per Minute (TPM) per-tenancy limit for this operation: 60.
* 
     * @param ChangeTopicCompartmentRequest
     * @return ChangeTopicCompartmentResponse
     * @throws OciError when an error occurs
     */
  public async changeTopicCompartment(
    changeTopicCompartmentRequest: requests.ChangeTopicCompartmentRequest
  ): Promise<responses.ChangeTopicCompartmentResponse> {
    const pathParams = {
      "{topicId}": changeTopicCompartmentRequest.topicId
    };

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": changeTopicCompartmentRequest.opcRetryToken,
      "opc-request-id": changeTopicCompartmentRequest.opcRequestId,
      "if-match": changeTopicCompartmentRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/topics/{topicId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeTopicCompartmentRequest.changeTopicCompartmentDetails,
        "ChangeCompartmentDetails",
        models.ChangeCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeTopicCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Creates a topic in the specified compartment. For general information about topics, see
* [Managing Topics and Subscriptions](https://docs.cloud.oracle.com/iaas/Content/Notification/Tasks/managingtopicsandsubscriptions.htm).
* <p>
For the purposes of access control, you must provide the OCID of the compartment where you want the topic to reside.
* For information about access control and compartments, see [Overview of the IAM Service](https://docs.cloud.oracle.com/Content/Identity/Concepts/overview.htm).
* <p>
You must specify a display name for the topic.
* <p>
All Oracle Cloud Infrastructure resources, including topics, get an Oracle-assigned, unique ID called an
* Oracle Cloud Identifier (OCID). When you create a resource, you can find its OCID in the response. You can also
* retrieve a resource's OCID by using a List API operation on that resource type, or by viewing the resource in the
* Console. For more information, see [Resource Identifiers](https://docs.cloud.oracle.com/Content/General/Concepts/identifiers.htm).
* <p>
Transactions Per Minute (TPM) per-tenancy limit for this operation: 60.
* 
     * @param CreateTopicRequest
     * @return CreateTopicResponse
     * @throws OciError when an error occurs
     */
  public async createTopic(
    createTopicRequest: requests.CreateTopicRequest
  ): Promise<responses.CreateTopicResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createTopicRequest.opcRetryToken,
      "opc-request-id": createTopicRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/topics",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createTopicRequest.createTopicDetails,
        "CreateTopicDetails",
        models.CreateTopicDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateTopicResponse>{},
        body: await response.json(),
        bodyKey: "notificationTopic",
        bodyModel: "model.NotificationTopic",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Deletes the specified topic.
* <p>
Transactions Per Minute (TPM) per-tenancy limit for this operation: 60.
* 
     * @param DeleteTopicRequest
     * @return DeleteTopicResponse
     * @throws OciError when an error occurs
     */
  public async deleteTopic(
    deleteTopicRequest: requests.DeleteTopicRequest
  ): Promise<responses.DeleteTopicResponse> {
    const pathParams = {
      "{topicId}": deleteTopicRequest.topicId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": deleteTopicRequest.opcRequestId,
      "if-match": deleteTopicRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/topics/{topicId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteTopicResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the specified topic's configuration information.
   *
   * @param GetTopicRequest
   * @return GetTopicResponse
   * @throws OciError when an error occurs
   */
  public async getTopic(
    getTopicRequest: requests.GetTopicRequest
  ): Promise<responses.GetTopicResponse> {
    const pathParams = {
      "{topicId}": getTopicRequest.topicId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getTopicRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/topics/{topicId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetTopicResponse>{},
        body: await response.json(),
        bodyKey: "notificationTopic",
        bodyModel: "model.NotificationTopic",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Lists topics in the specified compartment.
* <p>
Transactions Per Minute (TPM) per-tenancy limit for this operation: 120.
* 
     * @param ListTopicsRequest
     * @return ListTopicsResponse
     * @throws OciError when an error occurs
     */
  public async listTopics(
    listTopicsRequest: requests.ListTopicsRequest
  ): Promise<responses.ListTopicsResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listTopicsRequest.compartmentId,
      "id": listTopicsRequest.id,
      "name": listTopicsRequest.name,
      "page": listTopicsRequest.page,
      "limit": listTopicsRequest.limit,
      "sortBy": listTopicsRequest.sortBy,
      "sortOrder": listTopicsRequest.sortOrder,
      "lifecycleState": listTopicsRequest.lifecycleState
    };

    let headerParams = {
      "opc-request-id": listTopicsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/topics",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListTopicsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "NotificationTopicSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.NotificationTopicSummary objects
   * contained in responses from the listTopics operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllTopics(
    request: requests.ListTopicsRequest
  ): AsyncIterableIterator<models.NotificationTopicSummary> {
    return paginateRecords(request, req => this.listTopics(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listTopics operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllTopicsResponses(
    request: requests.ListTopicsRequest
  ): AsyncIterableIterator<responses.ListTopicsResponse> {
    return paginateResponses(request, req => this.listTopics(req));
  }

  /**
     * Updates the specified topic's configuration.
* <p>
Transactions Per Minute (TPM) per-tenancy limit for this operation: 60.
* 
     * @param UpdateTopicRequest
     * @return UpdateTopicResponse
     * @throws OciError when an error occurs
     */
  public async updateTopic(
    updateTopicRequest: requests.UpdateTopicRequest
  ): Promise<responses.UpdateTopicResponse> {
    const pathParams = {
      "{topicId}": updateTopicRequest.topicId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": updateTopicRequest.opcRequestId,
      "if-match": updateTopicRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/topics/{topicId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateTopicRequest.topicAttributesDetails,
        "TopicAttributesDetails",
        models.TopicAttributesDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateTopicResponse>{},
        body: await response.json(),
        bodyKey: "notificationTopic",
        bodyModel: "model.NotificationTopic",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }
}
export enum NotificationDataPlaneApiKeys {}

export class NotificationDataPlaneClient {
  protected static serviceEndpointTemplate = "https://notification.{region}.{secondLevelDomain}";
  protected "_endpoint": string = "";
  protected "_defaultHeaders": any = {};
  protected "_waiters": NotificationDataPlaneWaiter;

  protected _httpClient: common.HttpClient;

  constructor(params: common.AuthParams) {
    const requestSigner = params.authenticationDetailsProvider
      ? new common.DefaultRequestSigner(params.authenticationDetailsProvider)
      : null;
    this._httpClient = params.httpClient || new common.FetchHttpClient(requestSigner);

    if (
      params.authenticationDetailsProvider &&
      common.isRegionProvider(params.authenticationDetailsProvider)
    ) {
      const provider: common.RegionProvider = params.authenticationDetailsProvider;
      if (provider.getRegion()) {
        this.region = provider.getRegion();
      }
    }
  }

  /**
   * Sets the endpoint to call (ex, https://www.example.com).
   * @param endpoint The endpoint of the service.
   */
  public set endpoint(endpoint: string) {
    this._endpoint = endpoint;
    this._endpoint = this._endpoint + "/20181201";
  }

  /**
   * Sets the region to call (ex, Region.US_PHOENIX_1).
   * Note, this will call {@link #endpoint(String) endpoint} after resolving the endpoint.
   * @param region The region of the service.
   */
  public set region(region: common.Region) {
    this.endpoint = common.EndpointBuilder.createEndpointFromRegion(
      NotificationDataPlaneClient.serviceEndpointTemplate,
      region
    );
  }

  /**
   * Sets the regionId to call (ex, 'us-phoenix-1').
   *
   * Note, this will first try to map the region ID to a known Region and call {@link #region(Region) region}.
   * If no known Region could be determined, it will create an endpoint assuming its in default Realm OC1
   * and then call {@link #endpoint(String) endpoint}.
   * @param regionId The public region ID.
   */
  public set regionId(regionId: string) {
    this.endpoint = common.EndpointBuilder.createEndpointFromRegionId(
      NotificationDataPlaneClient.serviceEndpointTemplate,
      regionId
    );
  }

  /**
   * Creates a new NotificationDataPlaneWaiter for resources for this service.
   *
   * @param config The waiter configuration for termination and delay strategy
   * @return The service waiters.
   */
  public createWaiters(config?: common.WaiterConfiguration): NotificationDataPlaneWaiter {
    this._waiters = new NotificationDataPlaneWaiter(this, config);
    return this._waiters;
  }

  /**
   * Gets the waiters available for resources for this service.
   *
   * @return The service waiters.
   */
  public getWaiters(): NotificationDataPlaneWaiter {
    if (this._waiters) {
      return this._waiters;
    }
    throw Error("Waiters do not exist. Please create waiters.");
  }

  /**
     * Moves a subscription into a different compartment within the same tenancy. For information about moving
* resources between compartments, see
* [Moving Resources to a Different Compartment](https://docs.cloud.oracle.com/iaas/Content/Identity/Tasks/managingcompartments.htm#moveRes).
* <p>
Transactions Per Minute (TPM) per-tenancy limit for this operation: 60.
* 
     * @param ChangeSubscriptionCompartmentRequest
     * @return ChangeSubscriptionCompartmentResponse
     * @throws OciError when an error occurs
     */
  public async changeSubscriptionCompartment(
    changeSubscriptionCompartmentRequest: requests.ChangeSubscriptionCompartmentRequest
  ): Promise<responses.ChangeSubscriptionCompartmentResponse> {
    const pathParams = {
      "{subscriptionId}": changeSubscriptionCompartmentRequest.subscriptionId
    };

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": changeSubscriptionCompartmentRequest.opcRetryToken,
      "opc-request-id": changeSubscriptionCompartmentRequest.opcRequestId,
      "if-match": changeSubscriptionCompartmentRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/subscriptions/{subscriptionId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeSubscriptionCompartmentRequest.changeSubscriptionCompartmentDetails,
        "ChangeCompartmentDetails",
        models.ChangeCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeSubscriptionCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Creates a subscription for the specified topic and sends a subscription confirmation URL to the endpoint. The subscription remains in \"Pending\" status until it has been confirmed.
* For information about confirming subscriptions, see
* [To confirm a subscription](https://docs.cloud.oracle.com/iaas/Content/Notification/Tasks/managingtopicsandsubscriptions.htm#confirmSub).
* <p>
Transactions Per Minute (TPM) per-tenancy limit for this operation: 60.
* 
     * @param CreateSubscriptionRequest
     * @return CreateSubscriptionResponse
     * @throws OciError when an error occurs
     */
  public async createSubscription(
    createSubscriptionRequest: requests.CreateSubscriptionRequest
  ): Promise<responses.CreateSubscriptionResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createSubscriptionRequest.opcRetryToken,
      "opc-request-id": createSubscriptionRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/subscriptions",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createSubscriptionRequest.createSubscriptionDetails,
        "CreateSubscriptionDetails",
        models.CreateSubscriptionDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateSubscriptionResponse>{},
        body: await response.json(),
        bodyKey: "subscription",
        bodyModel: "model.Subscription",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Deletes the specified subscription.
* <p>
Transactions Per Minute (TPM) per-tenancy limit for this operation: 60.
* 
     * @param DeleteSubscriptionRequest
     * @return DeleteSubscriptionResponse
     * @throws OciError when an error occurs
     */
  public async deleteSubscription(
    deleteSubscriptionRequest: requests.DeleteSubscriptionRequest
  ): Promise<responses.DeleteSubscriptionResponse> {
    const pathParams = {
      "{subscriptionId}": deleteSubscriptionRequest.subscriptionId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": deleteSubscriptionRequest.opcRequestId,
      "if-match": deleteSubscriptionRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/subscriptions/{subscriptionId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteSubscriptionResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Gets the confirmation details for the specified subscription.
* <p>
Transactions Per Minute (TPM) per-tenancy limit for this operation: 60.
* 
     * @param GetConfirmSubscriptionRequest
     * @return GetConfirmSubscriptionResponse
     * @throws OciError when an error occurs
     */
  public async getConfirmSubscription(
    getConfirmSubscriptionRequest: requests.GetConfirmSubscriptionRequest
  ): Promise<responses.GetConfirmSubscriptionResponse> {
    const pathParams = {
      "{id}": getConfirmSubscriptionRequest.id
    };

    const queryParams = {
      "token": getConfirmSubscriptionRequest.token,
      "protocol": getConfirmSubscriptionRequest.protocol
    };

    let headerParams = {
      "opc-request-id": getConfirmSubscriptionRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/subscriptions/{id}/confirmation",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetConfirmSubscriptionResponse>{},
        body: await response.json(),
        bodyKey: "confirmationResult",
        bodyModel: "model.ConfirmationResult",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Gets the specified subscription's configuration information.
* <p>
Transactions Per Minute (TPM) per-tenancy limit for this operation: 60.
* 
     * @param GetSubscriptionRequest
     * @return GetSubscriptionResponse
     * @throws OciError when an error occurs
     */
  public async getSubscription(
    getSubscriptionRequest: requests.GetSubscriptionRequest
  ): Promise<responses.GetSubscriptionResponse> {
    const pathParams = {
      "{subscriptionId}": getSubscriptionRequest.subscriptionId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getSubscriptionRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/subscriptions/{subscriptionId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetSubscriptionResponse>{},
        body: await response.json(),
        bodyKey: "subscription",
        bodyModel: "model.Subscription",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Gets the unsubscription details for the specified subscription.
* <p>
Transactions Per Minute (TPM) per-tenancy limit for this operation: 60.
* 
     * @param GetUnsubscriptionRequest
     * @return GetUnsubscriptionResponse
     * @throws OciError when an error occurs
     */
  public async getUnsubscription(
    getUnsubscriptionRequest: requests.GetUnsubscriptionRequest
  ): Promise<responses.GetUnsubscriptionResponse> {
    const pathParams = {
      "{id}": getUnsubscriptionRequest.id
    };

    const queryParams = {
      "token": getUnsubscriptionRequest.token,
      "protocol": getUnsubscriptionRequest.protocol
    };

    let headerParams = {
      "opc-request-id": getUnsubscriptionRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/subscriptions/{id}/unsubscription",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetUnsubscriptionResponse>{},
        body: await response.json(),
        bodyKey: "value",
        bodyModel: "string",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Lists the subscriptions in the specified compartment or topic.
* <p>
Transactions Per Minute (TPM) per-tenancy limit for this operation: 60.
* 
     * @param ListSubscriptionsRequest
     * @return ListSubscriptionsResponse
     * @throws OciError when an error occurs
     */
  public async listSubscriptions(
    listSubscriptionsRequest: requests.ListSubscriptionsRequest
  ): Promise<responses.ListSubscriptionsResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listSubscriptionsRequest.compartmentId,
      "topicId": listSubscriptionsRequest.topicId,
      "page": listSubscriptionsRequest.page,
      "limit": listSubscriptionsRequest.limit
    };

    let headerParams = {
      "opc-request-id": listSubscriptionsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/subscriptions",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListSubscriptionsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "SubscriptionSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.SubscriptionSummary objects
   * contained in responses from the listSubscriptions operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllSubscriptions(
    request: requests.ListSubscriptionsRequest
  ): AsyncIterableIterator<models.SubscriptionSummary> {
    return paginateRecords(request, req => this.listSubscriptions(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listSubscriptions operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllSubscriptionsResponses(
    request: requests.ListSubscriptionsRequest
  ): AsyncIterableIterator<responses.ListSubscriptionsResponse> {
    return paginateResponses(request, req => this.listSubscriptions(req));
  }

  /**
     * Publishes a message to the specified topic.
* <p>
The topic endpoint is required for this operation.
* To get the topic endpoint, use {@link #getTopic(GetTopicRequest) getTopic}
* and review the `apiEndpoint` value in the response ({@link NotificationTopic}).
* <p>
Limits information follows.
* <p>
Message size limit per request: 64KB.
* <p>
Message delivery rate limit per endpoint: 60 messages per minute for HTTP-based protocols, 10 messages per minute for the `EMAIL` protocol.
* HTTP-based protocols use URL endpoints that begin with \"http:\" or \"https:\".
* <p>
Transactions Per Minute (TPM) per-tenancy limit for this operation: 60 per topic.
* <p>
For more information about publishing messages, see [Publishing Messages](https://docs.cloud.oracle.com/iaas/Content/Notification/Tasks/publishingmessages.htm).
* For steps to request a limit increase, see [Requesting a Service Limit Increase](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/servicelimits.htm#three).
* 
     * @param PublishMessageRequest
     * @return PublishMessageResponse
     * @throws OciError when an error occurs
     */
  public async publishMessage(
    publishMessageRequest: requests.PublishMessageRequest
  ): Promise<responses.PublishMessageResponse> {
    const pathParams = {
      "{topicId}": publishMessageRequest.topicId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": publishMessageRequest.opcRequestId,
      "messageType": publishMessageRequest.messageType
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/topics/{topicId}/messages",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        publishMessageRequest.messageDetails,
        "MessageDetails",
        models.MessageDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.PublishMessageResponse>{},
        body: await response.json(),
        bodyKey: "publishResult",
        bodyModel: "model.PublishResult",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Resends the confirmation details for the specified subscription.
* <p>
Transactions Per Minute (TPM) per-tenancy limit for this operation: 60.
* 
     * @param ResendSubscriptionConfirmationRequest
     * @return ResendSubscriptionConfirmationResponse
     * @throws OciError when an error occurs
     */
  public async resendSubscriptionConfirmation(
    resendSubscriptionConfirmationRequest: requests.ResendSubscriptionConfirmationRequest
  ): Promise<responses.ResendSubscriptionConfirmationResponse> {
    const pathParams = {
      "{id}": resendSubscriptionConfirmationRequest.id
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": resendSubscriptionConfirmationRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/subscriptions/{id}/resendConfirmation",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ResendSubscriptionConfirmationResponse>{},
        body: await response.json(),
        bodyKey: "subscription",
        bodyModel: "model.Subscription",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Updates the specified subscription's configuration.
* <p>
Transactions Per Minute (TPM) per-tenancy limit for this operation: 60.
* 
     * @param UpdateSubscriptionRequest
     * @return UpdateSubscriptionResponse
     * @throws OciError when an error occurs
     */
  public async updateSubscription(
    updateSubscriptionRequest: requests.UpdateSubscriptionRequest
  ): Promise<responses.UpdateSubscriptionResponse> {
    const pathParams = {
      "{subscriptionId}": updateSubscriptionRequest.subscriptionId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": updateSubscriptionRequest.opcRequestId,
      "if-match": updateSubscriptionRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/subscriptions/{subscriptionId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateSubscriptionRequest.updateSubscriptionDetails,
        "UpdateSubscriptionDetails",
        models.UpdateSubscriptionDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateSubscriptionResponse>{},
        body: await response.json(),
        bodyKey: "updateSubscriptionDetails",
        bodyModel: "model.UpdateSubscriptionDetails",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }
}
